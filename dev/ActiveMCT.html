<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Active Mode-Coupling Theory · ModeCouplingTheory</title><meta name="title" content="Active Mode-Coupling Theory · ModeCouplingTheory"/><meta property="og:title" content="Active Mode-Coupling Theory · ModeCouplingTheory"/><meta property="twitter:title" content="Active Mode-Coupling Theory · ModeCouplingTheory"/><meta name="description" content="Documentation for ModeCouplingTheory."/><meta property="og:description" content="Documentation for ModeCouplingTheory."/><meta property="twitter:description" content="Documentation for ModeCouplingTheory."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">ModeCouplingTheory</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">Introduction</a></li><li><a class="tocitem" href="Problems_and_Solvers.html">Equations and Solvers</a></li><li><a class="tocitem" href="Kernels.html">Kernels</a></li><li><a class="tocitem" href="MCT.html">Mode-Coupling Theory</a></li><li><a class="tocitem" href="SCGLET.html">Self-Consistent Generalized Langevin Equation Theory</a></li><li class="is-active"><a class="tocitem" href="ActiveMCT.html">Active Mode-Coupling Theory</a><ul class="internal"><li><a class="tocitem" href="#Single-component-active-MCT"><span>Single-component active MCT</span></a></li><li><a class="tocitem" href="#Tagged-particle-kernel"><span>Tagged-particle kernel</span></a></li><li><a class="tocitem" href="#Multi-component-active-MCT"><span>Multi-component active MCT</span></a></li><li><a class="tocitem" href="#Note-on-input-data"><span>Note on input data</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="Scope.html">Scope</a></li><li><a class="tocitem" href="FromPython.html">From Python</a></li><li><a class="tocitem" href="internals.html">Internals</a></li><li><a class="tocitem" href="API.html">API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="ActiveMCT.html">Active Mode-Coupling Theory</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="ActiveMCT.html">Active Mode-Coupling Theory</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/IlianPihlajamaa/ModeCouplingTheory.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/IlianPihlajamaa/ModeCouplingTheory.jl/blob/main/docs/src/ActiveMCT.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h2 id="Single-component-active-MCT"><a class="docs-heading-anchor" href="#Single-component-active-MCT">Single-component active MCT</a><a id="Single-component-active-MCT-1"></a><a class="docs-heading-anchor-permalink" href="#Single-component-active-MCT" title="Permalink"></a></h2><p>Next to standard mode-coupling theory (MCT), we also implemented a mode-coupling theory for athermal self-propelled (active) particles as derived in [1][2]. Athermal means that there is no thermal motion. The equation we need to solve is slightly different than for passive mode-coupling theory:</p><p class="math-container">\[\ddot{F}(k,t) + \frac{1}{\tau_p}\dot{F}(k,t) + \frac{\omega(k) k^2}{S(k)}F(k,t) + \int_0^t \text{d}t&#39;\ M(k,t-t&#39;) \dot{F}(k,t&#39;) = 0.\]</p><p>Here, <span>$\tau_p$</span> is the persistence time of a single active particle. Active MCT requires extra input in the form of spatial velocity correlations <span>$\omega(k)$</span> and their infinite-wavelength limit <span>$\omega(\infty)$</span>. Since the effect of active forces is encoded in <span>$S(k)$</span>, <span>$\omega(k)$</span> and <span>$\omega(\infty)$</span>, the theory can be directly applied to different systems, such as active Brownian particles or active Ornstein-Uhlenbeck particles.</p><p>The memory kernel <span>$M(k,t)$</span> in <span>$d$</span> dimensions is given by</p><p class="math-container">\[M(k,t) = \frac{\rho\, \omega(k)}{2 (2\pi)^d} \int \text{d}\mathbf{q}\ V(\mathbf{k},\mathbf{q})^2 F(q,t) F(|\mathbf{k}-\mathbf{q}|,t).\]</p><p>We also need (modified) expressions for the vertices <span>$V(\mathbf{k},\mathbf{q})$</span> and direct correlation function <span>$\mathcal{C}(k)$</span>:</p><p class="math-container">\[V(\mathbf{k},\mathbf{q}) = \frac{\mathbf{k}\cdot\mathbf{q}}{k} \mathcal{C}(q) + \frac{\mathbf{k}\cdot(\mathbf{k}-\mathbf{q})}{k} \mathcal{C}(|\mathbf{k}-\mathbf{q}|)\]</p><p class="math-container">\[\rho \mathcal{C}(k) = 1 - \frac{\omega(k)}{w(\infty) S(k)}\]</p><p>The discretization of the kernel is described on the page &quot;Mode-Coupling Theory&quot;. The kernel is not implemented using Bengtzelius&#39; trick, as we are mostly interested in two-dimensional applications where this is not applicable. The dimensionality of the kernel can be chosen with the parameter <code>dim</code> (the default is <code>dim=3</code>). Already implemented functionalities from standard MCT were re-used so any dimension up to <span>$d \approx 20$</span> should be supported, although we only explicitly tested <code>dim=2</code> and <code>dim=3</code> for this kernel.</p><h3 id="Example-code-single-component"><a class="docs-heading-anchor" href="#Example-code-single-component">Example code single-component</a><a id="Example-code-single-component-1"></a><a class="docs-heading-anchor-permalink" href="#Example-code-single-component" title="Permalink"></a></h3><pre><code class="language-julia hljs">using ModeCouplingTheory, Plots

Nk = 50; kmax = 40; dk = kmax / Nk;
k_array = dk*(collect(1:Nk) .- 0.5);

η = 0.514;  # packing fraction
ρ = η*6/π;  # number density
τₚ = 1.0;   # persistence time

# use analytical functions as example data (as defined in &quot;Mode-Coupling Theory&quot;)
function find_analytical_C_k(k, η)
    A = -(1 - η)^-4 *(1 + 2η)^2
    B = (1 - η)^-4*  6η*(1 + η/2)^2
    D = -(1 - η)^-4 * 1/2 * η*(1 + 2η)^2
    Cₖ = @. 4π/k^6 * 
    (
        24*D - 2*B * k^2 - (24*D - 2 * (B + 6*D) * k^2 + (A + B + D) * k^4) * cos(k)
     + k * (-24*D + (A + 2*B + 4*D) * k^2) * sin(k)
    )
    return Cₖ
end

function find_analytical_S_k(k, η)
        Cₖ = find_analytical_C_k(k, η)
        ρ = 6/π * η
        Sₖ = @. 1 + ρ*Cₖ / (1 - ρ*Cₖ)
    return Sₖ
end

# there is no analytical expression for w(k), so we use an example function
# (w(k) is usually obtained from simulation data)
approx_wk(x) = @. 0.8*(1 + cos(1.5*x)*exp(-0.2*x));
wk = approx_wk(k_array);
w0=0.85;
Sk = find_analytical_S_k(k_array, η);

# memory equation coefficients
α = 1.0; β = 1/τₚ; δ = 0.0;
γ = @. k_array^2 * wk / Sk;
γp = @. k_array^2 * 1.0 / Sk; 

kernelA  = ActiveMCTKernel(ρ, k_array, wk, w0, Sk, 3);
problemA = MemoryEquation(α, β, γ, δ, Sk, zeros(Nk), kernelA);
solA     = solve(problemA);

# passive system for reference
kernelP  = ModeCouplingKernel(ρ, 1.0, 1.0, k_array, Sk);
problemP = MemoryEquation(0.0, 1.0, γp, δ, Sk, zeros(Nk), kernelP);
solP     = solve(problemP);

n  = 11;
t  = get_t(solA);
Fa = get_F(solA,:,n);
Fp = get_F(solP,:,n);

plot(t, Fa, xaxis=(:log10, [10^-4, :auto]), dpi=500, lc=:black, lw=2, labels=&quot;Active (τₚ=$(τₚ), w0=$(w0))&quot;, framestyle=:box)
plot!(t, Fp, lc=:orange, lw=2, ls=:dash, dpi=500, labels=&quot;Passive Brownian system&quot;)
xlabel!(&quot;time&quot;)
ylabel!(&quot;F(k,t)&quot;)
xlims!((1e-10,1e10))
title!(&quot;Active mode-coupling kernel for k = $(k_array[n]), η = $(η)&quot;)</code></pre><p><img src="images/activeMCT_sc_plot.png" alt="image"/></p><h2 id="Tagged-particle-kernel"><a class="docs-heading-anchor" href="#Tagged-particle-kernel">Tagged-particle kernel</a><a id="Tagged-particle-kernel-1"></a><a class="docs-heading-anchor-permalink" href="#Tagged-particle-kernel" title="Permalink"></a></h2><p>The dynamics of a tagged active particle is governed by the following equation [1]:</p><p class="math-container">\[\ddot{F}_s(k,t) + \frac{1}{\tau_p} \dot{F}_s(k,t) + w(\infty) k^2 F_s(k,t) + \int_0^t \text{d}t&#39;\ M_s(k,t-t&#39;) \dot{F}_s(k,t&#39;) = 0,\]</p><p>where <span>$F_s(k,t)$</span> is the self-intermediate scattering function. The memory kernel is given by</p><p class="math-container">\[M_s(k,t) = \frac{\rho\, w(\infty)}{(2\pi)^d} \int \text{d}\mathbf{q}\ \left( \frac{\mathbf{k}\cdot(\mathbf{k} - \mathbf{q})}{k} \right)^2 F_s(q,t) F(|\mathbf{k}-\mathbf{q}|,t).\]</p><p>The tagged-particle memory kernel requires the collective intermediate scattering function <span>$F(k,t)$</span> as input. An example implementation of the tagged active memory kernel is given below.</p><h3 id="Example-code-tagged-particle-kernel"><a class="docs-heading-anchor" href="#Example-code-tagged-particle-kernel">Example code tagged-particle kernel</a><a id="Example-code-tagged-particle-kernel-1"></a><a class="docs-heading-anchor-permalink" href="#Example-code-tagged-particle-kernel" title="Permalink"></a></h3><pre><code class="language-julia hljs"># run the code from the single-component active MCT example for the constants and input data

kernelA  = ActiveMCTKernel(ρ, k_array, wk, w0, Sk, 3);
problemA = MemoryEquation(α, β, γ, δ, Sk, zeros(Nk), kernelA);
solA     = solve(problemA);

# α, β and δ are the same, but γ is different for a tagged particle
γT = @. k_array^2 * w0 / Sk;

kernelT  = TaggedActiveMCTKernel(ρ, k_array, wk, w0, Sk, solA, 3);
problemT = MemoryEquation(α, β, γT, δ, ones(Nk), zeros(Nk), kernelT);
solT     = solve(problemT);

n  = 11;
t  = get_t(solA);
Fc = get_F(solA,:,n);
Ft = get_F(solT,:,n);

plot(t, Ft, xaxis=(:log10, [10^-4, :auto]), dpi=500, lc=:black, lw=1.7, labels=&quot;Tagged Fₛ(k=8.4,t)&quot;, framestyle=:box)
plot!(t, Fc/Sk[n], labels=&quot;Collective F(k=8.4,t)&quot;, lw=1.7)
xlabel!(&quot;time&quot;)
ylabel!(&quot;F(k,t)&quot;)
xlims!((1e-10,1e10))
title!(&quot;Active tagged mode-coupling kernel&quot;)</code></pre><p><img src="images/activeMCT_tag_plot.png" alt="image"/></p><h2 id="Multi-component-active-MCT"><a class="docs-heading-anchor" href="#Multi-component-active-MCT">Multi-component active MCT</a><a id="Multi-component-active-MCT-1"></a><a class="docs-heading-anchor-permalink" href="#Multi-component-active-MCT" title="Permalink"></a></h2><p>Active mode-coupling theory can also be solved for mixtures of particles. The multi-component equation reads [2]</p><p class="math-container">\[\ddot{F}^{\alpha\beta}_k(t) + \frac{1}{\tau_p}\dot{F}^{\alpha\beta}_k(t) + \sum_{\gamma\delta} k^2 \omega^{\alpha\gamma}_k \left( S^{-1}_k \right)^{\gamma\delta} F^{\delta\beta}_k(t) + \sum_\gamma \int_0^t \text{d}t&#39;\ M^{\alpha\gamma}_k(t-t&#39;) \dot{F}^{\gamma\beta}_k(t&#39;) = 0,\]</p><p>where Greek letters denote particle species. The input now consists of partial structure factors ( <span>$S_k^{\alpha\beta}$</span> ) and partial velocity correlations ( <span>$\omega_k^{\alpha\beta}$</span> and <span>$\omega_\infty^{\alpha\beta}$</span> ). The multicomponent memory kernel can be written as</p><p class="math-container">\[M^{\alpha\beta}_k(t) = \frac{1}{2 (2\pi)^d} \sum_{\substack{\mu\, \nu \\ \mu&#39;\nu&#39;}}\sum_{\lambda} \int \text{d}\mathbf{q}\ F^{\mu\mu&#39;}_q(t) F^{\nu\nu&#39;}_{|\mathbf{k}-\mathbf{q}|}(t) V^{\mu\nu\alpha}_{\mathbf{k},\mathbf{q}} V^{\mu&#39;\nu&#39;\lambda}_{\mathbf{k},\mathbf{q}} (\omega^{-1}_k)^{\lambda\beta}.\]</p><p>The multicomponent vertices are defined as</p><p class="math-container">\[V^{\mu\nu\alpha}_{\mathbf{k},\mathbf{q}}= \sum_{\gamma}\frac{\omega_k^{\alpha\gamma}}{\sqrt{\rho_\gamma}} \left( \frac{\mathbf{k}\cdot\mathbf{q}}{k} \delta_{\gamma\nu} \mathcal{C}_q^{\gamma\mu} + \frac{\mathbf{k}\cdot(\mathbf{k}-\mathbf{q})}{k} \delta_{\gamma\mu} \mathcal{C}^{\gamma\nu}_{|\mathbf{k}-\mathbf{q}|} \right),\]</p><p>where <span>$x_\alpha$</span> is the fraction of particles of species <span>$\alpha$</span> and <span>$\delta_{\alpha\beta}$</span> is a Kronecker delta. The multi-component modified direct correlation function is defined as </p><p class="math-container">\[\mathcal{C}_q^{\alpha\beta} = \delta_{\alpha\beta} - \sum_{\gamma\sigma} (w_\infty^{-1})^{\alpha\gamma} w_q^{\gamma\sigma} (S_q^{-1})^{\sigma\beta}\]</p><p>The multi-component kernel is also not implemented using Bengtzelius&#39; trick. Instead, we used the package Tullio to improve the performance of the active kernel. If you want to use an active kernel in odd dimensions greater than 3, you could consider implementing this trick (see also the passive multi-component MCT kernel) for better performance.</p><h3 id="Example-code-multi-component-kernel"><a class="docs-heading-anchor" href="#Example-code-multi-component-kernel">Example code multi-component kernel</a><a id="Example-code-multi-component-kernel-1"></a><a class="docs-heading-anchor-permalink" href="#Example-code-multi-component-kernel" title="Permalink"></a></h3><pre><code class="language-julia hljs">using ModeCouplingTheory, Plots, DelimitedFiles, StaticArrays

Ns = 2         # number of species          
Nk = 100       # number of k-values
kmax = 40.0; dk = kmax/Nk; k_array = dk*(collect(1:Nk) .- 0.5);

τₚ = 0.001      # persistence time
x = [0.8, 0.2]  # number fractions
ρ_all = 1.2     # (total) number density
ρₐ = ρ_all * x  # partial densities

# the input data can be found in the \test\ folder
Sk_file = readdlm(&quot;dataVincent_Sk_Teff4.0_tau0.001.txt&quot;, &#39;;&#39;)
wk_file = readdlm(&quot;dataVincent_wk_Teff4.0_tau0.001.txt&quot;, &#39;;&#39;)
w0 = SMatrix{Ns,Ns}(readdlm(&quot;dataVincent_w0_Teff4.0_tau0.001.txt&quot;,&#39;;&#39;));

# rewrite data as a vector of Static Matrices for improved performance
Sk = [@SMatrix zeros(Ns, Ns) for i=1:Nk]
wk = [@SMatrix zeros(Ns, Ns) for i=1:Nk]

for i=1:Nk
    Sk[i] = Sk_file[i,:]
    wk[i] = wk_file[i,:]
end

# define mode-coupling parameters
α = 1.0; β = 1/τₚ;
δ = @SMatrix zeros(Ns, Ns)
γ = [@SMatrix zeros(Ns, Ns) for j in 1:length(k_array)]

for i=1:Nk
    γ[i] = k_array[i]^2 .* wk[i] * inv(Sk[i]);
end

kernel  = ActiveMultiComponentKernel(ρₐ, k_array, wk, w0, Sk, 3);
problem = MemoryEquation(α, β, γ, δ, Sk, zero(Sk), kernel);
solver  = TimeDoublingSolver(verbose=true, N=16, Δt = 10^(-6), tolerance=10^-8, max_iterations=10^8, t_max=10^5.0);
sol     = @time solve(problem, solver);

k_index = 19;
t = get_t(sol);
F_11 = get_F(sol, :, k_index, 1);
F_12 = get_F(sol, :, k_index, 2);
F_21 = get_F(sol, :, k_index, 3);
F_22 = get_F(sol, :, k_index, 4);

plot(t, F_11/Sk[k_index][1], xaxis=(:log10, [10^-5, 10^2]), dpi=500, lc=1, lw=2, labels=&quot;F{AA}(k,t)&quot;, framestyle=:box)
plot!(t, F_12/Sk[k_index][2], dpi=500, lc=:orange, lw=2, labels=&quot;F{AB}(k,t)&quot;)
plot!(t, F_21/Sk[k_index][3], dpi=500, lc=4, lw=2, ls=:dash, labels=&quot;F{BA}(k,t)&quot;)
plot!(t, F_22/Sk[k_index][4], dpi=500, lc=3, lw=2, labels=&quot;F{BB}(k,t)&quot;)
xlabel!(&quot;time&quot;)
title!(&quot;Active multicomponent mode-coupling kernel (k=7.4)&quot;)</code></pre><p><img src="images/activeMCT_mc_plot.png" alt="image"/></p><h2 id="Note-on-input-data"><a class="docs-heading-anchor" href="#Note-on-input-data">Note on input data</a><a id="Note-on-input-data-1"></a><a class="docs-heading-anchor-permalink" href="#Note-on-input-data" title="Permalink"></a></h2><p>The input data (consisting of <span>$S_k^{\alpha\beta}$</span> and <span>$\omega_k^{\alpha\beta}$</span>) is expected to be a vector of matrices, with the vector having length <span>$N_k$</span> and the matrix having size <span>$N_s$</span> x <span>$N_s$</span>.</p><p>Note that the multicomponent active MCT kernel has been implemented with the following convention for the partial structure factor and direct correlation function, <strong>which is different</strong> from the convention used for the passive kernels in this package:</p><p class="math-container">\[S_k^{\alpha\beta} = \frac{1}{\sqrt{N_\alpha N_\beta}} \sum_{i=1}^{N_\alpha} \sum_{j=1}^{N_\beta} \braket{ e^{i\mathbf{k}\cdot(\mathbf{r}_j^\beta - \mathbf{r}_i^\alpha)}}\]</p><p class="math-container">\[C_{k}^{\alpha\beta} = \delta_{\alpha\beta} - (S^{-1}_k)^{\alpha\beta}\]</p><p>The definitions used in the passive kernels are given in [3]. The structure factor can be converted to the right format by simply changing the (species-dependent) prefactor.</p><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><p>[1] G. Szamel. <em>Theory for the dynamics of dense systems of athermal self-propelled particles</em>. Phys. Rev. E <strong>93</strong>, 012603 (2016).</p><p>[2] V.E. Debets and L.M.C. Janssen. <em>Mode-coupling theory for mixtures of athermal self-propelled particles</em>. J. Chem. Phys. <strong>159</strong>, 014502 (2023).</p><p>[3] F. Weysser et al. <em>Structural relaxation of polydisperse hard spheres: Comparison of the mode-coupling theory to a Langevin dynamics simulation</em>. Phys. Rev. E <strong>82</strong>, 011504 (2010).</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="SCGLET.html">« Self-Consistent Generalized Langevin Equation Theory</a><a class="docs-footer-nextpage" href="Scope.html">Scope »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Tuesday 26 August 2025 12:59">Tuesday 26 August 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
