var documenterSearchIndex = {"docs":
[{"location":"Kernels.html#Kernels","page":"Kernels","title":"Kernels","text":"","category":"section"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"A memory kernel kernel is an instance of a type of which MemoryKernel is a supertype. It can be called like out = evaluate_kernel(kernel, F, t). Additionally, when F is a mutable container like a Vector, it can be called like evaluate_kernel!(out, kernel, F, t) in which case it will mutate the elements of the temporary array out. Below we list the memory kernels that this package defines and give some examples of how to use them.","category":"page"},{"location":"Kernels.html#Schematic-Kernels","page":"Kernels","title":"Schematic Kernels","text":"","category":"section"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"This package includes a couple of schematic memory kernels.","category":"page"},{"location":"Kernels.html#.-ExponentiallyDecayingKernel","page":"Kernels","title":"1. ExponentiallyDecayingKernel","text":"","category":"section"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"The ExponentiallyDecayingKernel implements the kernel K(t) = λ exp(-tτ). It has fields λ <: Number and τ <: Number.","category":"page"},{"location":"Kernels.html#Example","page":"Kernels","title":"Example","text":"","category":"section"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"The integro-differential equation with this memory kernel actually has an analytic solution for tau=1, alpha=0 , beta=1, and gamma=1. It is given by","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"F(t) = frace^-fract2left( lambda + sqrtlambda(lambda+4) + 2right)2 sqrtlambda  (lambda +4)left(sqrtlambda(lambda+4) left(e^sqrtlambda(lambda+4) t+1right)+lambda  left(e^sqrtlambda(lambda+4) t-1right)right)","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"F0 = 1.0; ∂F0 = 0.0; α = 0.0; β = 1.0; γ = 1.0; λ = 1.0; τ = 1.0;\n\nkernel = ExponentiallyDecayingKernel(λ, τ)\nproblem = MCTProblem(α, β, γ, F0, ∂F0, kernel)\nsolver = FuchsSolver(problem, Δt=10^-3, t_max=10.0^2, verbose=false, N = 128, tolerance=10^-10, max_iterations=10^6)\nt, F, K =  solve(problem, solver, kernel)\n\nt_analytic = 10 .^ range(-3, 2, length=50)\nF_analytic = @. (exp(-0.5*(3+sqrt(5))* t_analytic)*(exp(sqrt(5)*t_analytic) * (1+sqrt(5))-1+sqrt(5)))/(2sqrt(5))\n\nusing Plots\np = plot(log10.(t), F, label=\"Numeric solution\", lw=3)\nscatter!(log10.(t_analytic), F_analytic, label=\"Exact solution\", ylabel=\"F\", xlabel=\"log10(t)\")","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"(Image: image)","category":"page"},{"location":"Kernels.html#.-SchematicF1Kernel","page":"Kernels","title":"2. SchematicF1Kernel","text":"","category":"section"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"The SchematicF1Kernel implements the kernel K(t) = λ F(t). It has one field λ <: Number.","category":"page"},{"location":"Kernels.html#Example-2","page":"Kernels","title":"Example","text":"","category":"section"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"The integro-differential equation with this memory kernel also has an analytic solution for alpha=0 , beta=1, and gamma=1. It is given by","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"F(t) =  e^-2tleft(I_0(2t) + I_1(2t) right)","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"in which I_k are modified Bessel functions of the first kind.","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"F0 = 1.0; ∂F0 = 0.0; α = 0.0; β = 1.0; γ = 1.0; λ = 1.0\n\nkernel = SchematicF1Kernel(λ)\nproblem = MCTProblem(α, β, γ, F0, ∂F0, kernel)\nsolver = FuchsSolver(problem, Δt=10^-3, t_max=10.0^2, verbose=false, N = 100, tolerance=10^-14, max_iterations=10^6)\nt, F, K1 =  solve(problem, solver, kernel)\n\nusing Plots, SpecialFunctions\nt_analytic = 10 .^ range(-3, 2, length=50)\nF_analytic = @. exp(-2*t_analytic)*(besseli(0, 2t_analytic) + besseli(1, 2t_analytic))\nplot(log10.(t), F, label=\"Numerical Solution\", ylabel=\"F\", xlabel=\"log10(t)\", lw=3)\nscatter!(log10.(t_analytic), F_analytic, label=\"Exact Solution\")","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"(Image: image)","category":"page"},{"location":"Kernels.html#.-SchematicF2Kernel","page":"Kernels","title":"3. SchematicF2Kernel","text":"","category":"section"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"The SchematicF2Kernel implements the kernel K(t) = λ F(t)^2. It has one field λ <: Number.","category":"page"},{"location":"Kernels.html#.-SchematicF123Kernel","page":"Kernels","title":"4. SchematicF123Kernel","text":"","category":"section"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"The SchematicF123Kernel implements the kernel K(t) = λ_1 F(t) + λ_2 F(t)^2 + λ_3 F(t)^3. It has fields λ1 <: Number, λ2 <: Number, and λ3 <: Number.","category":"page"},{"location":"Kernels.html#Example-3","page":"Kernels","title":"Example","text":"","category":"section"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"kernel = SchematicF123Kernel(3.0, 2.0, 1.0);\nF = 2; t = 0;\nevaluate_kernel(kernel, F, t) # returns 22.0 = 3*2^1 + 2*2^2 + 1*2^3","category":"page"},{"location":"Kernels.html#.-SchematicDiagonalKernel","page":"Kernels","title":"5. SchematicDiagonalKernel","text":"","category":"section"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"The SchematicDiagonalKernel implements the kernel K_ij(t) = delta_ij lambda_i F_i(t)^2. It has one field λ which must be either a Vector or an SVector. When called, it returns Diagonal(λ .* F .^ 2), i.e., it implements a non-coupled system of SchematicF2Kernels.","category":"page"},{"location":"Kernels.html#.-SchematicMatrixKernel","page":"Kernels","title":"6. SchematicMatrixKernel","text":"","category":"section"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"The SchematicMatrixKernel implements the kernel K_ij(t) = sum_k lambda_ij F_k(t) F_j(t). It has one field λ which must be either a Matrix or an SMatrix. ","category":"page"},{"location":"Kernels.html#Mode-Coupling-Theory","page":"Kernels","title":"Mode-Coupling Theory","text":"","category":"section"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"The mode-coupling theory equation reads","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"ddotF(kt) + Omega(k)F(kt) + int_0^tdtau K(t-tau k)dotF(ktau)=0","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"in which Omega(k) = k^2 k_B TmS(k), and","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"K(kt) =fracrho k_BT16pi^3 m int dmathbfq V(mathbfk mathbfq)^2F(q t)F(mathbfk-mathbfqt)","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"in which the vertex V(textbfk textbfq) = (textbfkcdottextbfq)c(q)k+(textbfkcdot(textbfk-textbfq)c(textbfk-textbfq)k. For more details and the meaning of the symbols, see [1, 2].","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"This memory kernel integral is discretised as follows:","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"int dtextbfqf(q textbfk-textbfq) = 2piint_0^infty dq q^2 int_0^pi dtheta sin theta f(q textbfk-textbfq) = frac2pikint_0^infty dq int_k-q^k+qdp pq f(q p) approx frac2pi Delta k^2k_isum_j=1^N_k sum_l=j-i+1^j+i-1 fracp_l q_jk_if(q_j p_l)","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"in which p = textbfk-textbfq, and wave numbers k, q and p are discretized on the equidistant grid k_i = (i_k-frac12)Delta k where i_k = 1 2 3 ldots N_k. The double sum is then performed for all k using Bengtzelius' trick, yielding a fast O(N_k^2) algorithm.","category":"page"},{"location":"Kernels.html#Example-4","page":"Kernels","title":"Example","text":"","category":"section"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"\"\"\"\n    find_analytical_C_k(k, η)\nFinds the direct correlation function given by the \nanalytical Percus-Yevick solution of the Ornstein-Zernike \nequation for hard spheres for a given volume fraction η.\n\nReference: Wertheim, M. S. \"Exact solution of the Percus-Yevick integral equation \nfor hard spheres.\" Physical Review Letters 10.8 (1963): 321.\n\"\"\" \nfunction find_analytical_C_k(k, η)\n    A = -(1 - η)^-4 *(1 + 2η)^2\n    B = (1 - η)^-4*  6η*(1 + η/2)^2\n    D = -(1 - η)^-4 * 1/2 * η*(1 + 2η)^2\n    Cₖ = @. 4π/k^6 * \n    (\n        24*D - 2*B * k^2 - (24*D - 2 * (B + 6*D) * k^2 + (A + B + D) * k^4) * cos(k)\n     + k * (-24*D + (A + 2*B + 4*D) * k^2) * sin(k)\n     )\n    return Cₖ\nend\n\n\"\"\"\n    find_analytical_S_k(k, η)\nFinds the static structure factor given by the \nanalytical Percus-Yevick solution of the Ornstein-Zernike \nequation for hard spheres for a given volume fraction η.\n\"\"\" \nfunction find_analytical_S_k(k, η)\n        Cₖ = find_analytical_C_k(k, η)\n        ρ = 6/π * η\n        Sₖ = @. 1 + ρ*Cₖ / (1 - ρ*Cₖ)\n    return Sₖ\nend\n\n# We solve MCT for hard spheres at a volume fraction of 0.51591\nη = 0.51591; ρ = η*6/π; kBT = 1.0; m = 1.0\n\nNk = 100; kmax = 40.0; dk = kmax/Nk; k_array = dk*(collect(1:Nk) .- 0.5)\nSₖ = find_analytical_S_k(k_array, η)\n\n∂F0 = zeros(Nk); α = 1.0; β = 0.0; γ = @. k_array^2*kBT/(m*Sₖ)\n\nkernel = ModeCouplingKernel(ρ, kBT, m, k_array, Sₖ)\nproblem = MCTProblem(α, β, γ, Sₖ, ∂F0, kernel)\nsolver = FuchsSolver(problem, Δt=10^-5, t_max=10.0^15, verbose=false, \n                     N = 8, tolerance=10^-8)\nt, F, K = @time solve(problem, solver, kernel);\n    # 3.190870 seconds (377.93 k allocations: 106.456 MiB, 0.42% gc time)\np = plot(xlabel=\"log10(t)\", ylabel=\"F(k,t)\", ylims=(0,1))\nfor ik = [7, 18, 25, 39]\n    plot!(p, log10.(t), F[ik, :]/Sₖ[ik], label=\"k = $(k_array[ik])\", lw=3)\nend\np","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"(Image: image)","category":"page"},{"location":"Kernels.html#References","page":"Kernels","title":"References","text":"","category":"section"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"[1] Reichman, David R., and Patrick Charbonneau. \"Mode-coupling theory.\" Journal of Statistical Mechanics: Theory and Experiment 2005.05 (2005): P05013.","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"[2] Janssen, Liesbeth MC. \"Mode-coupling theory of the glass transition: A primer.\" Frontiers in Physics 6 (2018): 97.","category":"page"},{"location":"Kernels.html#Multi-component-Mode-Coupling-Theory","page":"Kernels","title":"Multi-component Mode-Coupling Theory","text":"","category":"section"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"The multi-component mode-coupling theory equation reads","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"ddotF_alphabeta(kt) + Omega_alphagamma(k)F_gammabeta(kt) + int_0^tdtau K_alphagamma(t-tau k)dotF_gammabeta(k tau)=0","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"in which Omega_alphagamma = k^2 k_B T x_alpham_alpha cdot left(S^-1right)_alphagamma(k), and","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"K_alphabeta(kt) =frack_B T rho2 x_beta m_alpha (2pi)^3 int dmathbfq V_munualpha(mathbfk mathbfq)F_mumu(q t)F_nunu(mathbfk-mathbfqt)V_munubeta(mathbfk mathbfq)","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"in which the vertex V_munualpha(mathbfk mathbfq) = (textbfkcdottextbfq)c_alphamu(q)delta_alphanuk+(textbfkcdot(textbfk-textbfq)c_alphanu(textbfk-textbfq)delta_alphamuk. Here, the Greek indices indicate species labels, and we have adopted the convention that we sum over repeated indices. This memory kernel has also been implemented using the Bengtzelius' trick. It requires O(N_k^2 N_s^2) storage and runs in O(N_k^2 N_s^4) in which N_s is the number of species.","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"Numerically, the correlator F_alphabeta(k) is implemented as a Vector of length Nk of which each of the elements is a small Ns x Ns static matrix. This means that this is also the expected form of the initial condition.","category":"page"},{"location":"Kernels.html#Example-5","page":"Kernels","title":"Example","text":"","category":"section"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"using StaticArrays, LinearAlgebra, DelimitedFiles\n# number of species Ns, number of wave numbers Nk, volume fraction η\n# thermal energy kBT and mass m\nNs = 2; Nk = 100; η  = 0.515; kBT = 1.0; m = ones(Ns)\nparticle_diameters = [0.8,1.0]\nx = [0.2,0.8] # concentration fraction\n\n# total density\nρ_all = 6η/(π*sum(x .* particle_diameters .^3))\nρ = ρ_all * x\n\nkmax = 40.0; dk = kmax/Nk\nk_array = dk*(collect(1:Nk) .- 0.5)\n\n# data can be found in the \\test\\ folder of the source code\nSₖdata = reshape(readdlm(\"Sk_MC.txt\"), (2,2,100))\n# convert the data to the Vector of SMatrix format\nSₖ = [@SMatrix(zeros(Ns, Ns)) for i = 1:Nk]\nfor i = 1:Nk\n    Sₖ[i] = Sₖdata[:, :, i]\nend\nS⁻¹ = inv.(Sₖ)\n\nJ = similar(Sₖ) .* 0.0\nfor ik = 1:Nk\n    J[ik] = kBT*k_array[ik]^2 * x ./ m .* I(Ns)\nend\n\nF₀ = copy(Sₖ)\n∂ₜF₀ = [@SMatrix(zeros(Ns, Ns)) for i = 1:Nk]\nα = 0.0\nβ = 1.0\nΩ = similar(Sₖ)\nΩ .*= 0.0\nfor ik = 1:Nk\n    Ω .= J.*S⁻¹\nend\n\nkernel = MultiComponentModeCouplingKernel(ρ, kBT, m, k_array, Sₖ)\nproblem = MCTProblem(α, β, Ω, F₀, ∂ₜF₀, kernel)\nsolver = FuchsSolver(problem, verbose=false, N=16, tolerance=10^-8, max_iterations=10^8)\nt, F, K = solve(problem, solver, kernel)\nik = 19\nk = k_array[ik]\np = plot(log10.(t), getindex.(F[ik,:], 1,1)/Sₖ[ik][1,1], ls=:dash, lw=2, color=1, label=\"Faa(k=$k, t)\") \nplot!(log10.(t), getindex.(F[ik,:], 1,2)/Sₖ[ik][1,2], lw=2, color=2, label=\"Fab(k=$k, t)\") \nplot!(log10.(t), getindex.(F[ik,:], 2,1)/Sₖ[ik][2,1], ls=:dash, lw=2, color=3, label=\"Fba(k=$k, t)\") \nplot!(log10.(t), getindex.(F[ik,:], 2,2)/Sₖ[ik][2,2], ls=:dash, lw=2, color=4, label=\"Fbb(k=$k, t)\")","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"(Image: image)","category":"page"},{"location":"Kernels.html#Defining-custom-kernels","page":"Kernels","title":"Defining custom kernels","text":"","category":"section"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"In order to define a custom kernel, one has to overload ModeCouplingTheory.evaluate_kernel(k::MyCustomKernel, F, t), and optionally  ModeCouplingTheory.evaluate_kernel!(out, k::MyCustomKernel, F, t) for better performance for mutable F.","category":"page"},{"location":"Kernels.html#Example-1","page":"Kernels","title":"Example 1","text":"","category":"section"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"Let's define a custom scalar kernel that evaluates K(t) = alpha F(t)^F(t). First, we define a MyWeirdKernel<:MemoryKernel type that holds the value of the parameter:","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"using ModeCouplingTheory\nimport ModeCouplingTheory.MemoryKernel\n\nstruct MyWeirdKernel <: MemoryKernel\n    α :: Float64\nend\n\nkernel = MyWeirdKernel(2.5)","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"Now, we can define the evaluation of this memory kernel","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"import ModeCouplingTheory.evaluate_kernel\n\nfunction evaluate_kernel(kernel::MyWeirdKernel, F, t)\n    return kernel.α*F^F\nend","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"That's it! We can now use it like any other memory kernel to solve the equation:","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"problem = MCTProblem(1.0, 0.0, 1.0, 1.0, 0.0, kernel)\nsolver = FuchsSolver(problem, Δt = 10^-4, t_max=10.0^5)\nt, F, K = solve(problem, solver, kernel)\nusing Plots\np = plot(log10.(t), F, ylims=(0,1), ylabel=\"F(t)\", xlabel=\"log10(t)\")","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"(Image: image)","category":"page"},{"location":"Kernels.html#Example-2","page":"Kernels","title":"Example 2","text":"","category":"section"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"For a slightly more complex example, let's define the tagged-particle mode-coupling theory memory kernel. The equation is given by:","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"ddotF_s(kt) + frack^2 k_BTm F_s(kt) + int_0^t dtau K(k t-tau)dotF_s(k tau)=0","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"in which","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"K(kt) = fracrho k_BT8pi^2 mint dmathbfq V(mathbfk mathbfq)^2 F(q t)F_s(mathbfk-mathbfqt)","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"where","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"V(textbfk textbfq) = (textbfkcdottextbfq)c(q)k = frack^2+q^2-p^22k cdot c(q)","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"Note that in the equation for the memory kernel, the solution of collective mode-coupling theory F(kt) appears (without subscript s). The most straightforward way of solving the tagged-particle equation therefore is to solve the full collective equation first, and use the result in the memory kernel of the tagged-particle motion. So, first we quickly solve MCT:","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"using ModeCouplingTheory, LinearAlgebra\nη = 0.51591; ρ = η*6/π; kBT = 1.0; m = 1.0\n\nNk = 100; kmax = 40.0; dk = kmax/Nk; k_array = dk*(collect(1:Nk) .- 0.5)\n# We use the Percus-Yevick solution to the structure factor that can be found above.\nSₖ = find_analytical_S_k(k_array, η)\n\n∂F0 = zeros(Nk); α = 1.0; β = 0.0; γ = @. k_array^2*kBT/(m*Sₖ)\n\nkernel = ModeCouplingKernel(ρ, kBT, m, k_array, Sₖ)\nproblem = MCTProblem(α, β, γ, Sₖ, ∂F0, kernel)\nsolver = FuchsSolver(problem, Δt=10^-5, t_max=10.0^15, verbose=false, \n                     N = 8, tolerance=10^-8)\nt, F, K = @time solve(problem, solver, kernel);","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"Now, we need to construct the tagged-particle memory kernel for the self intermediate scattering function Fs. When called with evaluate_kernel(kernel, Fs, t) it needs some way to access the collective F at the right time. To make that easy, we create a dictionary that maps the values in t to their respective indices.","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"tDict = Dict(zip(t, eachindex(t)))\n# tdict[t[8]] == 8","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"Now we can construct a memory kernel like above. For performance reasons, we also implement the in-place evaluate_kernel!(out, kernel, Fs, t). The discrete equation that we must implement is given by ","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"K(k_it) = fracrho k_B T Delta k^24 pi^2 m sum_j=1^N_k sum_l=j-i+1^j+i-1 fracp_l q_jk_i V^2(k_i q_j p_l)F(k_j t)F_s(k_l t)","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"This memory kernel can now be straightforwardly implemented as follows:","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"import ModeCouplingTheory.MemoryKernel\nstruct TaggedMCTKernel <: MemoryKernel\n    V²::Array{Float64, 3}\n    k_array::Vector{Float64}\n    prefactor::Float64\n    F::Matrix{Float64}\n    tDict::Dict{Float64, Int64}\nend\n\n# The constructor for the TaggedMCTKernel\nfunction TaggedMCTKernel(ρ, kBT, m, k_array, Cₖ, t, F)\n    tDict = Dict(zip(t, eachindex(t)))\n    Δk = k_array[2] - k_array[1]\n    prefactor = ρ*kBT*Δk^2/(4*π^2*m)\n    Nk = length(k_array)\n    # calculate the vertices\n    V² = zeros(Nk, Nk, Nk)\n    for i = 1:Nk, j = 1:Nk, l = 1:Nk # loop over k, q, p\n        k = k_array[i]\n        q = k_array[j]\n        cq = Cₖ[j]\n        p = k_array[l]\n        if abs(j-i)+1 <= l <= j+i-1\n            V²[l, j, i] = (cq * (k^2  + q^2 - p^2)/(2k))^2\n        end\n    end\n    return TaggedMCTKernel(V², k_array, prefactor, F, tDict)\nend\n","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"Now to evaluate the kernel, we first write the in-place version of the code, that mutates its first argument. Note also that, since the mermory kernel is multiplied with a vector F to produce something of the same type of F, it has to be encoded as a diagonal matrix, with on the diagonal the dicretised wave-number dependent memory kernel.","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"import ModeCouplingTheory.evaluate_kernel!\nfunction evaluate_kernel!(out::Diagonal, kernel::TaggedMCTKernel, Fs, t)\n    out.diag .= zero(eltype(out.diag)) # set the output array to zero\n    it = kernel.tDict[t] # find the correct index corresponding to t\n    k_array = kernel.k_array\n    Nk = length(k_array)\n    for i = 1:Nk, j = 1:Nk, l = 1:Nk # loop over k, q, p\n        k = k_array[i]\n        q = k_array[j]\n        p = k_array[l]\n        out.diag[i] += p*q/k * kernel.V²[l, j, i] * kernel.F[j, it] * Fs[l]\n    end\n    out.diag .*= kernel.prefactor\nend\n\nimport ModeCouplingTheory.evaluate_kernel\nfunction evaluate_kernel(kernel::TaggedMCTKernel, Fs, t)\n    out = Diagonal(similar(Fs)) # we need it to produce a diagonal matrix\n    evaluate_kernel!(out, kernel::TaggedMCTKernel, Fs, t) # call the inplace version\n    return out\nend","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"Now we can finally solve the tagged equation:","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"Cₖ = find_analytical_C_k(k_array, η)\nF0 = ones(Nk); ∂F0 = zeros(Nk); α = 1.0; β = 0.0; γ = @. k_array^2*kBT/m\n\ntaggedkernel = TaggedMCTKernel(ρ, kBT, m, k_array, Cₖ, t, F)\ntaggedproblem = MCTProblem(α, β, γ, F0, ∂F0, taggedkernel)\ntaggedsolver = FuchsSolver(taggedproblem, Δt=10^-5, t_max=10.0^15, \n                           N = 8, tolerance=10^-8) # it is important we use the same settings for Δt, t_max and N\nts, Fs, Ks = @time solve(taggedproblem, taggedsolver, taggedkernel)\nusing Plots\np = plot(xlabel=\"log10(t)\", ylabel=\"Fₛ(k,t)\", ylims=(0,1))\nfor ik = [7, 18, 25, 39]\n    plot!(p, log10.(t), Fs[ik, :], label=\"k = $(k_array[ik])\", lw=3)\nend\np","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"(Image: image)","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"This implementation of the tagged-particle memory kernel is an order of magnitude slower than the built-in collective one, and can be made much more performant by Bengtzelius' trick. For the purposes of this example, however, we do not pursue this any further. For help with implementing your own kernel, please file an issue.","category":"page"},{"location":"Kernels.html#Bengtzelius'-Trick","page":"Kernels","title":"Bengtzelius' Trick","text":"","category":"section"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"Bengtzelius' trick is a fast way to evaluate the integral I(k) = int d mathbfq A(q mathbfk-mathbfq). Very briefly: after discretisation of the integral, one is left with terms such as T_iA=sum_j=1^N_ksum_l=j-i+1^i+j-1  A(p_lq_j) which are largely independent of i_k. Because of this, one can calculate T_iA from T_i-1A in order N_k operations. The recurrence relation that allows one to do so is given by ","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"T_iA = T_i-1A + sum_j=1^N_k-i+1(A(j j+i-1)+A(j+i-1 j)) - sum_j=1^i-1A(ji-j)","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"with initial condition","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"T_1A = sum_j=1^N_kA(j j)","category":"page"},{"location":"Scope.html#Automatic-differentiation","page":"Scope","title":"Automatic differentiation","text":"","category":"section"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"This package is compatible with forward-mode automatic differentiation. This makes it possible to calculate quatities such as fracdF(t)dgamma for example.","category":"page"},{"location":"Scope.html#Example","page":"Scope","title":"Example","text":"","category":"section"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"Let's take the derivative of the solution to the generalized Langevin equation with the exponentially decaying kernel with respect to the coupling parameter. First we need to write a function that solves this equation and outputs the solution for a given coupling parameter. Since we know the analytical solution, we can compare with the derivative of that.","category":"page"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"using ModeCouplingTheory, Plots\nfunction my_func(λ)\n    F0 = 1.0\n    ∂F0 = 0.0\n    α = 0.0\n    β = 1.0\n    γ = 1.0\n\n    kernel1 = ExponentiallyDecayingKernel(λ, 1.0)\n    system1 = MCTProblem(α, β, γ, F0, ∂F0, kernel1)\n    solver1 = FuchsSolver(system1, Δt=10^-4, t_max=5*10.0^1, verbose=false, N = 128, tolerance=10^-10, max_iterations=10^6)\n\n    t1, F1, K1 =  solve(system1, solver1, kernel1)\n    return [t1[2:end], F1[2:end], K1[2:end]]\nend\n\nfunction exact_func(λ, t)\n    temp = sqrt(λ*(λ+4)) \n    F = @. exp(-0.5* t*(temp+λ+2)) * (temp*(exp(temp*t)+1)+ λ* (exp(temp*t)-1)) / (2temp) \n    return [t, F]\nend\n\nt, F, K = my_func(5.0)\ntexact, Fexact = exact_func(5.0, t)\n\np = plot(log10.(texact), Fexact, label=\"Exact\", lw=4) \nscatter!(log10.(t[1:100:end]), F[1:100:end], label=\"Numerical solution\", ls=:dash, lw=4) ","category":"page"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"(Image: image)","category":"page"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"Now we can take the derivative with respect to the argument of the functions we defined:","category":"page"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"using ForwardDiff\n_, dF_exact = ForwardDiff.derivative(y -> exact_func(y, t), 5.0)\n_, dF, _ = ForwardDiff.derivative(my_func, 5.0)\n\np = plot(log10.(texact), dF_exact, lw=3, label=\"Exact\", ylabel=\"dF/dλ(λ=5,t)\", xlabel=\"log10(t)\") \nplot!(log10.(t), dF, ls=:dash, lw=3, label=\"Numerical solution\", legend=:topleft)","category":"page"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"(Image: image)","category":"page"},{"location":"Scope.html#Measurement-errors-and-other-number-types","page":"Scope","title":"Measurement errors and other number types","text":"","category":"section"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"Similar to automatically evaluating derivatives, it is also possible to automatically propagate measurement errors through the entire solution process. This does however cause a serious performace loss. It works by instead of doing arithmatic with standard floating point numbers, it uses numbers with an error attached. The  Measurements.jl package implements how arithmatic with such numbers should be performed. Analagously, one can use arbitrary precision arithmatic (when many decimal places of precision are required) or complex valued numbers together with this package.","category":"page"},{"location":"Scope.html#Example-2","page":"Scope","title":"Example","text":"","category":"section"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"Let's solve standard mode-coupling theory with a structure factor that contains measurement errors. To generate such a structure factor, we can use the analytical Percus-Yevick expression, but pretend there is an uncertainty in the volume fraction eta.","category":"page"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"\njulia> using ModeCouplingTheory, Plots, Measurements\n\njulia> η = 0.51 ± 0.01\n0.51 ± 0.05\n\njulia> ρ = η*6/π\n0.974 ± 0.019\n\njulia> kBT = 1.0; m = 1.0;\n\njulia> Nk = 100; kmax = 40.0; dk = kmax/Nk; k_array = dk*(collect(1:Nk) .- 0.5);","category":"page"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"We use the same functions to find the structure factor as before:","category":"page"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"\"\"\"\nFinds the fourier transform of the direct correlation function given by the \nanalytical percus yevick solution of the Ornstein Zernike \nequation for hard spheres for a given volume fraction η on the coordinates r\nin units of one over the diameter of the particles\n\"\"\" \nfunction find_analytical_C_k(k, η)\n    A = -(1 - η)^-4 *(1 + 2η)^2\n    B = (1 - η)^-4*  6η*(1 + η/2)^2\n    D = -(1 - η)^-4 * 1/2 * η*(1 + 2η)^2\n    Cₖ = @. 4π/k^6 * \n    (\n        24*D - 2*B * k^2 - (24*D - 2 * (B + 6*D) * k^2 + (A + B + D) * k^4) * cos(k)\n     + k * (-24*D + (A + 2*B + 4*D) * k^2) * sin(k)\n     )\n    return Cₖ\nend\n\n\"\"\"\nFinds the static structure factor given by the \nanalytical percus yevick solution of the Ornstein Zernike \nequation for hard spheres for a given volume fraction η on the coordinates r\nin units of one over the diameter of the particles\n\"\"\" \nfunction find_analytical_S_k(k, η)\n        Cₖ = find_analytical_C_k(k, η)\n        ρ = 6/π * η\n        Sₖ = @. 1 + ρ*Cₖ / (1 - ρ*Cₖ)\n    return Sₖ\nend\n\njulia> Sₖ_uncertain = find_analytical_S_k(k_array, ρ*π/6)\n100-element Vector{Measurement{Float64}}:\n  0.0142 ± 0.0014\n  0.0145 ± 0.0015\n  0.0152 ± 0.0015\n  0.0163 ± 0.0017\n         ⋮\n  1.0154 ± 0.0012\n  0.9987 ± 0.00012\n 0.98327 ± 0.00089\n\njulia> plot(k_array, Sₖ_uncertain, xlabel=\"k\", ylabel=\"S(k)\", legend=false)","category":"page"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"(Image: image)","category":"page"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"Now we can use this structure factor to solve the mode-coupling equation as usual.","category":"page"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"# The initial condition of the derivative must have the same type as the initial condition itself\n∂F0 = zeros(eltype(Sₖ_uncertain), Nk)\nα = 1.0; β = 0.0; γ = @. k_array^2*kBT/(m*Sₖ_uncertain)\nkernel = ModeCouplingKernel(ρ, kBT, m, k_array, Sₖ_uncertain)\nproblem = MCTProblem(α, β, γ, Sₖ_uncertain, ∂F0, kernel)\nsolver = FuchsSolver(problem, Δt=10^-5, t_max=10.0^5, verbose=true, N = 8, tolerance=10^-8, max_iterations=10^8)\nt, F, K = @time solve(problem, solver, kernel);\np = plot(xlabel=\"log10(t)\", ylabel=\"F(k,t)\", ylims=(0,1), xlims=(-5,5))\nplot!(p, log10.(t[2:10:end]), F[19, 2:10:end]/Sₖ_uncertain[19], label=\"k = $(k_array[19])\", lw=3)","category":"page"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"(Image: image)","category":"page"},{"location":"Scope.html#Steady-state-(non-ergodicity-parameter)","page":"Scope","title":"Steady state (non-ergodicity parameter)","text":"","category":"section"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"This package also exports a function solve_steady_state(γ, F₀, kernel; tolerance=10^-8, max_iterations=10^6, verbose=false) to find the steady-state solution of a mode-coupling like equation. In order to find it, it performs a recursive iteration of the mapping ","category":"page"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"F^infty = (K(F^inftyt=infty) + γ)^-1 cdot K(F^infty t=infty) cdot F(t=0)","category":"page"},{"location":"Scope.html#Example-3","page":"Scope","title":"Example","text":"","category":"section"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"using ModeCouplingTheory, Plots\nη = 0.51595; ρ = η*6/π; kBT = 1.0; m = 1.0\nNk = 100; kmax = 40.0; dk = kmax/Nk; k_array = dk*(collect(1:Nk) .- 0.5);\nSₖ = find_analytical_S_k(k_array, ρ*π/6)\n\nγ = @. k_array^2*kBT/(m*Sₖ)\nkernel = ModeCouplingKernel(ρ, kBT, m, k_array, Sₖ)\nfk = solve_steady_state(γ, Sₖ, kernel; tolerance=10^-8, verbose=false)\np = plot(k_array, fk, ylabel=\"non-ergodicity parameter\", xlabel=\"k\")","category":"page"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"(Image: image)","category":"page"},{"location":"Scope.html#Relaxation-time","page":"Scope","title":"Relaxation time","text":"","category":"section"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"Relaxation times can be easily extracted from dynamical data using the find_relaxation_time(t, F; threshold=exp(-1), mode=:log) function.","category":"page"},{"location":"Scope.html#Example-4","page":"Scope","title":"Example","text":"","category":"section"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"Let's solve mode-coupling theory to get some data:","category":"page"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"# We solve MCT for hard spheres at a volume fraction of 0.51591\nη = 0.51591; ρ = η*6/π; kBT = 1.0; m = 1.0\n\nNk = 100; kmax = 40.0; dk = kmax/Nk; k_array = dk*(collect(1:Nk) .- 0.5)\nSₖ = find_analytical_S_k(k_array, η)\n\n∂F0 = zeros(Nk); α = 1.0; β = 0.0; γ = @. k_array^2*kBT/(m*Sₖ)\n\nkernel = ModeCouplingKernel(ρ, kBT, m, k_array, Sₖ)\nproblem = MCTProblem(α, β, γ, Sₖ, ∂F0, kernel)\nsolver = FuchsSolver(problem, Δt=10^-5, t_max=10.0^15, verbose=false, \n                     N = 8, tolerance=10^-8)\nt, F, K = @time solve(problem, solver, kernel);","category":"page"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"We can now extract a single relaxation time by calling ","category":"page"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"julia> find_relaxation_time(t, F[18, :]) # at k k_array[18]\n4.232796654132995e11","category":"page"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"To extract all relaxation times as a function of k:","category":"page"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"julia> t_R = [find_relaxation_time(t, F[ik, :]) for ik in eachindex(k_array)]; \njulia> p = plot(k_array, log10.(t_R), xlabel=\"k\", ylabel=\"log10(relaxation time)\", legend=false)","category":"page"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"(Image: image)","category":"page"},{"location":"Problems_and_Solvers.html#Problems","page":"Problems and Solvers","title":"Problems","text":"","category":"section"},{"location":"Problems_and_Solvers.html","page":"Problems and Solvers","title":"Problems and Solvers","text":"The most straightforward workflow for solving MCT-like equations is to first construct a MemoryKernel, a MCTProblem, and a Solver, in that order. The MemoryKernel is a function or callable object that evaluates the memory kernel when called. The MCTProblem holds the coefficients and initial conditions of the equations that need to be solved, and the Solver stores information related to the numerical integration procedure, such as the time step. Once these three objects have been defined, the function solve can be called on them to solve the equation","category":"page"},{"location":"Problems_and_Solvers.html","page":"Problems and Solvers","title":"Problems and Solvers","text":"alpha ddotF(t) + beta dotF(t) + gamma F(t) + int_0^t dtau K(t-tau)dotF(tau) = 0","category":"page"},{"location":"Problems_and_Solvers.html","page":"Problems and Solvers","title":"Problems and Solvers","text":"An MCTProblem is constructed by the constructor MCTProblem(α, β, γ, F₀, ∂ₜF₀, kernel::MemoryKernel). Here, F₀ and ∂ₜF₀ are the initial conditions of F and its time derivative. In the case of vector-valued functions F, this package requires that the operation α*F is defined and returns the same type as F. This means that in general, when F is a vector, α must either be a matrix with a compatible element type, or a scalar. However, because it is common in practice to find equations in which α and F are both vectors (such that the multiplication α*F is understood to be conducted element-wise), vector-valued αs will automatically be promoted to diagonal matrices. β and γ are treated in the same way. MCTProblem will also evaluate the kernel at t=0 to find its initial condition.","category":"page"},{"location":"Problems_and_Solvers.html#Examples","page":"Problems and Solvers","title":"Examples","text":"","category":"section"},{"location":"Problems_and_Solvers.html","page":"Problems and Solvers","title":"Problems and Solvers","text":"Scalar problems are the most straightforward:","category":"page"},{"location":"Problems_and_Solvers.html","page":"Problems and Solvers","title":"Problems and Solvers","text":"kernel = SchematicF1Kernel(0.2); # in the next page of the documentation we will \n                                 # explain how to construct memory kernels\nα = 1.0; β = 0.0; γ = 1.0; F0 = 1.0; ∂F0 = 0.0;\nproblem = MCTProblem(α, β, γ, F0, ∂F0, kernel)","category":"page"},{"location":"Problems_and_Solvers.html","page":"Problems and Solvers","title":"Problems and Solvers","text":"For vector-valued problems, the coefficients can be scalar, vector or matrix-valued. They are automatically promoted to make linear algebra work:","category":"page"},{"location":"Problems_and_Solvers.html","page":"Problems and Solvers","title":"Problems and Solvers","text":"julia> N = 5;\njulia> kernel = SchematicDiagonalKernel(rand(N));\njulia> α = 1.0; β = rand(N); γ = rand(N,N); F0 = ones(N); ∂F0 = zeros(N);\njulia> problem = MCTProblem(α, β, γ, F0, ∂F0, kernel);\n\njulia> problem.α\nLinearAlgebra.UniformScaling{Float64}\n1.0*I\n\njulia> problem.β\n5×5 LinearAlgebra.Diagonal{Float64, Vector{Float64}}:\n 0.789182   ⋅         ⋅        ⋅         ⋅\n  ⋅        0.379832   ⋅        ⋅         ⋅\n  ⋅         ⋅        0.50589   ⋅         ⋅\n  ⋅         ⋅         ⋅       0.241663   ⋅\n  ⋅         ⋅         ⋅        ⋅        0.857202\n\njulia> problem.γ\n5×5 Matrix{Float64}:\n 0.746936  0.963531  0.724356  0.31979   0.600617\n 0.731198  0.217209  0.603705  0.373079  0.930195\n 0.464137  0.670576  0.973505  0.23666   0.536108\n 0.40188   0.797017  0.332496  0.841541  0.434256\n 0.401826  0.303485  0.238624  0.239107  0.453554","category":"page"},{"location":"Problems_and_Solvers.html#Limitations","page":"Problems and Solvers","title":"Limitations","text":"","category":"section"},{"location":"Problems_and_Solvers.html","page":"Problems and Solvers","title":"Problems and Solvers","text":"This package is not tested for and is not expected to work when the type of F is something other than a Number, Vector or SVector. For example, using types like OffsetArrays as initial conditions might lead to unexpected behaviour.","category":"page"},{"location":"Problems_and_Solvers.html#Solvers","page":"Problems and Solvers","title":"Solvers","text":"","category":"section"},{"location":"Problems_and_Solvers.html","page":"Problems and Solvers","title":"Problems and Solvers","text":"A Solver object holds the settings for a specific integration method. This package defines two solvers: EulerSolver and FuchsSolver. The EulerSolver implements a simple forward Euler method (with trapezoidal integration) which is wildly inefficient if the domain of t spans many orders of magnitude (such as it often does in Mode-Coupling Theory). It should therefore mainly be used for testing purposes. The FuchsSolver should be used in almost all other cases. The scheme it implements is outlined in [1] and in the appendix of [2].","category":"page"},{"location":"Problems_and_Solvers.html","page":"Problems and Solvers","title":"Problems and Solvers","text":"In short, the equation is discretised and solved on a grid of 4N time-points, which are equally spaced over an interval Δt. It is solved using an implicit method, and thus a fixed point has to be found for each time point. This is done by recursive iteration. When the solution is found, the interval is doubled Δt => 2Δt and the solution on the previous grid is mapped onto the first 2N time points of the new grid. The solution on the other2N points is again found by recursive iteration. This is repeated until some final time t_max is reached.","category":"page"},{"location":"Problems_and_Solvers.html","page":"Problems and Solvers","title":"Problems and Solvers","text":"A FuchsSolver is constructed as follows:","category":"page"},{"location":"Problems_and_Solvers.html","page":"Problems and Solvers","title":"Problems and Solvers","text":"julia> kernel = SchematicF1Kernel(0.2);\njulia> α = 1.0; β = 0.0; γ = 1.0; F0 = 1.0; ∂F0 = 0.0;\njulia> problem = MCTProblem(α, β, γ, F0, ∂F0, kernel);\njulia> solver1 = FuchsSolver(problem) # using all default parameters\njulia> solver2 = FuchsSolver(problem; N=128, Δt=10^-5, \n                            t_max=10.0^15, max_iterations=10^8, \n                            tolerance=10^-6, verbose=true)","category":"page"},{"location":"Problems_and_Solvers.html","page":"Problems and Solvers","title":"Problems and Solvers","text":"As optional keyword arguments FuchsSolver accepts:","category":"page"},{"location":"Problems_and_Solvers.html","page":"Problems and Solvers","title":"Problems and Solvers","text":"N: The number of time points in the interval is equal to 4N. default = 32\nt_max: when this time value is reached, the integration returns. default = 10.0^10\nΔt: starting time interval, this will be doubled repeatedly. default = 10^-10\nmax_iterations: the maximal number of iterations before convergence is reached for each time doubling step. default = 10^4\ntolerance: while the error of the recursive iteration is bigger than this value, convergence is not reached. The error by default is computed as the absolute sum of squared differences. default = 10^-10\nverbose: if true, some information will be printed. default = false\ninplace: if true and if the type of F is mutable, the solver will try to avoid allocating many temporaries. default = true","category":"page"},{"location":"Problems_and_Solvers.html","page":"Problems and Solvers","title":"Problems and Solvers","text":"Having defined a MemoryKernel, MCTProblem and a Solver, one can call t, F, K = solve(problem, solver, kernel) to solve the problem. It outputs a Vector of time points t and the solution F and memory kernel K evaluated at those times points. ","category":"page"},{"location":"Problems_and_Solvers.html#References","page":"Problems and Solvers","title":"References","text":"","category":"section"},{"location":"Problems_and_Solvers.html","page":"Problems and Solvers","title":"Problems and Solvers","text":"[1] Fuchs, Matthias, et al. \"Comments on the alpha-peak shapes for relaxation in supercooled liquids.\" Journal of Physics: Condensed Matter 3.26 (1991): 5047.","category":"page"},{"location":"Problems_and_Solvers.html","page":"Problems and Solvers","title":"Problems and Solvers","text":"[2] Flenner, Elijah, and Grzegorz Szamel. \"Relaxation in a glassy binary mixture: Comparison of the mode-coupling theory to a Brownian dynamics simulation.\" Physical Review E 72.3 (2005): 031508.","category":"page"},{"location":"FromPython.html#Calling-from-Python","page":"From Python","title":"Calling from Python","text":"","category":"section"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"Using ModeCouplingTheory from Python can be useful for solving mode-coupling theory repeatedly or for large systems of equations, making the overhead of initializing Julia negligible. (Or perhaps if one prefers to work in Python.)","category":"page"},{"location":"FromPython.html#Installing","page":"From Python","title":"Installing","text":"","category":"section"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"First, install julia through the pip package manager, with","category":"page"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"% pip install julia","category":"page"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"Using ipython3 (only Python geq 3 is supported), do:","category":"page"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"from julia import Main","category":"page"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"which will install the latest stable version of Julia the first time it is called. Now install ModeCouplingTheory.jl, with","category":"page"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"from julia import Pkg\nPkg.add(\"ModeCouplingTheory.jl\")","category":"page"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"To import this package in order to use it we need to run:","category":"page"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"from julia import ModeCouplingTheory as mct","category":"page"},{"location":"FromPython.html#Usage","page":"From Python","title":"Usage","text":"","category":"section"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"And now we can use ModeCouplingTheory.jl in Python:","category":"page"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"# since Python doesn't like all unicode symbols (α, β, ∂, ...), we use standard letters:\nk = 3.99999\na = 1.0\nb = 0.0\nc = 1.0\nF0 = 1.0\ndF0 = 0.0\nkernel = mct.SchematicF2Kernel(k)\nproblem = mct.MCTProblem(a, b, c, F0, dF0, kernel)\nsolver = mct.FuchsSolver(problem)\nt, F, K = mct.solve(problem, solver, kernel)\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nplt.plot(np.log10(t), F)\nplt.show()","category":"page"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"et voilà!","category":"page"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"(Image: image)","category":"page"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"See the documentation of pyjulia for more information on how to call julia from python.","category":"page"},{"location":"index.html#ModeCouplingTheory.jl","page":"Introduction","title":"ModeCouplingTheory.jl","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"This package provides a generic and fast solver of mode-coupling theory-like integrodifferential equations. It uses the algorithm outlined in Fuchs et al. to solve equations of the form","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"alpha ddotF(t) + beta dotF(t) + gamma F(t) + int_0^t dtau K(t-tau)dotF(tau) = 0","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"in which alpha, beta, and gamma are coefficients, and K(t) = K(F(t) t). This package exports some commonly used memory kernels, but it is straightforward to define your own. The solver is differentiable and works for scalar- and vector-valued functions F(t). ","category":"page"},{"location":"index.html#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"To install the package run:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"import Pkg\nPkg.add(\"ModeCouplingTheory.jl\")","category":"page"},{"location":"index.html#Example","page":"Introduction","title":"Example","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"We can define one of the predefined memory kernels ","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"julia> using ModeCouplingTheory\njulia> λ = 3.999\n3.999\njulia> kernel = SchematicF2Kernel(λ)\nSchematicF2Kernel{Float64}(3.999)","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"This kernel evaluates K(t)=lambda F(t)^2.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"We can now define the equation we want to solve as follows:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"julia> α = 1.0; β = 0.0; γ = 2.0; F0 = 1.0; ∂F0 = 0.0;\njulia> problem = MCTProblem(α, β, γ, F0, ∂F0, kernel)\nMCTProblem{Float64, Float64, Float64, Float64, Float64}(1.0, 0.0, 2.0, 1.0, 0.0, 3.999, Float64, Float64, Float64)","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"and a solver:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"julia> solver = FuchsSolver(problem)","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Now we can solve the equation by calling solve:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"julia> using Plots\njulia> t, F, K = solve(problem, solver, kernel);\njulia> plot(log10.(t), F)","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"(Image: image)","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Full copy-pastable example:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"using ModeCouplingTheory, Plots\nλ = 3.999\nα = 1.0; β = 0.0; γ = 1.0; F0 = 1.0; ∂F0 = 0.0;\nkernel = SchematicF2Kernel(λ)\nproblem = MCTProblem(α, β, γ, F0, ∂F0, kernel)\nsolver = FuchsSolver(problem)\nt, F, K = solve(problem, solver, kernel);\nplot(log10.(t), F)","category":"page"},{"location":"API.html#Module-Index","page":"API Reference","title":"Module Index","text":"","category":"section"},{"location":"API.html","page":"API Reference","title":"API Reference","text":"Modules = [ModeCouplingTheory]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"API.html#Detailed-API","page":"API Reference","title":"Detailed API","text":"","category":"section"},{"location":"API.html","page":"API Reference","title":"API Reference","text":"Modules = [ModeCouplingTheory]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"API.html#ModeCouplingTheory.EulerSolver-Tuple{MCTProblem}","page":"API Reference","title":"ModeCouplingTheory.EulerSolver","text":"EulerSolver(problem::MCTProblem; t_max=10.0^2, Δt=10^-3, verbose=false)\n\nConstructs a solver object that, when called solve upon will solve an MCTProblem using a forward Euler method. It will discretise the integral using a Trapezoidal rule. Use this solver only for testing purposes. It is a wildy  inefficient way to solve MCT-like equations.\n\nArguments:\n\nproblem an instance of MCTProblem\nt_max when this time value is reached, the integration returns\nΔt fixed time step\nverbose if true, information will be printed to STDOUT\n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.ExponentiallyDecayingKernel","page":"API Reference","title":"ModeCouplingTheory.ExponentiallyDecayingKernel","text":"ExponentiallyDecayingKernel{T<:Number} <: MemoryKernel\n\nScalar kernel with fields λ and τ which when called returns λ exp(-t/τ).\n\n\n\n\n\n","category":"type"},{"location":"API.html#ModeCouplingTheory.FuchsSolver-Tuple{MCTProblem}","page":"API Reference","title":"ModeCouplingTheory.FuchsSolver","text":"FuchsSolver(problem; N=32, Δt=10^-10, t_max=10.0^10, max_iterations=10^4, tolerance=10^-10, verbose=false)\n\nUses the algorithm devised by Fuchs et al. to solve the MCTProblem.\n\nArguments:\n\nproblem: an instance of MCTProblem\nN: The number of time points in the interval is equal to 4N\nt_max: when this time value is reached, the integration returns\nΔt: starting time step, this will be doubled repeatedly\nmax_iterations: the maximal number of iterations before convergence is reached for each time doubling step\ntolerance: while the error is bigger than this value, convergence is not reached. The error by default is computed as the absolute sum of squares\nverbose: if true, information will be printed to STDOUT\ninplace: if true and the type of F is mutable, the solver will try to avoid allocating many temporaries\n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.MCTProblem-Union{Tuple{T}, Tuple{Any, Any, Any, T, T, MemoryKernel}} where T","page":"API Reference","title":"ModeCouplingTheory.MCTProblem","text":"MCTProblem(α, β, γ, F₀::T, ∂ₜF₀::T, kernel::MemoryKernel) where T\n\nConstructor of the MCTProblem type. It requires that F₀ and ∂ₜF₀ have the same type.\n\nArguments:\n\nα: coefficient in front of the second derivative term. If α and F₀ are both vectors, α will automatically be converted to a diagonal matrix, to make them compatible.\nβ: coefficient in front of the first derivative term. If β and F₀ are both vectors, β will automatically be converted to a diagonal matrix, to make them compatible.\nγ: coefficient in front of the second derivative term. If γ and F₀ are both vectors, γ will automatically be converted to a diagonal matrix, to make them compatible.\nF₀: initial condition of F(t)\n∂ₜF₀ initial condition of the derivative of F(t)\nkernel instance of a MemoryKernel that when called on F₀ and t=0, evaluates to the initial condition of the memory kernel.\n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.ModeCouplingKernel-NTuple{5, Any}","page":"API Reference","title":"ModeCouplingTheory.ModeCouplingKernel","text":"ModeCouplingKernel(ρ, kBT, m, k_array, Sₖ)\n\nConstructor of a ModeCouplingKernel. It implements the kernel K(k,t) = ρ kBT / (16π^3m) ∫dq V^2(k,q) F(q,t) F(k-q,t) in which k and q are vectors. \n\nArguments:\n\nρ: number density\nkBT: Thermal energy\nm : particle mass\nk_array: vector of wavenumbers at which the structure factor is known\nSₖ: structure factor\n\nReturns:\n\nan instance k of ModeCouplingKernel <: MemoryKernel, which can be called both in-place and out-of-place: k(out, F, t) out = k(F, t)\n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.MultiComponentModeCouplingKernel-NTuple{5, Any}","page":"API Reference","title":"ModeCouplingTheory.MultiComponentModeCouplingKernel","text":"MultiComponentModeCouplingKernel(ρ, kBT, m, k_array, Sₖ)\n\nConstructor of a MultiComponentModeCouplingKernel. It implements the kernel Kαβ(k,t) = ρ  / (2 xα xβ (2π)³) Σμνμ'ν' ∫dq Vμ'ν'(k,q) Fμμ'(q,t) Fνν'(k-q,t) Vμν(k,q) in which k and q are vectors and α and β species labels. \n\nArguments:\n\nρ: vector of number densities for each species\nkBT: Thermal energy\nm : vector of particle masses for each species\nk_array: vector of wavenumbers at which the structure factor is known\nSₖ: a Vector of Nk SMatrixs containing the structure factor of each component at each wave number\n\nReturns:\n\nan instance k of ModeCouplingKernel <: MemoryKernel, which can be called both in-place and out-of-place: k = MultiComponentModeCouplingKernel(ρ, kBT, m, k_array, Sₖ) out = k(F, t) k(out, F, t)\n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.SchematicDiagonalKernel","page":"API Reference","title":"ModeCouplingTheory.SchematicDiagonalKernel","text":"SchematicDiagonalKernel{T<:Union{SVector, Vector}} <: MemoryKernel\n\nMatrix kernel with field λ which when called returns Diagonal(λ .* F .^ 2), i.e., it implements a non-coupled system of SchematicF2Kernels.\n\n\n\n\n\n","category":"type"},{"location":"API.html#ModeCouplingTheory.SchematicF123Kernel","page":"API Reference","title":"ModeCouplingTheory.SchematicF123Kernel","text":"SchematicF1Kernel{T<:Number} <: MemoryKernel\n\nScalar kernel with fields λ1, λ2, and λ3 which when called returns λ1 * F^1 + λ2 * F^2 + λ3 * F^3.\n\n\n\n\n\n","category":"type"},{"location":"API.html#ModeCouplingTheory.SchematicF1Kernel","page":"API Reference","title":"ModeCouplingTheory.SchematicF1Kernel","text":"SchematicF1Kernel{T<:Number} <: MemoryKernel\n\nScalar kernel with field λ which when called returns λ F.\n\n\n\n\n\n","category":"type"},{"location":"API.html#ModeCouplingTheory.SchematicF2Kernel","page":"API Reference","title":"ModeCouplingTheory.SchematicF2Kernel","text":"SchematicF2Kernel{T<:Number} <: MemoryKernel\n\nScalar kernel with field λ which when called returns λ F^2.\n\n\n\n\n\n","category":"type"},{"location":"API.html#ModeCouplingTheory.SchematicMatrixKernel","page":"API Reference","title":"ModeCouplingTheory.SchematicMatrixKernel","text":"SchematicMatrixKernel{T<:Union{SVector, Vector}} <: MemoryKernel\n\nMatrix kernel with field λ which when called returns λ * F * Fᵀ, i.e., it implements Kαβ = λFαFβ.\n\n\n\n\n\n","category":"type"},{"location":"API.html#ModeCouplingTheory.evaluate_kernel!-Tuple{Any, MemoryKernel, Any, Any}","page":"API Reference","title":"ModeCouplingTheory.evaluate_kernel!","text":"evaluate_kernel!(out, kernel::MemoryKernel, F, t)\n\nEvaluates the memory kernel in-place, overwriting the elements of the out variable. It may mutate the content of kernel.\n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.evaluate_kernel-Tuple{MemoryKernel, Any, Any}","page":"API Reference","title":"ModeCouplingTheory.evaluate_kernel","text":"evaluate_kernel(kernel::MemoryKernel, F, t)\n\nEvaluates the memory kernel out-place. It may mutate the content of kernel.\n\nReturns\n\nout the kernel evaluated at (F, t)\n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.find_relaxation_time-Tuple{Any, Any}","page":"API Reference","title":"ModeCouplingTheory.find_relaxation_time","text":"find_relaxation_time(t, F; threshold=exp(-1), mode=:log)\n\nFinds the time at which a signal first decreases below some threshold. Uses interpolation to find an accurate result\n\nArguments:\n\nt: a vector of time values at which the signal F is known\nF: the signal\nthreshold: see above\nmode: uses interpolation either in a logarithmic or linear space. \n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.solve-Tuple{MCTProblem, ModeCouplingTheory.Solver, MemoryKernel}","page":"API Reference","title":"ModeCouplingTheory.solve","text":"solve(problem::MCTProblem, solver::Solver, kernel::MemoryKernel)\n\nSolves the MCTproblem with the provided kernel using solver.  Search for a specific solver or kernel object to find more specific information.\n\nReturns:\n\nt an array of time values\nF The solution in an array of which the last dimension corresponds to the time.\nK The memory kernel corresponding to each F\n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.solve_steady_state-Tuple{Any, Vector, Any}","page":"API Reference","title":"ModeCouplingTheory.solve_steady_state","text":"solve_steady_state(γ, F₀, kernel; tolerance=10^-8, max_iterations=10^6, verbose=false)\n\nFinds the steady-state solution (non-ergodicity parameter) of the generalized Langevin equation by recursive iteration of F = (K + γ)⁻¹ * K(F) * F₀\n\nArguments:\n\nγ: parameter in front of the linear term in F\nF₀: initial condition of F. This is also the initial condition of the rootfinding method.\nkernel: callable memory kernel\nmax_iterations: the maximal number of iterations before convergence is reached\ntolerance: while the error is bigger than this value, convergence is not reached. The error by default is computed as the absolute sum of squares between successive iterations\nverbose: if true, information will be printed to STDOUT\n\nReturns:\n\nThe steady state solution\n\n\n\n\n\n","category":"method"}]
}
