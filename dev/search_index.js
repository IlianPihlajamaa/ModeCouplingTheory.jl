var documenterSearchIndex = {"docs":
[{"location":"Kernels.html#Kernels","page":"Kernels","title":"Kernels","text":"","category":"section"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"A memory kernel kernel is an instance of a type of which MemoryKernel is a supertype. It can be called like out = evaluate_kernel(kernel, F, t). Additionally, when F is a mutable container like a Vector, it can be called like evaluate_kernel!(out, kernel, F, t) in which case it will mutate the elements of the temporary array out. Below we list the memory kernels that this package defines and give some examples of how to use them.","category":"page"},{"location":"Kernels.html#Schematic-Kernels","page":"Kernels","title":"Schematic Kernels","text":"","category":"section"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"This package includes a couple of schematic memory kernels.","category":"page"},{"location":"Kernels.html#.-ExponentiallyDecayingKernel","page":"Kernels","title":"1. ExponentiallyDecayingKernel","text":"","category":"section"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"The ExponentiallyDecayingKernel implements the kernel K(t) = λ exp(-tτ). It has fields λ <: Number and τ <: Number.","category":"page"},{"location":"Kernels.html#Example","page":"Kernels","title":"Example","text":"","category":"section"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"The integro-differential equation with this memory kernel actually has an analytic solution for tau=1, alpha=0 , beta=1, and gamma=1. It is given by","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"F(t) = frace^-fract2left( lambda + sqrtlambda(lambda+4) + 2right)2 sqrtlambda  (lambda +4)left(sqrtlambda(lambda+4) left(e^sqrtlambda(lambda+4) t+1right)+lambda  left(e^sqrtlambda(lambda+4) t-1right)right)","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"F0 = 1.0; ∂F0 = 0.0; α = 0.0; β = 1.0; γ = 1.0; λ = 1.0; τ = 1.0;\n\nkernel = ExponentiallyDecayingKernel(λ, τ)\nproblem = LinearMCTEquation(α, β, γ, F0, ∂F0, kernel)\nsolver = FuchsSolver(Δt=10^-3, t_max=10.0^2, verbose=false, N = 128, tolerance=10^-10, max_iterations=10^6)\nsol =  solve(problem, solver)\n\nt_analytic = 10 .^ range(-3, 2, length=50)\nF_analytic = @. (exp(-0.5*(3+sqrt(5))* t_analytic)*(exp(sqrt(5)*t_analytic) * (1+sqrt(5))-1+sqrt(5)))/(2sqrt(5))\n\nusing Plots\np = plot(log10.(sol.t), sol.F, label=\"Numeric solution\", lw=3)\nscatter!(log10.(t_analytic), F_analytic, label=\"Exact solution\", ylabel=\"F\", xlabel=\"log10(t)\")","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"(Image: image)","category":"page"},{"location":"Kernels.html#SchematicF1Kernel","page":"Kernels","title":"SchematicF1Kernel","text":"","category":"section"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"The SchematicF1Kernel implements the kernel K(t) = ν F(t). It has one field ν <: Number.","category":"page"},{"location":"Kernels.html#Example-2","page":"Kernels","title":"Example","text":"","category":"section"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"The integro-differential equation with this memory kernel also has an analytic solution for alpha=0 , beta=1, and gamma=1. It is given by","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"F(t) =  e^-2tleft(I_0(2t) + I_1(2t) right)","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"in which I_k are modified Bessel functions of the first kind.","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"F0 = 1.0; ∂F0 = 0.0; α = 0.0; β = 1.0; γ = 1.0; ν = 1.0\n\nkernel = SchematicF1Kernel(ν)\nproblem = LinearMCTEquation(α, β, γ, F0, ∂F0, kernel)\nsolver = FuchsSolver(Δt=10^-3, t_max=10.0^2, verbose=false, N = 100, tolerance=10^-14, max_iterations=10^6)\nsol =  solve(problem, solver)\n\nusing Plots, SpecialFunctions\nt_analytic = 10 .^ range(-3, 2, length=50)\nF_analytic = @. exp(-2*t_analytic)*(besseli(0, 2t_analytic) + besseli(1, 2t_analytic))\nplot(log10.(sol.t), sol.F, label=\"Numerical Solution\", ylabel=\"F\", xlabel=\"log10(t)\", lw=3)\nscatter!(log10.(t_analytic), F_analytic, label=\"Exact Solution\")","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"(Image: image)","category":"page"},{"location":"Kernels.html#SchematicF2Kernel","page":"Kernels","title":"SchematicF2Kernel","text":"","category":"section"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"The SchematicF2Kernel implements the kernel K(t) = ν F(t)^2. It has one field ν <: Number.","category":"page"},{"location":"Kernels.html#SchematicF123Kernel","page":"Kernels","title":"SchematicF123Kernel","text":"","category":"section"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"The SchematicF123Kernel implements the kernel K(t) = nu_1 F(t) + nu_2 F(t)^2 + nu_3 F(t)^3. It has fields ν1 <: Number, ν2 <: Number, and ν3 <: Number.","category":"page"},{"location":"Kernels.html#Example-3","page":"Kernels","title":"Example","text":"","category":"section"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"kernel = SchematicF123Kernel(3.0, 2.0, 1.0);\nF = 2; t = 0;\nevaluate_kernel(kernel, F, t) # returns 22.0 = 3*2^1 + 2*2^2 + 1*2^3","category":"page"},{"location":"Kernels.html#InterpolatingKernel","page":"Kernels","title":"InterpolatingKernel","text":"","category":"section"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"The InterpolatingKernel implements a kernel that interpolates memory kernel data. It is initialized by calling kernel = InterpolatingKernel(t, M, k=k) where t is a Vector of time points, M is a vector of corresponding memory kernel values, and k is the integer degree of polynomial interpolation (default=1). This kernel is oimplemented using Dierckx.Spline1D. See Dierckx.jl for more information.","category":"page"},{"location":"Kernels.html#SchematicDiagonalKernel","page":"Kernels","title":"SchematicDiagonalKernel","text":"","category":"section"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"The SchematicDiagonalKernel implements the kernel K_ij(t) = delta_ij nu_i F_i(t)^2. It has one field ν which must be either a Vector or an SVector. When called, it returns Diagonal(ν .* F .^ 2), i.e., it implements a non-coupled system of SchematicF2Kernels.","category":"page"},{"location":"Kernels.html#SchematicMatrixKernel","page":"Kernels","title":"SchematicMatrixKernel","text":"","category":"section"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"The SchematicMatrixKernel implements the kernel K_ij(t) = sum_k lambda_ij F_k(t) F_j(t). It has one field ν which must be either a Matrix or an SMatrix. ","category":"page"},{"location":"Kernels.html#SjogrenKernel","page":"Kernels","title":"SjogrenKernel","text":"","category":"section"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"The SjogrenKernel implements the kernel K_1(t) = nu_1 F_1(t)^2, K_2(t) = nu_2 F_1(t) F_2(t). It has two fields ν1 and ν2 which must both be of the same type. Consider using Static Vectors for performance. Example:","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"using StaticArrays\nα = 1.0\nβ = 0.0\nγ = 1.0\nν1 = 2.0\nν2 = 1.0\nF0 = @SVector [1.0, 1.0]\n∂F0 = @SVector [0.0, 0.0]\nkernel = SjogrenKernel(ν1, ν2)\neq = LinearMCTEquation(α, β, γ, F0, ∂F0, kernel)\nsol = solve(eq)","category":"page"},{"location":"Kernels.html#TaggedSchematicF2Kernel","page":"Kernels","title":"TaggedSchematicF2Kernel","text":"","category":"section"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"The TaggedSchematicF2Kernel implements a memory kernel K(t) = nu F(t) F_c(t), where F_c(t) is a correlator that the tagged one couples to. It must be a solution of an earlier schematic MCT equation. Make sure to use the same solver settings for both solves. ","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"Example:","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"F0 = 1.0\n∂F0 = 0.0\nα = 1.0\nβ = 0.0\nγ = 1.0\nν1 = 2.0\nν2 = 1.0\nkernel = SchematicF2Kernel(ν1)\neq = LinearMCTEquation(α, β, γ, F0, ∂F0, kernel)\nsol = solve(eq)\n\ntaggedkernel = TaggedSchematicF2Kernel(ν2, sol)\ntagged_eq = LinearMCTEquation(α, β, γ, F0, ∂F0, taggedkernel)\ntagged_sol = solve(tagged_eq);","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"This example is (less performantly) equivalent to the example of the Sjogren kernel above. ","category":"page"},{"location":"Kernels.html#Mode-Coupling-Theory","page":"Kernels","title":"Mode-Coupling Theory","text":"","category":"section"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"The mode-coupling theory equation reads","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"ddotF(kt) + Omega(k)F(kt) + int_0^tdtau K(t-tau k)dotF(ktau)=0","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"in which Omega(k) = k^2 k_B TmS(k), and","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"K(kt) =fracrho k_BT16pi^3 m int dmathbfq V(mathbfk mathbfq)^2F(q t)F(mathbfk-mathbfqt)","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"in which the vertex V(textbfk textbfq) = (textbfkcdottextbfq)c(q)k+(textbfkcdot(textbfk-textbfq)c(textbfk-textbfq)k. For more details and the meaning of the symbols, see [1, 2].","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"This memory kernel integral is discretised as follows:","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"int dtextbfqf(q textbfk-textbfq) = 2piint_0^infty dq q^2 int_0^pi dtheta sin theta f(q textbfk-textbfq) = frac2pikint_0^infty dq int_k-q^k+qdp pq f(q p) approx frac2pi Delta k^2k_isum_j=1^N_k sum_l=j-i+1^j+i-1 fracp_l q_jk_if(q_j p_l)","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"in which p = textbfk-textbfq, and wave numbers k, q and p are discretized on the equidistant grid k_i = (i_k-frac12)Delta k where i_k = 1 2 3 ldots N_k. The double sum is then performed for all k using Bengtzelius' trick, yielding a fast O(N_k^2) algorithm.","category":"page"},{"location":"Kernels.html#Example-4","page":"Kernels","title":"Example","text":"","category":"section"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"\"\"\"\n    find_analytical_C_k(k, η)\nFinds the direct correlation function given by the \nanalytical Percus-Yevick solution of the Ornstein-Zernike \nequation for hard spheres for a given volume fraction η.\n\nReference: Wertheim, M. S. \"Exact solution of the Percus-Yevick integral equation \nfor hard spheres.\" Physical Review Letters 10.8 (1963): 321.\n\"\"\" \nfunction find_analytical_C_k(k, η)\n    A = -(1 - η)^-4 *(1 + 2η)^2\n    B = (1 - η)^-4*  6η*(1 + η/2)^2\n    D = -(1 - η)^-4 * 1/2 * η*(1 + 2η)^2\n    Cₖ = @. 4π/k^6 * \n    (\n        24*D - 2*B * k^2 - (24*D - 2 * (B + 6*D) * k^2 + (A + B + D) * k^4) * cos(k)\n     + k * (-24*D + (A + 2*B + 4*D) * k^2) * sin(k)\n     )\n    return Cₖ\nend\n\n\"\"\"\n    find_analytical_S_k(k, η)\nFinds the static structure factor given by the \nanalytical Percus-Yevick solution of the Ornstein-Zernike \nequation for hard spheres for a given volume fraction η.\n\"\"\" \nfunction find_analytical_S_k(k, η)\n        Cₖ = find_analytical_C_k(k, η)\n        ρ = 6/π * η\n        Sₖ = @. 1 + ρ*Cₖ / (1 - ρ*Cₖ)\n    return Sₖ\nend\n\n# We solve MCT for hard spheres at a volume fraction of 0.51591\nη = 0.51591; ρ = η*6/π; kBT = 1.0; m = 1.0\n\nNk = 100; kmax = 40.0; dk = kmax/Nk; k_array = dk*(collect(1:Nk) .- 0.5)\nSₖ = find_analytical_S_k(k_array, η)\n\n∂F0 = zeros(Nk); α = 1.0; β = 0.0; γ = @. k_array^2*kBT/(m*Sₖ)\n\nkernel = ModeCouplingKernel(ρ, kBT, m, k_array, Sₖ)\nproblem = LinearMCTEquation(α, β, γ, Sₖ, ∂F0, kernel)\nsolver = FuchsSolver(Δt=10^-5, t_max=10.0^15, verbose=false, \n                     N = 8, tolerance=10^-8)\nsol = @time solve(problem, solver);\n    # 3.190870 seconds (377.93 k allocations: 106.456 MiB, 0.42% gc time)\np = plot(xlabel=\"log10(t)\", ylabel=\"F(k,t)\", ylims=(0,1))\nfor ik = [7, 18, 25, 39]\n    plot!(p, log10.(sol.t), sol[ik]/Sₖ[ik], label=\"k = $(k_array[ik])\", lw=3)\nend\np","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"(Image: image)","category":"page"},{"location":"Kernels.html#References","page":"Kernels","title":"References","text":"","category":"section"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"[1] Reichman, David R., and Patrick Charbonneau. \"Mode-coupling theory.\" Journal of Statistical Mechanics: Theory and Experiment 2005.05 (2005): P05013.","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"[2] Janssen, Liesbeth MC. \"Mode-coupling theory of the glass transition: A primer.\" Frontiers in Physics 6 (2018): 97.","category":"page"},{"location":"Kernels.html#Multi-component-Mode-Coupling-Theory","page":"Kernels","title":"Multi-component Mode-Coupling Theory","text":"","category":"section"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"The multi-component mode-coupling theory equation reads","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"ddotF_alphabeta(kt) + Omega_alphagamma(k)F_gammabeta(kt) + int_0^tdtau K_alphagamma(t-tau k)dotF_gammabeta(k tau)=0","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"in which Omega_alphagamma = k^2 k_B T x_alpham_alpha cdot left(S^-1right)_alphagamma(k), and textbfS(k) = (fracdelta_alphabetax_alpha - rho c_alphagamma(k)). The memory kernel is given by","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"K_alphabeta(kt) =frack_B T rho2 x_beta m_alpha (2pi)^3 int dmathbfq V_munualpha(mathbfk mathbfq)F_mumu(q t)F_nunu(mathbfk-mathbfqt)V_munubeta(mathbfk mathbfq)","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"in which the vertex V_munualpha(mathbfk mathbfq) = (textbfkcdottextbfq)c_alphamu(q)delta_alphanuk+(textbfkcdot(textbfk-textbfq)c_alphanu(textbfk-textbfq)delta_alphamuk. Here, the Greek indices indicate species labels, and we have adopted the convention that we sum over repeated indices. This memory kernel has also been implemented using the Bengtzelius' trick. It requires O(N_k^2 N_s^2) storage and runs in O(N_k^2 N_s^4) in which N_s is the number of species.","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"Numerically, the correlator F_alphabeta(k) is implemented as a Vector of length Nk of which each of the elements is a small Ns x Ns static matrix. This means that this is also the expected form of the initial condition.","category":"page"},{"location":"Kernels.html#Example-5","page":"Kernels","title":"Example","text":"","category":"section"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"using StaticArrays, LinearAlgebra, DelimitedFiles\n# number of species Ns, number of wave numbers Nk, volume fraction η\n# thermal energy kBT and mass m\nNs = 2; Nk = 100; η  = 0.515; kBT = 1.0; m = ones(Ns)\nparticle_diameters = [0.8,1.0]\nx = [0.2,0.8] # concentration fraction\n\n# total density\nρ_all = 6η/(π*sum(x .* particle_diameters .^3))\nρ = ρ_all * x\n\nkmax = 40.0; dk = kmax/Nk\nk_array = dk*(collect(1:Nk) .- 0.5)\n\n# data can be found in the \\test\\ folder of the source code\nSₖdata = reshape(readdlm(\"Sk_MC.txt\"), (2,2,100))\n# convert the data to the Vector of SMatrix format\nSₖ = [@SMatrix(zeros(Ns, Ns)) for i = 1:Nk]\nfor i = 1:Nk\n    Sₖ[i] = Sₖdata[:, :, i]\nend\nS⁻¹ = inv.(Sₖ)\n\nJ = similar(Sₖ) .* 0.0\nfor ik = 1:Nk\n    J[ik] = kBT*k_array[ik]^2 * x ./ m .* I(Ns)\nend\n\nF₀ = copy(Sₖ)\n∂ₜF₀ = [@SMatrix(zeros(Ns, Ns)) for i = 1:Nk]\nα = 0.0\nβ = 1.0\nΩ = similar(Sₖ)\nΩ .*= 0.0\nfor ik = 1:Nk\n    Ω .= J.*S⁻¹\nend\n\nkernel = MultiComponentModeCouplingKernel(ρ, kBT, m, k_array, Sₖ)\nproblem = LinearMCTEquation(α, β, Ω, F₀, ∂ₜF₀, kernel)\nsolver = FuchsSolver(verbose=false, N=16, tolerance=10^-8, max_iterations=10^8)\nsol = solve(problem, solver)\nik = 19\nk = k_array[ik]\nt = sol.t\np = plot(log10.(t), getindex.(sol[ik], 1,1)/Sₖ[ik][1,1], ls=:dash, lw=2, color=1, label=\"Faa(k=$k, t)\") \nplot!(log10.(t), getindex.(sol[ik], 1,2)/Sₖ[ik][1,2], lw=2, color=2, label=\"Fab(k=$k, t)\") \nplot!(log10.(t), getindex.(sol[ik], 2,1)/Sₖ[ik][2,1], ls=:dash, lw=2, color=3, label=\"Fba(k=$k, t)\") \nplot!(log10.(t), getindex.(sol[ik], 2,2)/Sₖ[ik][2,2], ls=:dash, lw=2, color=4, label=\"Fbb(k=$k, t)\")","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"(Image: image)","category":"page"},{"location":"Kernels.html#Defining-custom-kernels","page":"Kernels","title":"Defining custom kernels","text":"","category":"section"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"In order to define a custom kernel, one has to overload ModeCouplingTheory.evaluate_kernel(k::MyCustomKernel, F, t), and optionally  ModeCouplingTheory.evaluate_kernel!(out, k::MyCustomKernel, F, t) for better performance for mutable F.","category":"page"},{"location":"Kernels.html#Example-1","page":"Kernels","title":"Example 1","text":"","category":"section"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"Let's define a custom scalar kernel that evaluates K(t) = alpha F(t)^F(t). First, we define a MyWeirdKernel<:MemoryKernel type that holds the value of the parameter:","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"using ModeCouplingTheory\nimport ModeCouplingTheory.MemoryKernel\n\nstruct MyWeirdKernel <: MemoryKernel\n    α :: Float64\nend\n\nkernel = MyWeirdKernel(2.5)","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"Now, we can define the evaluation of this memory kernel","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"import ModeCouplingTheory.evaluate_kernel\n\nfunction evaluate_kernel(kernel::MyWeirdKernel, F, t)\n    return kernel.α*F^F\nend","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"That's it! We can now use it like any other memory kernel to solve the equation:","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"problem = LinearMCTEquation(1.0, 0.0, 1.0, 1.0, 0.0, kernel)\nsolver = FuchsSolver(Δt = 10^-4, t_max=10.0^5)\nsol = solve(problem, solver)\nusing Plots\np = plot(log10.(sol.t), sol.F, ylims=(0,1), ylabel=\"F(t)\", xlabel=\"log10(t)\")","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"(Image: image)","category":"page"},{"location":"Kernels.html#Example-2","page":"Kernels","title":"Example 2","text":"","category":"section"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"For a slightly more complex example, let's define the tagged-particle mode-coupling theory memory kernel. The equation is given by:","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"ddotF_s(kt) + frack^2 k_BTm F_s(kt) + int_0^t dtau K(k t-tau)dotF_s(k tau)=0","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"in which","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"K(kt) = fracrho k_BT8pi^2 mint dmathbfq V(mathbfk mathbfq)^2 F(q t)F_s(mathbfk-mathbfqt)","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"where","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"V(textbfk textbfq) = (textbfkcdottextbfq)c(q)k = frack^2+q^2-p^22k cdot c(q)","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"where p = textbfk - textbfq. Note that in the equation for the memory kernel, the solution of collective mode-coupling theory F(kt) appears (without subscript s). The most straightforward way of solving the tagged-particle equation therefore is to solve the full collective equation first, and use the result in the memory kernel of the tagged-particle motion. So, first we quickly solve MCT:","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"using ModeCouplingTheory, LinearAlgebra\nη = 0.51591; ρ = η*6/π; kBT = 1.0; m = 1.0\n\nNk = 100; kmax = 40.0; dk = kmax/Nk; k_array = dk*(collect(1:Nk) .- 0.5)\n# We use the Percus-Yevick solution to the structure factor that can be found above.\nSₖ = find_analytical_S_k(k_array, η)\n\n∂F0 = zeros(Nk); α = 1.0; β = 0.0; γ = @. k_array^2*kBT/(m*Sₖ)\n\nkernel = ModeCouplingKernel(ρ, kBT, m, k_array, Sₖ)\nproblem = LinearMCTEquation(α, β, γ, Sₖ, ∂F0, kernel)\nsolver = FuchsSolver(Δt=10^-5, t_max=10.0^15, verbose=false, \n                     N = 8, tolerance=10^-8)\nsol = @time solve(problem, solver);","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"Now, we need to construct the tagged-particle memory kernel for the self intermediate scattering function Fs. When called with evaluate_kernel(kernel, Fs, t) it needs some way to access the collective F at the right time. To make that easy, we create a dictionary that maps the values in t to their respective indices.","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"tDict = Dict(zip(t, eachindex(t)))\n# tdict[t[8]] == 8","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"Now we can construct a memory kernel like above. For performance reasons, we also implement the in-place evaluate_kernel!(out, kernel, Fs, t). The discrete equation that we must implement is given by ","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"K(k_it) = fracrho k_B T Delta k^24 pi^2 m sum_j=1^N_k sum_l=j-i+1^j+i-1 fracp_l q_jk_i V^2(k_i q_j p_l)F(k_j t)F_s(k_l t)","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"This memory kernel can now be straightforwardly implemented as follows:","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"import ModeCouplingTheory.MemoryKernel\nstruct TaggedMCTKernel <: MemoryKernel\n    V²::Array{Float64, 3}\n    k_array::Vector{Float64}\n    prefactor::Float64\n    F::Matrix{Float64}\n    tDict::Dict{Float64, Int64}\nend\n\n# The constructor for the TaggedMCTKernel\nfunction TaggedMCTKernel(ρ, kBT, m, k_array, Cₖ, t, F)\n    tDict = Dict(zip(t, eachindex(t)))\n    Δk = k_array[2] - k_array[1]\n    prefactor = ρ*kBT*Δk^2/(4*π^2*m)\n    Nk = length(k_array)\n    # calculate the vertices\n    V² = zeros(Nk, Nk, Nk)\n    for i = 1:Nk, j = 1:Nk, l = 1:Nk # loop over k, q, p\n        k = k_array[i]\n        q = k_array[j]\n        cq = Cₖ[j]\n        p = k_array[l]\n        if abs(j-i)+1 <= l <= j+i-1\n            V²[l, j, i] = (cq * (k^2  + q^2 - p^2)/(2k))^2\n        end\n    end\n    return TaggedMCTKernel(V², k_array, prefactor, F, tDict)\nend\n","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"Now to evaluate the kernel, we first write the in-place version of the code, that mutates its first argument. Note also that, since the mermory kernel is multiplied with a vector F to produce something of the same type of F, it has to be encoded as a matrix, with on the diagonal the discretised wave-number dependent memory kernel.","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"import ModeCouplingTheory.evaluate_kernel!\nfunction evaluate_kernel!(out::Diagonal, kernel::TaggedMCTKernel, Fs, t)\n    out.diag .= zero(eltype(out.diag)) # set the output array to zero\n    it = kernel.tDict[t] # find the correct index corresponding to t\n    k_array = kernel.k_array\n    Nk = length(k_array)\n    for i = 1:Nk, j = 1:Nk, l = 1:Nk # loop over k, q, p\n        k = k_array[i]\n        q = k_array[j]\n        p = k_array[l]\n        out.diag[i] += p*q/k * kernel.V²[l, j, i] * kernel.F[j, it] * Fs[l]\n    end\n    out.diag .*= kernel.prefactor\nend\n\nimport ModeCouplingTheory.evaluate_kernel\nfunction evaluate_kernel(kernel::TaggedMCTKernel, Fs, t)\n    out = Diagonal(similar(Fs)) # we need it to produce a diagonal matrix\n    evaluate_kernel!(out, kernel, Fs, t) # call the inplace version\n    return out\nend","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"Now we can finally solve the tagged equation:","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"Cₖ = find_analytical_C_k(k_array, η)\nF0 = ones(Nk); ∂F0 = zeros(Nk); α = 1.0; β = 0.0; γ = @. k_array^2*kBT/m\n\ntaggedkernel = TaggedMCTKernel(ρ, kBT, m, k_array, Cₖ, t, F)\ntaggedproblem = LinearMCTEquation(α, β, γ, F0, ∂F0, taggedkernel)\ntaggedsolver = FuchsSolver(Δt=10^-5, t_max=10.0^15, \n                           N = 8, tolerance=10^-8) # it is important we use the same settings for Δt, t_max and N\nsol_s = @time solve(taggedproblem, taggedsolver)\nusing Plots\np = plot(xlabel=\"log10(t)\", ylabel=\"Fₛ(k,t)\", ylims=(0,1))\nfor ik = [7, 18, 25, 39]\n    plot!(p, log10.(sol_s.t), sol_s[ik], label=\"k = $(k_array[ik])\", lw=3)\nend\np","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"(Image: image)","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"This implementation of the tagged-particle memory kernel is an order of magnitude slower than the built-in collective one, and can be made much more performant by Bengtzelius' trick. For the purposes of this example, however, we do not pursue this any further. For help with implementing your own kernel, please file an issue.","category":"page"},{"location":"Kernels.html#Bengtzelius'-Trick","page":"Kernels","title":"Bengtzelius' Trick","text":"","category":"section"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"Bengtzelius' trick is a fast way to evaluate the integral I(k) = int d mathbfq A(q mathbfk-mathbfq). Very briefly: after discretisation of the integral, one is left with terms such as T_iA=sum_j=1^N_ksum_l=j-i+1^i+j-1  A(p_lq_j) which are largely independent of i. Because of this, one can calculate T_iA from T_i-1A in order N_k operations. The recurrence relation that allows one to do so is given by ","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"T_iA = T_i-1A + sum_j=1^N_k-i+1(A(j j+i-1)+A(j+i-1 j)) - sum_j=1^i-1A(ji-j)","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"with initial condition","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"T_1A = sum_j=1^N_kA(j j)","category":"page"},{"location":"Scope.html#Automatic-differentiation","page":"Scope","title":"Automatic differentiation","text":"","category":"section"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"This package is compatible with forward-mode automatic differentiation. This makes it possible to calculate quatities such as fracdF(t)dlambda for example, where lambda is a parameter of the memory kernel.","category":"page"},{"location":"Scope.html#Example","page":"Scope","title":"Example","text":"","category":"section"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"Let's take the derivative of the solution to the generalized Langevin equation with the exponentially decaying kernel with respect to the coupling parameter. First we need to write a function that solves this equation and outputs the solution for a given coupling parameter. Since we know the analytical solution, we can compare with the derivative of that.","category":"page"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"using ModeCouplingTheory, Plots\nfunction my_func(λ)\n    F0 = 1.0\n    ∂F0 = 0.0\n    α = 0.0\n    β = 1.0\n    γ = 1.0\n\n    kernel = ExponentiallyDecayingKernel(λ, 1.0)\n    problem = LinearMCTEquation(α, β, γ, F0, ∂F0, kernel)\n    solver = FuchsSolver(Δt=10^-4, t_max=5*10.0^1, verbose=false, N = 128, tolerance=10^-10, max_iterations=10^6)\n\n    sol =  solve(problem, solver)\n    return [sol.t[2:end], sol.F[2:end], sol.K[2:end]]\nend\n\nfunction exact_func(λ, t)\n    temp = sqrt(λ*(λ+4)) \n    F = @. exp(-0.5* t*(temp+λ+2)) * (temp*(exp(temp*t)+1)+ λ* (exp(temp*t)-1)) / (2temp) \n    return [t, F]\nend\n\nsol = my_func(5.0)\ntexact, Fexact = exact_func(5.0, t)\n\np = plot(log10.(texact), Fexact, label=\"Exact\", lw=4) \nscatter!(log10.(sol.t[1:100:end]), sol.F[1:100:end], label=\"Numerical solution\", ls=:dash, lw=4) ","category":"page"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"(Image: image)","category":"page"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"Now we can take the derivative with respect to the argument of the functions we defined:","category":"page"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"using ForwardDiff\n_, dF_exact = ForwardDiff.derivative(y -> exact_func(y, t), 5.0)\nsol = ForwardDiff.derivative(my_func, 5.0)\n\np = plot(log10.(texact), dF_exact, lw=3, label=\"Exact\", ylabel=\"dF/dλ(λ=5,t)\", xlabel=\"log10(t)\") \nplot!(log10.(sol.t), sol.dF, ls=:dash, lw=3, label=\"Numerical solution\", legend=:topleft)","category":"page"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"(Image: image)","category":"page"},{"location":"Scope.html#Measurement-errors-and-other-number-types","page":"Scope","title":"Measurement errors and other number types","text":"","category":"section"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"Similar to automatically evaluating derivatives, it is also possible to automatically propagate measurement errors through the entire solution process. This does however cause a serious performace loss. It works by instead of doing arithmatic with standard floating point numbers, it uses numbers with an error attached. The  Measurements.jl package implements how arithmatic with such numbers should be performed. Analagously, one can use arbitrary precision arithmatic (when many decimal places of precision are required) or complex valued numbers together with this package.","category":"page"},{"location":"Scope.html#Example-2","page":"Scope","title":"Example","text":"","category":"section"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"Let's solve standard mode-coupling theory with a structure factor that contains measurement errors. To generate such a structure factor, we can use the analytical Percus-Yevick expression, but pretend there is an uncertainty in the volume fraction eta.","category":"page"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"\njulia> using ModeCouplingTheory, Plots, Measurements\n\njulia> η = 0.51 ± 0.01\n0.51 ± 0.05\n\njulia> ρ = η*6/π\n0.974 ± 0.019\n\njulia> kBT = 1.0; m = 1.0;\n\njulia> Nk = 100; kmax = 40.0; dk = kmax/Nk; k_array = dk*(collect(1:Nk) .- 0.5);","category":"page"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"We use the same functions to find the structure factor as before:","category":"page"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"\"\"\"\nFinds the fourier transform of the direct correlation function given by the \nanalytical percus yevick solution of the Ornstein Zernike \nequation for hard spheres for a given volume fraction η on the coordinates r\nin units of one over the diameter of the particles\n\"\"\" \nfunction find_analytical_C_k(k, η)\n    A = -(1 - η)^-4 *(1 + 2η)^2\n    B = (1 - η)^-4*  6η*(1 + η/2)^2\n    D = -(1 - η)^-4 * 1/2 * η*(1 + 2η)^2\n    Cₖ = @. 4π/k^6 * \n    (\n        24*D - 2*B * k^2 - (24*D - 2 * (B + 6*D) * k^2 + (A + B + D) * k^4) * cos(k)\n     + k * (-24*D + (A + 2*B + 4*D) * k^2) * sin(k)\n     )\n    return Cₖ\nend\n\n\"\"\"\nFinds the static structure factor given by the \nanalytical percus yevick solution of the Ornstein Zernike \nequation for hard spheres for a given volume fraction η on the coordinates r\nin units of one over the diameter of the particles\n\"\"\" \nfunction find_analytical_S_k(k, η)\n        Cₖ = find_analytical_C_k(k, η)\n        ρ = 6/π * η\n        Sₖ = @. 1 + ρ*Cₖ / (1 - ρ*Cₖ)\n    return Sₖ\nend\n\njulia> Sₖ_uncertain = find_analytical_S_k(k_array, ρ*π/6)\n100-element Vector{Measurement{Float64}}:\n  0.0142 ± 0.0014\n  0.0145 ± 0.0015\n  0.0152 ± 0.0015\n  0.0163 ± 0.0017\n         ⋮\n  1.0154 ± 0.0012\n  0.9987 ± 0.00012\n 0.98327 ± 0.00089\n\njulia> plot(k_array, Sₖ_uncertain, xlabel=\"k\", ylabel=\"S(k)\", legend=false)","category":"page"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"(Image: image)","category":"page"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"Now we can use this structure factor to solve the mode-coupling equation as usual.","category":"page"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"# The initial condition of the derivative must have the same type as the initial condition itself\n∂F0 = zeros(eltype(Sₖ_uncertain), Nk)\nα = 1.0; β = 0.0; γ = @. k_array^2*kBT/(m*Sₖ_uncertain)\nkernel = ModeCouplingKernel(ρ, kBT, m, k_array, Sₖ_uncertain)\nproblem = LinearMCTEquation(α, β, γ, Sₖ_uncertain, ∂F0, kernel)\nsolver = FuchsSolver(Δt=10^-5, t_max=10.0^5, verbose=true, N = 8, tolerance=10^-8, max_iterations=10^8)\nsol = @time solve(problem, solver);\np = plot(xlabel=\"log10(t)\", ylabel=\"F(k,t)\", ylims=(0,1), xlims=(-5,5))\nplot!(p, log10.(sol.t[2:10:end]), sol[19]/Sₖ_uncertain[19], label=\"k = $(k_array[19])\", lw=3)","category":"page"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"(Image: image)","category":"page"},{"location":"Scope.html#Steady-state-(non-ergodicity-parameter)","page":"Scope","title":"Steady state (non-ergodicity parameter)","text":"","category":"section"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"This package also exports a function solve_steady_state(γ, F₀, kernel; tolerance=10^-8, max_iterations=10^6, verbose=false) to find the steady-state solution of a mode-coupling like equation. In order to find it, it performs a recursive iteration of the mapping ","category":"page"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"F^infty = (K(F^inftyt=infty) + γ)^-1 cdot K(F^infty t=infty) cdot F(t=0)","category":"page"},{"location":"Scope.html#Example-3","page":"Scope","title":"Example","text":"","category":"section"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"using ModeCouplingTheory, Plots\nη = 0.51595; ρ = η*6/π; kBT = 1.0; m = 1.0\nNk = 100; kmax = 40.0; dk = kmax/Nk; k_array = dk*(collect(1:Nk) .- 0.5);\nSₖ = find_analytical_S_k(k_array, ρ*π/6)\n\nγ = @. k_array^2*kBT/(m*Sₖ)\nkernel = ModeCouplingKernel(ρ, kBT, m, k_array, Sₖ)\nfk = solve_steady_state(γ, Sₖ, kernel; tolerance=10^-8, verbose=false)\np = plot(k_array, fk, ylabel=\"non-ergodicity parameter\", xlabel=\"k\")","category":"page"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"(Image: image)","category":"page"},{"location":"Scope.html#Relaxation-time","page":"Scope","title":"Relaxation time","text":"","category":"section"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"Relaxation times can be easily extracted from dynamical data using the find_relaxation_time(t, F; threshold=exp(-1), mode=:log) function.","category":"page"},{"location":"Scope.html#Example-4","page":"Scope","title":"Example","text":"","category":"section"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"Let's solve mode-coupling theory to get some data:","category":"page"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"# We solve MCT for hard spheres at a volume fraction of 0.51591\nη = 0.51591; ρ = η*6/π; kBT = 1.0; m = 1.0\n\nNk = 100; kmax = 40.0; dk = kmax/Nk; k_array = dk*(collect(1:Nk) .- 0.5)\nSₖ = find_analytical_S_k(k_array, η)\n\n∂F0 = zeros(Nk); α = 1.0; β = 0.0; γ = @. k_array^2*kBT/(m*Sₖ)\n\nkernel = ModeCouplingKernel(ρ, kBT, m, k_array, Sₖ)\nproblem = LinearMCTEquation(α, β, γ, Sₖ, ∂F0, kernel)\nsolver = FuchsSolver(Δt=10^-5, t_max=10.0^15, verbose=false, \n                     N = 8, tolerance=10^-8)\nsol = @time solve(problem, solver);","category":"page"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"We can now extract a single relaxation time by calling ","category":"page"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"julia> find_relaxation_time(sol.t, sol[18]) # at k k_array[18]\n4.232796654132995e11","category":"page"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"To extract all relaxation times as a function of k:","category":"page"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"julia> t_R = [find_relaxation_time(t, F[ik, :]) for ik in eachindex(k_array)]; \njulia> p = plot(k_array, log10.(t_R), xlabel=\"k\", ylabel=\"log10(relaxation time)\", legend=false)","category":"page"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"(Image: image)","category":"page"},{"location":"Problems_and_Solvers.html#Equations","page":"Problems and Solvers","title":"Equations","text":"","category":"section"},{"location":"Problems_and_Solvers.html","page":"Problems and Solvers","title":"Problems and Solvers","text":"The most straightforward workflow for solving MCT-like equations is to first construct a MemoryKernel, a MCTEquation, and optionally a Solver, in that order. The MemoryKernel is an object that evaluates the memory kernel when passed to the function evaluate_kernel. The MCTEquation holds the coefficients, initial conditions, and the just defined MemoryKernel belonging to the equation that need to be solved, and the Solver stores information related to the numerical integration procedure, such as the time step. Once these three objects have been defined, the function solve(::MCTEquation, ::Solver) can be called on them to solve the equation","category":"page"},{"location":"Problems_and_Solvers.html","page":"Problems and Solvers","title":"Problems and Solvers","text":"alpha ddotF(t) + beta dotF(t) + gamma F(t) + int_0^t dtau K(t-tau)dotF(tau) = 0","category":"page"},{"location":"Problems_and_Solvers.html","page":"Problems and Solvers","title":"Problems and Solvers","text":"A LinearMCTEquation defined by the equation above is constructed by the constructor LinearMCTEquation(α, β, γ, F₀, ∂ₜF₀, kernel::MemoryKernel). Here, F₀ and ∂ₜF₀ are the initial conditions of F and its time derivative. In the case of vector-valued functions F, this package requires that the operation α*F is defined and returns the same type as F. This means that in general, when F is a vector, α must either be a matrix with a compatible element type, or a scalar. However, because it is common in practice to find equations in which α and F are both vectors (such that the multiplication α*F is understood to be conducted element-wise), vector-valued αs will automatically be promoted to diagonal matrices. β and γ are treated in the same way. LinearMCTEquation will also evaluate the kernel at t=0 to find its initial condition.","category":"page"},{"location":"Problems_and_Solvers.html#Examples","page":"Problems and Solvers","title":"Examples","text":"","category":"section"},{"location":"Problems_and_Solvers.html","page":"Problems and Solvers","title":"Problems and Solvers","text":"Scalar problems are the most straightforward:","category":"page"},{"location":"Problems_and_Solvers.html","page":"Problems and Solvers","title":"Problems and Solvers","text":"kernel = SchematicF1Kernel(0.2); # in the next page of the documentation we will \n                                 # explain how to construct memory kernels\nα = 1.0; β = 0.0; γ = 1.0; F0 = 1.0; ∂F0 = 0.0;\nproblem = LinearMCTEquation(α, β, γ, F0, ∂F0, kernel)","category":"page"},{"location":"Problems_and_Solvers.html","page":"Problems and Solvers","title":"Problems and Solvers","text":"For vector-valued problems, the coefficients can be scalar, vector or matrix-valued. They are automatically promoted to make linear algebra work:","category":"page"},{"location":"Problems_and_Solvers.html","page":"Problems and Solvers","title":"Problems and Solvers","text":"julia> N = 5;\njulia> kernel = SchematicDiagonalKernel(rand(N));\njulia> α = 1.0; β = rand(N); γ = rand(N,N); F0 = ones(N); ∂F0 = zeros(N);\njulia> problem = LinearMCTEquation(α, β, γ, F0, ∂F0, kernel);\n\njulia> problem.α\nLinearAlgebra.UniformScaling{Float64}\n1.0*I\n\njulia> problem.β\n5×5 LinearAlgebra.Diagonal{Float64, Vector{Float64}}:\n 0.789182   ⋅         ⋅        ⋅         ⋅\n  ⋅        0.379832   ⋅        ⋅         ⋅\n  ⋅         ⋅        0.50589   ⋅         ⋅\n  ⋅         ⋅         ⋅       0.241663   ⋅\n  ⋅         ⋅         ⋅        ⋅        0.857202\n\njulia> problem.γ\n5×5 Matrix{Float64}:\n 0.746936  0.963531  0.724356  0.31979   0.600617\n 0.731198  0.217209  0.603705  0.373079  0.930195\n 0.464137  0.670576  0.973505  0.23666   0.536108\n 0.40188   0.797017  0.332496  0.841541  0.434256\n 0.401826  0.303485  0.238624  0.239107  0.453554","category":"page"},{"location":"Problems_and_Solvers.html#Limitations","page":"Problems and Solvers","title":"Limitations","text":"","category":"section"},{"location":"Problems_and_Solvers.html","page":"Problems and Solvers","title":"Problems and Solvers","text":"This package is not tested for and is not expected to work when the type of F is something other than a Number, Vector or SVector. For example, using types like OffsetArrays as initial conditions might lead to unexpected behaviour.","category":"page"},{"location":"Problems_and_Solvers.html#Solvers","page":"Problems and Solvers","title":"Solvers","text":"","category":"section"},{"location":"Problems_and_Solvers.html","page":"Problems and Solvers","title":"Problems and Solvers","text":"A Solver object holds the settings for a specific integration method. This package defines two solvers: EulerSolver and FuchsSolver. The EulerSolver implements a simple forward Euler method (with trapezoidal integration) which is wildly inefficient if the domain of t spans many orders of magnitude (such as it often does in Mode-Coupling Theory). It should therefore mainly be used for testing purposes. The FuchsSolver should be used in almost all other cases. The scheme it implements is outlined in [1] and in the appendix of [2]. If no solver is provided to a solve call, the default FuchsSolver is used.","category":"page"},{"location":"Problems_and_Solvers.html","page":"Problems and Solvers","title":"Problems and Solvers","text":"In short, the equation is discretised and solved on a grid of 4N time-points, which are equally spaced over an interval Δt. It is solved using an implicit method, and thus a fixed point has to be found for each time point. This is done by recursive iteration. When the solution is found, the interval is doubled Δt => 2Δt and the solution on the previous grid is mapped onto the first 2N time points of the new grid. The solution on the other2N points is again found by recursive iteration. This is repeated until some final time t_max is reached.","category":"page"},{"location":"Problems_and_Solvers.html","page":"Problems and Solvers","title":"Problems and Solvers","text":"A FuchsSolver is constructed as follows:","category":"page"},{"location":"Problems_and_Solvers.html","page":"Problems and Solvers","title":"Problems and Solvers","text":"julia> kernel = SchematicF1Kernel(0.2);\njulia> α = 1.0; β = 0.0; γ = 1.0; F0 = 1.0; ∂F0 = 0.0;\njulia> problem = LinearMCTEquation(α, β, γ, F0, ∂F0, kernel);\njulia> solver1 = FuchsSolver() # using all default parameters\njulia> solver2 = FuchsSolver(N=128, Δt=10^-5, \n                            t_max=10.0^15, max_iterations=10^8, \n                            tolerance=10^-6, verbose=true)","category":"page"},{"location":"Problems_and_Solvers.html","page":"Problems and Solvers","title":"Problems and Solvers","text":"As optional keyword arguments FuchsSolver accepts:","category":"page"},{"location":"Problems_and_Solvers.html","page":"Problems and Solvers","title":"Problems and Solvers","text":"N: The number of time points in the interval is equal to 4N. default = 32\nt_max: when this time value is reached, the integration returns. default = 10.0^10\nΔt: starting time interval, this will be doubled repeatedly. default = 10^-10\nmax_iterations: the maximal number of iterations before convergence is reached for each time doubling step. default = 10^4\ntolerance: while the error of the recursive iteration is bigger than this value, convergence is not reached. The error by default is computed as the absolute sum of squared differences. default = 10^-10\nverbose: if true, some information will be printed. default = false\ninplace: if true and if the type of F is mutable, the solver will try to avoid allocating many temporaries. default = true","category":"page"},{"location":"Problems_and_Solvers.html","page":"Problems and Solvers","title":"Problems and Solvers","text":"Having defined a MemoryKernel, MCTEquation and a Solver, one can call t, F, K = solve(problem, solver) to solve the problem. It outputs a Vector of time points t and the solution F and memory kernel K evaluated at those times points. ","category":"page"},{"location":"Problems_and_Solvers.html#References","page":"Problems and Solvers","title":"References","text":"","category":"section"},{"location":"Problems_and_Solvers.html","page":"Problems and Solvers","title":"Problems and Solvers","text":"[1] Fuchs, Matthias, et al. \"Comments on the alpha-peak shapes for relaxation in supercooled liquids.\" Journal of Physics: Condensed Matter 3.26 (1991): 5047.","category":"page"},{"location":"Problems_and_Solvers.html","page":"Problems and Solvers","title":"Problems and Solvers","text":"[2] Flenner, Elijah, and Grzegorz Szamel. \"Relaxation in a glassy binary mixture: Comparison of the mode-coupling theory to a Brownian dynamics simulation.\" Physical Review E 72.3 (2005): 031508.","category":"page"},{"location":"FromPython.html#Calling-from-Python","page":"From Python","title":"Calling from Python","text":"","category":"section"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"Using ModeCouplingTheory from Python can be useful for solving mode-coupling theory repeatedly or for large systems of equations, making the overhead of initializing Julia negligible. (Or perhaps if one prefers to work in Python.)","category":"page"},{"location":"FromPython.html#Installing","page":"From Python","title":"Installing","text":"","category":"section"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"First, install julia through the pip package manager, with","category":"page"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"% pip install julia","category":"page"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"Using ipython3 (only Python geq 3 is supported), do:","category":"page"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"from julia import Main","category":"page"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"which will install the latest stable version of Julia the first time it is called. Now install ModeCouplingTheory.jl, with","category":"page"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"from julia import Pkg\nPkg.add(\"ModeCouplingTheory\")","category":"page"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"To import this package in order to use it we need to run:","category":"page"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"from julia import ModeCouplingTheory as mct","category":"page"},{"location":"FromPython.html#Usage","page":"From Python","title":"Usage","text":"","category":"section"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"And now we can use ModeCouplingTheory.jl in Python:","category":"page"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"# since Python doesn't like all unicode symbols (α, β, ∂, ...), we use standard letters:\nk = 3.99999\na = 1.0\nb = 0.0\nc = 1.0\nF0 = 1.0\ndF0 = 0.0\nkernel = mct.SchematicF2Kernel(k)\nproblem = mct.LinearMCTEquation(a, b, c, F0, dF0, kernel)\nsol = mct.solve(problem)\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nplt.plot(np.log10(sol.t), sol.F)\nplt.show()","category":"page"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"et voilà!","category":"page"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"(Image: image)","category":"page"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"See the documentation of pyjulia for more information on how to call julia from python.","category":"page"},{"location":"index.html#ModeCouplingTheory.jl","page":"Introduction","title":"ModeCouplingTheory.jl","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"This package provides a generic and fast solver of mode-coupling theory-like integrodifferential equations. It uses the algorithm outlined in Fuchs et al. to solve equations of the form","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"alpha ddotF(t) + beta dotF(t) + gamma F(t) + int_0^t dtau K(t-tau)dotF(tau) = 0","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"in which alpha, beta, and gamma are coefficients, and K(t) = K(F(t) t). This package exports some commonly used memory kernels, but it is straightforward to define your own. The solver is differentiable and works for scalar- and vector-valued functions F(t). ","category":"page"},{"location":"index.html#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"To install the package run:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"import Pkg\nPkg.add(\"ModeCouplingTheory\")","category":"page"},{"location":"index.html#Example","page":"Introduction","title":"Example","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"We can define one of the predefined memory kernels ","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"julia> using ModeCouplingTheory\njulia> λ = 3.999\n3.999\njulia> kernel = SchematicF2Kernel(λ)\nSchematicF2Kernel{Float64}(3.999)","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"This kernel evaluates K(t)=lambda F(t)^2.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"We can now define the equation we want to solve as follows:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"julia> α = 1.0; β = 0.0; γ = 2.0; F0 = 1.0; ∂F0 = 0.0;\njulia> problem = LinearMCTEquation(α, β, γ, F0, ∂F0, kernel)\nLinearMCTEquation{Float64, Float64, Float64, Float64, Float64}(1.0, 0.0, 2.0, 1.0, 0.0, 3.999, Float64, Float64, Float64)","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"and a solver:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"julia> solver = FuchsSolver(problem)","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Now we can solve the equation by calling solve:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"julia> using Plots\njulia> sol = solve(problem, solver);\njulia> plot(log10.(sol.t), sol.F)","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"(Image: image)","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Full copy-pastable example:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"using ModeCouplingTheory, Plots\nν = 3.999\nα = 1.0; β = 0.0; γ = 1.0; F0 = 1.0; ∂F0 = 0.0;\nkernel = SchematicF2Kernel(ν)\nproblem = LinearMCTEquation(α, β, γ, F0, ∂F0, kernel)\nsolver = FuchsSolver(problem)\nsol = solve(problem, solver);\nplot(log10.(sol.t), sol.F)","category":"page"},{"location":"internals.html#Overview-of-the-internals-of-ModeCouplingTheory.jl","page":"Internals","title":"Overview of the internals of ModeCouplingTheory.jl","text":"","category":"section"},{"location":"internals.html","page":"Internals","title":"Internals","text":"In order to be able to solve an \"MCT-like\" equation, one must construct an instance of an MCTEquation, and optionally a Solver. Every MCTEquation also needs a MemoryKernel in order to define the equation to be solved. These three are all abstract types such that extending this package to include functionality for different equations or different types of memory kernels is easy. For example, subtypes of MemoryKernel include SchematicF1Kernel and ModeCouplingKernel. Examples of Solvers are EulerSolver and FuchsSolver. At this point, the only concrete MCTEquation is a LinearMCTEquation, which implements the equation mentioned in the Introduction. ","category":"page"},{"location":"internals.html","page":"Internals","title":"Internals","text":"When concrete instances of a an MCTEquation, and a Solver have been defined by the user, the function solve(problem::MCTEquation, solver::Solver) is called to solve the equation defined by problem, with the memory kernel kernel using the solver solver. ","category":"page"},{"location":"internals.html","page":"Internals","title":"Internals","text":"Thus, in order to extend the functionality of this package to solve an equation of a different form, say:","category":"page"},{"location":"internals.html","page":"Internals","title":"Internals","text":"dotF(t) + a F(t)^p + int_0^tdtau K(tau)dotF(t-tau) = 0","category":"page"},{"location":"internals.html","page":"Internals","title":"Internals","text":"one needs to define ","category":"page"},{"location":"internals.html","page":"Internals","title":"Internals","text":"a new type of MCTEquation (e.g. AnharmonicMCTEquation <: MCTEquation) which stores the coefficients a, p and initial conditions.\noptionally a new Solver (e.g. AnharmonicSolver <: Solver) type, which stores some solver settings, such as timesteps and tolerances. In the case that the solution method is very similar to one that is already implemented, (such as it is in this case), it might be possible to use the already defined solvers such as FuchsSolver, only extending a few methods, see below. \na new solve method that dispatches on the above types to solve this equation with the right method (e.g. one needs to write the method solve(problem::AnharmonicMCTEquation, solver::AnharmonicSolver)). However, in the case that e.g. FuchsSolver can be reused, instead of a new solve method, one can also create new methods for lower-level function that solve(problem::AnharmonicMCTEquation, solver::FuchsSolver) calls, specializing for AnharmonicMCTEquation, in order to implement the changes necessary to solve this AnharmonicMCTEquation.","category":"page"},{"location":"internals.html","page":"Internals","title":"Internals","text":"The newly defined methods for this new equation should then work with any of the defined memory kernels. In summary, the real functionality of this package is implemented by the solve function. The memory kernel, solvers and problem types are used in order to specialize solve calls.","category":"page"},{"location":"internals.html#Internals-of-the-Fuchs-Solver","page":"Internals","title":"Internals of the Fuchs Solver","text":"","category":"section"},{"location":"internals.html","page":"Internals","title":"Internals","text":"The basic idea of the algorithm popularizd by Fuchs and coworkers was, that, in order to solve the equations over many orders of magnitude in time, it is helpful to periodically increase the time step of the grid on which the equation is solved. Below we give a more detailed overview of the implementation of the algorithm in this package.","category":"page"},{"location":"internals.html","page":"Internals","title":"Internals","text":"The equations are solved using these steps:","category":"page"},{"location":"internals.html","page":"Internals","title":"Internals","text":"allocate_temporary_arrays(problem::MCTEquation, solver::FuchsSolver) returns a FuchsTempStruct that is used internally to avoid unnecessary allocations.\ninitialize_temporary_arrays!(problem::MCTEquation, solver::FuchsSolver, kernel::MemoryKernel, temp_arrays::FuchsTempStruct): The algorithm is started by initializing temporary variables such as F and K discretised on the time grid of 4N points on t_i = iDelta t4N where i = 1ldots4N. F(t) is solved by a forward Euler method on the first 2N points to kickstart the algorithm. The effects of the memory integral is neglected here. \ndo_time_steps!(problem::MCTEquation, solver::FuchsSolver, kernel::MemoryKernel, temp_arrays::FuchsTempStruct): The full equation is discretised on the time points between i=2N+1 and i=4N. For each of these time points, the parameters C_1, C_2, and C_3 are calculated by update_Fuchs_parameters!(problem, solver, temp_arrays, i) as prescribed in the literature. Now, in order to solve for F(t_i), the fixed point of the mapping C_1 F  = -C_2 K(F) + C_3 is found by recurstive iteration. Convergence is established if the maximimal squared error is smaller than a set tolerance.\nallocate_results!(t_array, F_array, K_array, solver, temp_arrays::FuchsTempStruct) the results found by step 2, residing in temporary arrays are pushed to t_array, F_array, and K_array, which are returned when the program exits.\nnew_time_mapping!(problem, solver, temp_arrays::FuchsTempStruct): the results stored in the temporary variables temp_arrays.F_temp, temp_arrays.K_temp, temp_arrays.I_F, temp_arrays.I_K are mapped from the time points i=1ldots4N to the points i=1ldots2N as prescribed in the literature. The time step Delta t is also doubled.\nIf Δt > t_max the main loop exits and a solution object containing t_array, F_array, K_array, and the solver settings is returned. ","category":"page"},{"location":"internals.html","page":"Internals","title":"Internals","text":"For information on specific methods, see the next page of the documentation.","category":"page"},{"location":"API.html#Module-Index","page":"API Reference","title":"Module Index","text":"","category":"section"},{"location":"API.html","page":"API Reference","title":"API Reference","text":"Modules = [ModeCouplingTheory]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"API.html#Detailed-API","page":"API Reference","title":"Detailed API","text":"","category":"section"},{"location":"API.html","page":"API Reference","title":"API Reference","text":"Modules = [ModeCouplingTheory]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"API.html#ModeCouplingTheory.EulerSolver-Tuple{}","page":"API Reference","title":"ModeCouplingTheory.EulerSolver","text":"EulerSolver(equation::LinearMCTEquation; t_max=10.0^2, Δt=10^-3, verbose=false)\n\nConstructs a solver object that, when called solve upon will solve an LinearMCTEquation using a forward Euler method. It will discretise the integral using a Trapezoidal rule. Use this solver only for testing purposes. It is a wildy  inefficient way to solve MCT-like equations.\n\nArguments:\n\nequation an instance of LinearMCTEquation\nt_max when this time value is reached, the integration returns\nΔt fixed time step\nverbose if true, information will be printed to STDOUT\n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.ExponentiallyDecayingKernel","page":"API Reference","title":"ModeCouplingTheory.ExponentiallyDecayingKernel","text":"ExponentiallyDecayingKernel{T<:Number} <: MemoryKernel\n\nScalar kernel with fields ν and τ which when called returns ν exp(-t/τ).\n\n\n\n\n\n","category":"type"},{"location":"API.html#ModeCouplingTheory.FuchsSolver-Tuple{}","page":"API Reference","title":"ModeCouplingTheory.FuchsSolver","text":"FuchsSolver(N=32, Δt=10^-10, t_max=10.0^10, max_iterations=10^4, tolerance=10^-10, verbose=false, ismutable=true)\n\nUses the algorithm devised by Fuchs et al.\n\nArguments:\n\nequation: an instance of LinearMCTEquation\nN: The number of time points in the interval is equal to 4N\nt_max: when this time value is reached, the integration returns\nΔt: starting time step, this will be doubled repeatedly\nmax_iterations: the maximal number of iterations before convergence is reached for each time doubling step\ntolerance: while the error is bigger than this value, convergence is not reached. The error by default is computed as the absolute sum of squares\nverbose: if true, information will be printed to STDOUT\nismutable: if true and if the type of F is mutable, the solver will try to avoid allocating many temporaries\n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.InterpolatingKernel-Tuple{Any, Any}","page":"API Reference","title":"ModeCouplingTheory.InterpolatingKernel","text":"InterpolatingKernel(t, M; k=1)\n\nUses the package Dierckx to provide a kernel that interpolates the data M defined on grid t using spline interpolation of degree k. \n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.LinearMCTEquation-Tuple{Any, Any, Any, Any, Any, MemoryKernel}","page":"API Reference","title":"ModeCouplingTheory.LinearMCTEquation","text":"LinearMCTEquation(α, β, γ, F₀::T, ∂ₜF₀::T, kernel::MemoryKernel) where T\n\nArguments:\n\nα: coefficient in front of the second derivative term. If α and F₀ are both vectors, α will automatically be converted to a diagonal matrix, to make them compatible.\nβ: coefficient in front of the first derivative term. If β and F₀ are both vectors, β will automatically be converted to a diagonal matrix, to make them compatible.\nγ: coefficient in front of the second derivative term. If γ and F₀ are both vectors, γ will automatically be converted to a diagonal matrix, to make them compatible.\nF₀: initial condition of F(t)\n∂ₜF₀ initial condition of the derivative of F(t)\nkernel instance of a MemoryKernel that when called on F₀ and t=0, evaluates to the initial condition of the memory kernel.\n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.MCTSolution","page":"API Reference","title":"ModeCouplingTheory.MCTSolution","text":"MCTSolution\n\nsolution object that holds the solution of an MCTEquation. It has 4 fields     t: array of t values     F: array of F for all t     K: array of K for all T     solver: solver object that holds the solver settings\n\nan MCT object can be indexed such that      sol=MCTSolution     sol[2]   gives the F[2] for all t.\n\n\n\n\n\n","category":"type"},{"location":"API.html#ModeCouplingTheory.ModeCouplingKernel-NTuple{5, Any}","page":"API Reference","title":"ModeCouplingTheory.ModeCouplingKernel","text":"ModeCouplingKernel(ρ, kBT, m, k_array, Sₖ)\n\nConstructor of a ModeCouplingKernel. It implements the kernel K(k,t) = ρ kBT / (16π^3m) ∫dq V^2(k,q) F(q,t) F(k-q,t) in which k and q are vectors. \n\nArguments:\n\nρ: number density\nkBT: Thermal energy\nm : particle mass\nk_array: vector of wavenumbers at which the structure factor is known\nSₖ: structure factor\n\nReturns:\n\nan instance k of ModeCouplingKernel <: MemoryKernel, which can be called both in-place and out-of-place: k(out, F, t) out = k(F, t)\n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.MultiComponentModeCouplingKernel-NTuple{5, Any}","page":"API Reference","title":"ModeCouplingTheory.MultiComponentModeCouplingKernel","text":"MultiComponentModeCouplingKernel(ρ, kBT, m, k_array, Sₖ)\n\nConstructor of a MultiComponentModeCouplingKernel. It implements the kernel Kαβ(k,t) = ρ  / (2 xα xβ (2π)³) Σμνμ'ν' ∫dq Vμ'ν'(k,q) Fμμ'(q,t) Fνν'(k-q,t) Vμν(k,q) in which k and q are vectors and α and β species labels. \n\nArguments:\n\nρ: vector of number densities for each species\nkBT: Thermal energy\nm : vector of particle masses for each species\nk_array: vector of wavenumbers at which the structure factor is known\nSₖ: a Vector of Nk SMatrixs containing the structure factor of each component at each wave number\n\nReturns:\n\nan instance k of ModeCouplingKernel <: MemoryKernel, which can be called both in-place and out-of-place: k = MultiComponentModeCouplingKernel(ρ, kBT, m, k_array, Sₖ) out = k(F, t) k(out, F, t)\n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.SchematicDiagonalKernel","page":"API Reference","title":"ModeCouplingTheory.SchematicDiagonalKernel","text":"SchematicDiagonalKernel{T<:Union{SVector, Vector}} <: MemoryKernel\n\nMatrix kernel with field ν which when called returns Diagonal(ν .* F .^ 2), i.e., it implements a non-coupled system of SchematicF2Kernels.\n\n\n\n\n\n","category":"type"},{"location":"API.html#ModeCouplingTheory.SchematicF123Kernel","page":"API Reference","title":"ModeCouplingTheory.SchematicF123Kernel","text":"SchematicF1Kernel{T<:Number} <: MemoryKernel\n\nScalar kernel with fields ν1, ν2, and ν3 which when called returns ν1 * F^1 + ν2 * F^2 + ν3 * F^3.\n\n\n\n\n\n","category":"type"},{"location":"API.html#ModeCouplingTheory.SchematicF1Kernel","page":"API Reference","title":"ModeCouplingTheory.SchematicF1Kernel","text":"SchematicF1Kernel{T<:Number} <: MemoryKernel\n\nScalar kernel with field ν which when called returns ν F.\n\n\n\n\n\n","category":"type"},{"location":"API.html#ModeCouplingTheory.SchematicF2Kernel","page":"API Reference","title":"ModeCouplingTheory.SchematicF2Kernel","text":"SchematicF2Kernel{T<:Number} <: MemoryKernel\n\nScalar kernel with field ν which when called returns ν F^2.\n\n\n\n\n\n","category":"type"},{"location":"API.html#ModeCouplingTheory.SchematicMatrixKernel","page":"API Reference","title":"ModeCouplingTheory.SchematicMatrixKernel","text":"SchematicMatrixKernel{T<:Union{SVector, Vector}} <: MemoryKernel\n\nMatrix kernel with field ν which when called returns ν * F * Fᵀ, i.e., it implements Kαβ = νFαFβ.\n\n\n\n\n\n","category":"type"},{"location":"API.html#ModeCouplingTheory.SjogrenKernel","page":"API Reference","title":"ModeCouplingTheory.SjogrenKernel","text":"SjogrenKernel\n\nMemory kernel that implements the kernel K[1] = ν1 F[1]^2, K[2] = ν2 F[1] F[2]. Consider using Static Vectors for performance. \n\n\n\n\n\n","category":"type"},{"location":"API.html#ModeCouplingTheory.TaggedModeCouplingKernel-NTuple{6, Any}","page":"API Reference","title":"ModeCouplingTheory.TaggedModeCouplingKernel","text":"TaggedModeCouplingKernel(ρ, kBT, m, k_array, Sₖ)\n\nConstructor of a Tagged ModeCouplingKernel. It implements the kernel K(k,t) = ρ kBT / (8π^2m) ∫dq V^2(k,q) F(q,t) Fs(k-q,t) in which k and q are vectors. \n\nArguments:\n\nρ: number density\nkBT: Thermal energy\nm : particle mass\nk_array: vector of wavenumbers at which the structure factor is known\n\nReturns:\n\nan instance k of TaggedModeCouplingKernel <: MemoryKernel, which can be called both in-place and out-of-place: k(out, F, t) out = k(F, t)\n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.TaggedSchematicF2Kernel","page":"API Reference","title":"ModeCouplingTheory.TaggedSchematicF2Kernel","text":"SchematicF2Kernel{T<:Number} <: MemoryKernel\n\nScalar tagged particle kernel with field ν which when called returns ν F*Fs.\n\n\n\n\n\n","category":"type"},{"location":"API.html#ModeCouplingTheory.allocate_results!-Tuple{Any, Any, Any, FuchsSolver, Any}","page":"API Reference","title":"ModeCouplingTheory.allocate_results!","text":"allocate_results!(t_array, F_array, K_array, solver::FuchsSolver, temp_arrays::FuchsTempStruct; istart=2(solver.N)+1, iend=4(solver.N))\n\npushes the found solution, stored in temp_arrays with indices istart until istop to the output arrays.\n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.allocate_temporary_arrays-Tuple{MCTEquation, FuchsSolver}","page":"API Reference","title":"ModeCouplingTheory.allocate_temporary_arrays","text":"allocate_temporary_arrays(equation::MCTEquation, solver::FuchsSolver)\n\nReturns a FuchsTempStruct containing several arrays that are used for intermediate calculations.\n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.convertresults-Union{Tuple{T}, Tuple{T2}, Tuple{Vector{T}, Array{LinearAlgebra.Diagonal{T, T2}, 1}}} where {T2, T}","page":"API Reference","title":"ModeCouplingTheory.convertresults","text":"convertresults(F_array::Vector{T}, K_array::Vector{Diagonal{T, T2}}) where {T2, T}\n\nconverts the arrays of arrays into multidimensional arrays for ease of use.\n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.do_time_steps!-Tuple{MCTEquation, FuchsSolver, MemoryKernel, ModeCouplingTheory.FuchsTempStruct}","page":"API Reference","title":"ModeCouplingTheory.do_time_steps!","text":"do_time_steps!(equation::LinearMCTEquation, solver::FuchsSolver, kernel::MemoryKernel, temp_arrays::FuchsTempStruct)\n\nSolves the equation on the time points with index 2N+1 until 4N, for each point doing a recursive iteration to find the solution to the nonlinear equation C1 F  = -C2 M(F) + C3.\n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.evaluate_kernel!-Tuple{Any, MemoryKernel, Any, Any}","page":"API Reference","title":"ModeCouplingTheory.evaluate_kernel!","text":"evaluate_kernel!(out, kernel::MemoryKernel, F, t)\n\nEvaluates the memory kernel in-place, overwriting the elements of the out variable. It may mutate the content of kernel.\n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.evaluate_kernel-Tuple{MemoryKernel, Any, Any}","page":"API Reference","title":"ModeCouplingTheory.evaluate_kernel","text":"evaluate_kernel(kernel::MemoryKernel, F, t)\n\nEvaluates the memory kernel out-place. It may mutate the content of kernel.\n\nReturns\n\nout the kernel evaluated at (F, t)\n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.find_error-Union{Tuple{T}, Tuple{T, T}} where T","page":"API Reference","title":"ModeCouplingTheory.find_error","text":"find_error(F_new::T, F_old::T) where T\n\nFinds the error between a new and old iteration of F. The returned scalar will be compared  to the tolerance to establish convergence. \n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.find_relaxation_time-Tuple{Any, Vector{<:Number}}","page":"API Reference","title":"ModeCouplingTheory.find_relaxation_time","text":"find_relaxation_time(t, F; threshold=exp(-1), mode=:log)\n\nFinds the time at which a signal first decreases below some threshold. Uses interpolation to find an accurate result. if it never decreases below the threshold, returns Inf.\n\nArguments:\n\nt: a vector of time values at which the signal F is known\nF: the signal\nthreshold: see above\nmode: uses interpolation either in a logarithmic or linear space. \n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.initialize_F_temp!-Tuple{LinearMCTEquation, FuchsSolver, ModeCouplingTheory.FuchsTempStruct}","page":"API Reference","title":"ModeCouplingTheory.initialize_F_temp!","text":"initialize_F_temp!(equation::MCTEquation, solver::FuchsSolver, temp_arrays::FuchsTempStruct)\n\nFills the first 2N entries of the temporary arrays of F using forward Euler without a memory kernel in order to kickstart Fuchs' scheme.\n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.initialize_K_temp!-Tuple{FuchsSolver, MemoryKernel, ModeCouplingTheory.FuchsTempStruct}","page":"API Reference","title":"ModeCouplingTheory.initialize_K_temp!","text":"initialize_K_temp!(solver::FuchsSolver, kernel::MemoryKernel, temp_arrays::FuchsTempStruct)\n\nEvaluates the memory kernel at the first 2N time points.\n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.initialize_integrals!-Tuple{MCTEquation, FuchsSolver, ModeCouplingTheory.FuchsTempStruct}","page":"API Reference","title":"ModeCouplingTheory.initialize_integrals!","text":"initialize_integrals!(equation::MCTEquation, solver::FuchsSolver, temp_arrays::FuchsTempStruct)\n\nInitializes the integrals on the first 2N time points as prescribed in the literature.\n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.initialize_output_arrays-Tuple{MCTEquation}","page":"API Reference","title":"ModeCouplingTheory.initialize_output_arrays","text":"initialize_output_arrays(equation::MCTEquation)\n\ninitializes arrays that the solver will push results into.\n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.mymul!-NTuple{5, Any}","page":"API Reference","title":"ModeCouplingTheory.mymul!","text":"\"     mymul!(c,a,b,α,β)\n\nprescribes how types used in this solver should be multiplied in place. In particular, it performs C.= βC .+ αa*b. defaults to mul!(c,a,b,α,β)\n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.new_time_mapping!-Tuple{MCTEquation, FuchsSolver, ModeCouplingTheory.FuchsTempStruct}","page":"API Reference","title":"ModeCouplingTheory.new_time_mapping!","text":"newtimemapping!(equation::MCTEquation, solver::FuchsSolver, temp_arrays::FuchsTempStruct)\n\nPerforms the time mapping central to Fuchs' algorithm with the conventions prescribed in  \"Flenner, Elijah, and Grzegorz Szamel. Physical Review E 72.3 (2005): 031508\".  Performs them inplace if solver.inplace = true in order to avoid unnecessary allocations.\n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.solve-Tuple{MCTEquation, ModeCouplingTheory.Solver}","page":"API Reference","title":"ModeCouplingTheory.solve","text":"solve(equation::MCTEquation, solver::Solver)\n\nSolves the MCTequation with the provided kernel using solver.  Search for a specific solver or kernel object to find more specific information.\n\nIf no solver is provided, it uses the default FuchsSolver. \n\nReturns:\n\nt an array of time values\nF The solution in an array of which the last dimension corresponds to the time.\nK The memory kernel corresponding to each F\n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.solve_steady_state-Tuple{Any, Any, Any}","page":"API Reference","title":"ModeCouplingTheory.solve_steady_state","text":"solve_steady_state(γ, F₀, kernel; tolerance=10^-8, max_iterations=10^6, verbose=false, inplace=true)\n\nFinds the steady-state solution (non-ergodicity parameter) of the generalized Langevin equation by recursive iteration of F = (K + γ)⁻¹ * K(F) * F₀\n\nArguments:\n\nγ: parameter in front of the linear term in F\nF₀: initial condition of F. This is also the initial condition of the rootfinding method.\nkernel: callable memory kernel\nmax_iterations: the maximal number of iterations before convergence is reached\ntolerance: while the error is bigger than this value, convergence is not reached. The error by default is computed as the absolute sum of squares between successive iterations\nverbose: if true, information will be printed to STDOUT\ninplace: if true and if the type of F is mutable, the solver will try to avoid allocating many temporaries. default =true``\n\nReturns:\n\nThe steady state solution\n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.update_F!-Tuple{FuchsSolver, ModeCouplingTheory.FuchsTempStruct, Int64}","page":"API Reference","title":"ModeCouplingTheory.update_F!","text":"update_F!(solver::FuchsSolver, temp_arrays::FuchsTempStruct, it::Int)\n\nupdates F using the formula c1F = -KC2 + C3.\n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.update_Fuchs_parameters!-Tuple{LinearMCTEquation, FuchsSolver, ModeCouplingTheory.FuchsTempStruct, Int64}","page":"API Reference","title":"ModeCouplingTheory.update_Fuchs_parameters!","text":"update_Fuchs_parameters!(equation::LinearMCTEquation, solver::FuchsSolver, temp_arrays::FuchsTempStruct, it::Int)\n\nUpdates the parameters c1, c2, c3, according to the appendix of  \"Flenner, Elijah, and Grzegorz Szamel. Physical Review E 72.3 (2005): 031508\" using the naming conventions from that paper. If F is mutable (and therefore also c1,c2,c3), it will updata the variables in place, otherwise it will create new copies. This is controlled by the solver.inplace  setting.\n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.update_K!-Tuple{FuchsSolver, MemoryKernel, ModeCouplingTheory.FuchsTempStruct, Int64}","page":"API Reference","title":"ModeCouplingTheory.update_K!","text":"update_K!(solver::FuchsSolver, kernel::MemoryKernel, temp_arrays::FuchsTempStruct, it::Int)\n\nevaluates the memory kernel, updating the value in solver.temparrays.Ktemp    \n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.update_integrals!-Tuple{ModeCouplingTheory.FuchsTempStruct, Int64}","page":"API Reference","title":"ModeCouplingTheory.update_integrals!","text":"update_integrals!(solver::FuchsSolver, temp_arrays::FuchsTempStruct, it::Int)\n\nUpdate the discretisation of the integral of F and K, see the literature for details.\n\n\n\n\n\n","category":"method"}]
}
