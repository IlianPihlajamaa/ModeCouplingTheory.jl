var documenterSearchIndex = {"docs":
[{"location":"anotherPage.html#Module-Index","page":"An other page","title":"Module Index","text":"","category":"section"},{"location":"anotherPage.html","page":"An other page","title":"An other page","text":"Modules = [ModeCouplingTheory]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"anotherPage.html#Detailed-API","page":"An other page","title":"Detailed API","text":"","category":"section"},{"location":"anotherPage.html","page":"An other page","title":"An other page","text":"Modules = [ModeCouplingTheory]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"anotherPage.html#ModeCouplingTheory.EulerSolver-Tuple{MCTProblem}","page":"An other page","title":"ModeCouplingTheory.EulerSolver","text":"EulerSolver(problem::MCTProblem; t_max=10.0^2, Δt=10^-3, verbose=false)\n\nConstructs a solver object that, when called solve upon will solve an MCTProblem using a forward Euler method. It will discretise the integral using a Trapezoidal rule.\n\narguments:\n\n`problem` an instance of MCTProblem\n`t_max` when this time value is reached, the integration returns\n`Δt` fixed time step\n`verbosity` if `true`, information will be printed to STDOUT\n\nreturns\n\n`t` an array of time values\n`F` The solution in an array of which the last dimension corresponds to the time.\n`K` The memory kernel corresponding to each `F`\n\n\n\n\n\n","category":"method"},{"location":"anotherPage.html#ModeCouplingTheory.ExponentiallyDecayingKernel","page":"An other page","title":"ModeCouplingTheory.ExponentiallyDecayingKernel","text":"ExponentiallyDecayingKernel{T<:Number} <: MemoryKernel\n\nScalar kernel with fields λ and τ which when called returns λ exp(-t/τ).\n\n\n\n\n\n","category":"type"},{"location":"anotherPage.html#ModeCouplingTheory.FuchsSolver-Tuple{MCTProblem}","page":"An other page","title":"ModeCouplingTheory.FuchsSolver","text":"FuchsSolver(problem; N=32, Δt=10^-10, t_max=10.0^10, max_iterations=10^4, tolerance=10^-10, verbose=false)\n\nUses the algorithm devised by Fuchs et al. to solve the MCTProblem.\n\narguments:\n\n`problem` an instance of MCTProblem\n`t_max` when this time value is reached, the integration returns\n`Δt` starting time step, this will be doubled repeatedly\n`max_iterations` the maximal number of iterations before convergence is reached for each time doubling step\n`tolerance` while the error is bigger than this value, convergence is not reached. The error by default is computed as the absolute sum of squares\n`verbosity` if `true`, information will be printed to STDOUT\n\n    # returns \n`t` an array of time values\n`F` The solution in an array of which the last dimension corresponds to the time.\n`K` The memory kernel corresponding to each `F`\n\n\n\n\n\n","category":"method"},{"location":"anotherPage.html#ModeCouplingTheory.ModeCouplingKernel-NTuple{5, Any}","page":"An other page","title":"ModeCouplingTheory.ModeCouplingKernel","text":"ModeCouplingKernel(ρ, kBT, m, k_array, Sₖ)\n\nConstructor of a ModeCouplingKernel. It implements the kernel K(k,t) = ρ kBT / (16π^3m) ∫dq V^2(k,q) F(q,t) F(k-q,t) in which k and q are vectors. \n\narguments:\n\nρ: number density kBT: Thermal energy m : particle mass k_array: vector of wavenumbers at which the structure factor is known Sₖ: structure factor\n\nreturns:\n\nan instance k of ModeCouplingKernel <: MemoryKernel, which can be called both in-place and out-of-place: k(out, F, t) out = k(F, t)\n\n\n\n\n\n","category":"method"},{"location":"anotherPage.html#ModeCouplingTheory.MultiComponentModeCouplingKernel-NTuple{5, Any}","page":"An other page","title":"ModeCouplingTheory.MultiComponentModeCouplingKernel","text":"MultiComponentModeCouplingKernel(ρ, kBT, m, k_array, Sₖ)\n\nConstructor of a MultiComponentModeCouplingKernel. It implements the kernel Kαβ(k,t) = ρ  / (2 xα xβ (2π)³) Σμνμ'ν' ∫dq Vμ'ν'(k,q) Fμμ'(q,t) Fνν'(k-q,t) Vμν(k,q) in which k and q are vectors and α and β species labels. \n\narguments:\n\nρ: vector of number densities for each species kBT: Thermal energy m : vector of particle masses for each species k_array: vector of wavenumbers at which the structure factor is known Sₖ: a Vector of Nk SMatrixs containing the structure factor of each component at each wave number\n\nreturns:\n\nan instance k of ModeCouplingKernel <: MemoryKernel, which can be called both in-place and out-of-place: k = MultiComponentModeCouplingKernel(ρ, kBT, m, k_array, Sₖ) out = k(F, t) k(out, F, t)\n\n\n\n\n\n","category":"method"},{"location":"anotherPage.html#ModeCouplingTheory.SchematicDiagonalKernel","page":"An other page","title":"ModeCouplingTheory.SchematicDiagonalKernel","text":"SchematicDiagonalKernel{T<:Union{SVector, Vector}} <: MemoryKernel\n\nMatrix kernel with field λ which when called returns Diagonal(λ .* F .^ 2), i.e., it implements a non-coupled system of SchematicF2Kernels.\n\n\n\n\n\n","category":"type"},{"location":"anotherPage.html#ModeCouplingTheory.SchematicF123Kernel","page":"An other page","title":"ModeCouplingTheory.SchematicF123Kernel","text":"SchematicF1Kernel{T<:Number} <: MemoryKernel\n\nScalar kernel with fields λ1, λ2, and λ3 which when called returns λ1 * F^1 + λ2 * F^2 + λ3 * F^3.\n\n\n\n\n\n","category":"type"},{"location":"anotherPage.html#ModeCouplingTheory.SchematicF1Kernel","page":"An other page","title":"ModeCouplingTheory.SchematicF1Kernel","text":"SchematicF1Kernel{T<:Number} <: MemoryKernel\n\nScalar kernel with field λ which when called returns λ F.\n\n\n\n\n\n","category":"type"},{"location":"anotherPage.html#ModeCouplingTheory.SchematicF2Kernel","page":"An other page","title":"ModeCouplingTheory.SchematicF2Kernel","text":"SchematicF2Kernel{T<:Number} <: MemoryKernel\n\nScalar kernel with field λ which when called returns λ F^2.\n\n\n\n\n\n","category":"type"},{"location":"anotherPage.html#ModeCouplingTheory.SchematicMatrixKernel","page":"An other page","title":"ModeCouplingTheory.SchematicMatrixKernel","text":"SchematicMatrixKernel{T<:Union{SVector, Vector}} <: MemoryKernel\n\nMatrix kernel with field λ which when called returns λ * F * Fᵀ, i.e., it implements Kαβ = λFαFβ.\n\n\n\n\n\n","category":"type"},{"location":"anotherPage.html#ModeCouplingTheory.find_relaxation_time-Tuple{Any, Any}","page":"An other page","title":"ModeCouplingTheory.find_relaxation_time","text":"find_relaxation_time(t, F; threshold=exp(-1), mode=:log)\n\nFinds the time at which a signal first decreases below some threshold. Uses interpolation to find an accurate result\n\narguments:\n\n`t`: a vector of time values at which the signal `F` is known\n`F`: the signal\n`threshold`: see above\n`mode`: uses interpolation either in a logarithmic or linear space.\n\n\n\n\n\n","category":"method"},{"location":"anotherPage.html#ModeCouplingTheory.solve-Tuple{MCTProblem, ModeCouplingTheory.Solver, ModeCouplingTheory.MemoryKernel}","page":"An other page","title":"ModeCouplingTheory.solve","text":"solve(problem::MCTProblem, solver::Solver, kernel::MemoryKernel)\n\nSolves the MCTproblem with the provided kernel using solver.  Search for a specific solver or kernel object to find more specific information.\n\n\n\n\n\n","category":"method"},{"location":"anotherPage.html#ModeCouplingTheory.solve_steady_state-Tuple{Any, Vector, Any}","page":"An other page","title":"ModeCouplingTheory.solve_steady_state","text":"\"     solvesteadystate(γ, F₀::Vector, kernel; tolerance=10^-8, max_iterations=10^6, verbose=false)\n\nFinds the steady-state solution (non-ergodicity parameter) of the generalized Langevin equation by recursive iteration of F = (K + γ)⁻¹ * K(F) * F₀\n\narguments:\n\n`γ` parameter in front of the linear term in F\n`F₀` initial condition of F\n`kernel` callable memory kernel\n`max_iterations` the maximal number of iterations before convergence is reached\n`tolerance` while the error is bigger than this value, convergence is not reached. The error by default is computed as the absolute sum of squares\n`verbosity` if `true`, information will be printed to STDOUT\n\nreturns:\n\nThe steady state solution\n\n\n\n\n\n","category":"method"},{"location":"index.html#ModeCouplingTheory.jl","page":"Index","title":"ModeCouplingTheory.jl","text":"","category":"section"},{"location":"index.html","page":"Index","title":"Index","text":"Documentation for ModeCouplingTheory.jl","category":"page"}]
}
