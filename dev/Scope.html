<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Scope · ModeCouplingTheory</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">ModeCouplingTheory</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Introduction</a></li><li><a class="tocitem" href="Problems_and_Solvers.html">Problems and Solvers</a></li><li><a class="tocitem" href="Kernels.html">Kernels</a></li><li class="is-active"><a class="tocitem" href="Scope.html">Scope</a><ul class="internal"><li><a class="tocitem" href="#Time-dependent-coefficients"><span>Time-dependent coefficients</span></a></li><li><a class="tocitem" href="#Automatic-differentiation"><span>Automatic differentiation</span></a></li><li><a class="tocitem" href="#Measurement-errors-and-other-number-types"><span>Measurement errors and other number types</span></a></li><li><a class="tocitem" href="#Steady-state-(non-ergodicity-parameter)"><span>Steady state (non-ergodicity parameter)</span></a></li><li><a class="tocitem" href="#Relaxation-time"><span>Relaxation time</span></a></li></ul></li><li><a class="tocitem" href="FromPython.html">From Python</a></li><li><a class="tocitem" href="internals.html">Internals</a></li><li><a class="tocitem" href="API.html">API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="Scope.html">Scope</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="Scope.html">Scope</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/IlianPihlajamaa/ModeCouplingTheory.jl/blob/main/docs/src/Scope.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="Time-dependent-coefficients"><a class="docs-heading-anchor" href="#Time-dependent-coefficients">Time-dependent coefficients</a><a id="Time-dependent-coefficients-1"></a><a class="docs-heading-anchor-permalink" href="#Time-dependent-coefficients" title="Permalink"></a></h2><p>In order to allow the coefficients <span>$\alpha$</span>, <span>$\beta$</span>, <span>$\gamma$</span>, and <span>$\delta$</span> to have a time dependence, the constructor of <code>MemoryEquation</code> allows for an optional keyword argument <code>update_coefficients!</code>, which should be a user-defined function that updates the coefficient struct given a value of <code>t</code>. Make sure, when updating the coefficients, that their type does not change. The type of the coefficients can be inspected in the <code>coeffs</code> field of a <code>MemoryEquation</code> object.</p><p>The default is that all coefficients are independent of time, that is: <code>update_coefficients! = (coeffs, t) -&gt; nothing</code>. </p><h3 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h3><p>Let&#39;s say we want the coefficient <code>γ</code> to be equal to <span>$2 + \cos(sqrt(t))$</span>, this can be achieved like this:</p><pre><code class="language-julia hljs">α=1.0, β=0.0, γ=3.0, δ=0.0; F0=1.0; dF0=0.0
kernel = SchematicF2Kernel(3.9)

function myfunc(coeffs, t)
    coeffs.γ = 2+cos(sqrt(t))
end

MemoryEquation(α, β, γ, δ, F0, ∂F0, kernel; update_coefficients! = myfunc)</code></pre><p>Alternatively, let&#39;s say we want to solve  <span>$\ddot{F} + F - t = 0$</span>, which has the analytical solution <span>$F(t) = t + \cos(t) - \sin(t)$</span></p><pre><code class="language-julia hljs">import ModeCouplingTheory: MemoryKernel, evaluate_kernel
function myfunc(coeffs, t)
    coeffs.δ = -t
end
struct ZeroKernel &lt;: MemoryKernel end
evaluate_kernel(::ZeroKernel, _, _) = 0.0
α = 1.0; β = 0.0; γ = 1.0; δ = 0.0; F0 = 1.0; dF0 = 0.0; kernel = ZeroKernel()
equation = MemoryEquation(α, β, γ, δ, F0, dF0, kernel; update_coefficients! = myfunc)
solver = TimeDoublingSolver(t_max = 10.0^3, N = 600, Δt = 10^-4)
sol = solve(equation, solver)
t = sol.t; F = sol.F
plot(log10.(t), log10.(F), lw=3)
plot!(log10.(t), log10.(t .+ cos.(t) .- sin.(t)), ls=:dash, lw=3)</code></pre><h2 id="Automatic-differentiation"><a class="docs-heading-anchor" href="#Automatic-differentiation">Automatic differentiation</a><a id="Automatic-differentiation-1"></a><a class="docs-heading-anchor-permalink" href="#Automatic-differentiation" title="Permalink"></a></h2><p>This package is compatible with forward-mode automatic differentiation. This makes it possible to calculate quatities such as <span>$\frac{dF(t)}{d\lambda}$</span> for example, where <span>$\lambda$</span> is a parameter of the memory kernel.</p><h3 id="Example-2"><a class="docs-heading-anchor" href="#Example-2">Example</a><a class="docs-heading-anchor-permalink" href="#Example-2" title="Permalink"></a></h3><p>Let&#39;s take the derivative of the solution to the generalized Langevin equation with the exponentially decaying kernel with respect to the coupling parameter. First we need to write a function that solves this equation and outputs the solution for a given coupling parameter. Since we know the analytical solution, we can compare with the derivative of that.</p><pre><code class="language-julia hljs">using ModeCouplingTheory, Plots
function my_func(λ)
    F0 = 1.0
    ∂F0 = 0.0
    α = 0.0
    β = 1.0
    γ = 1.0
    δ = 0.0
    kernel = ExponentiallyDecayingKernel(λ, 1.0)
    problem = MemoryEquation(α, β, γ, δ, F0, ∂F0, kernel)
    solver = TimeDoublingSolver(Δt=10^-4, t_max=5*10.0^1, verbose=false, N = 128, tolerance=10^-10, max_iterations=10^6)

    sol =  solve(problem, solver)
    return [sol.t[2:end], sol.F[2:end], sol.K[2:end]]
end

function exact_func(λ, t)
    temp = sqrt(λ*(λ+4)) 
    F = @. exp(-0.5* t*(temp+λ+2)) * (temp*(exp(temp*t)+1)+ λ* (exp(temp*t)-1)) / (2temp) 
    return [t, F]
end

sol = my_func(5.0)
texact, Fexact = exact_func(5.0, t)

p = plot(log10.(texact), Fexact, label=&quot;Exact&quot;, lw=4) 
scatter!(log10.(sol.t[1:100:end]), sol.F[1:100:end], label=&quot;Numerical solution&quot;, ls=:dash, lw=4) </code></pre><p><img src="images/deriv1.png" alt="image"/></p><p>Now we can take the derivative with respect to the argument of the functions we defined:</p><pre><code class="language-julia hljs">using ForwardDiff
_, dF_exact = ForwardDiff.derivative(y -&gt; exact_func(y, t), 5.0)
sol = ForwardDiff.derivative(my_func, 5.0)

p = plot(log10.(texact), dF_exact, lw=3, label=&quot;Exact&quot;, ylabel=&quot;dF/dλ(λ=5,t)&quot;, xlabel=&quot;log10(t)&quot;) 
plot!(log10.(sol.t), sol.dF, ls=:dash, lw=3, label=&quot;Numerical solution&quot;, legend=:topleft)</code></pre><p><img src="images/deriv2.png" alt="image"/></p><h2 id="Measurement-errors-and-other-number-types"><a class="docs-heading-anchor" href="#Measurement-errors-and-other-number-types">Measurement errors and other number types</a><a id="Measurement-errors-and-other-number-types-1"></a><a class="docs-heading-anchor-permalink" href="#Measurement-errors-and-other-number-types" title="Permalink"></a></h2><p>Similar to automatically evaluating derivatives, it is also possible to automatically propagate measurement errors through the entire solution process. This does however cause a serious performace loss. It works by instead of doing arithmatic with standard floating point numbers, it uses numbers with an error attached. The  <a href="https://juliaphysics.github.io/Measurements.jl/stable/">Measurements.jl</a> package implements how arithmatic with such numbers should be performed. Analagously, one can use arbitrary precision arithmatic (when many decimal places of precision are required) or complex valued numbers together with this package.</p><h3 id="Example-3"><a class="docs-heading-anchor" href="#Example-3">Example</a><a class="docs-heading-anchor-permalink" href="#Example-3" title="Permalink"></a></h3><p>Let&#39;s solve standard mode-coupling theory with a structure factor that contains measurement errors. To generate such a structure factor, we can use the analytical Percus-Yevick expression, but pretend there is an uncertainty in the volume fraction <span>$\eta$</span>.</p><pre><code class="language-julia hljs">
julia&gt; using ModeCouplingTheory, Plots, Measurements

julia&gt; η = 0.51 ± 0.01
0.51 ± 0.05

julia&gt; ρ = η*6/π
0.974 ± 0.019

julia&gt; kBT = 1.0; m = 1.0;

julia&gt; Nk = 100; kmax = 40.0; dk = kmax/Nk; k_array = dk*(collect(1:Nk) .- 0.5);</code></pre><p>We use the same functions to find the structure factor as before:</p><pre><code class="nohighlight hljs">&quot;&quot;&quot;
Finds the fourier transform of the direct correlation function given by the 
analytical percus yevick solution of the Ornstein Zernike 
equation for hard spheres for a given volume fraction η on the coordinates r
in units of one over the diameter of the particles
&quot;&quot;&quot; 
function find_analytical_C_k(k, η)
    A = -(1 - η)^-4 *(1 + 2η)^2
    B = (1 - η)^-4*  6η*(1 + η/2)^2
    D = -(1 - η)^-4 * 1/2 * η*(1 + 2η)^2
    Cₖ = @. 4π/k^6 * 
    (
        24*D - 2*B * k^2 - (24*D - 2 * (B + 6*D) * k^2 + (A + B + D) * k^4) * cos(k)
     + k * (-24*D + (A + 2*B + 4*D) * k^2) * sin(k)
     )
    return Cₖ
end

&quot;&quot;&quot;
Finds the static structure factor given by the 
analytical percus yevick solution of the Ornstein Zernike 
equation for hard spheres for a given volume fraction η on the coordinates r
in units of one over the diameter of the particles
&quot;&quot;&quot; 
function find_analytical_S_k(k, η)
        Cₖ = find_analytical_C_k(k, η)
        ρ = 6/π * η
        Sₖ = @. 1 + ρ*Cₖ / (1 - ρ*Cₖ)
    return Sₖ
end

julia&gt; Sₖ_uncertain = find_analytical_S_k(k_array, ρ*π/6)
100-element Vector{Measurement{Float64}}:
  0.0142 ± 0.0014
  0.0145 ± 0.0015
  0.0152 ± 0.0015
  0.0163 ± 0.0017
         ⋮
  1.0154 ± 0.0012
  0.9987 ± 0.00012
 0.98327 ± 0.00089

julia&gt; plot(k_array, Sₖ_uncertain, xlabel=&quot;k&quot;, ylabel=&quot;S(k)&quot;, legend=false)</code></pre><p><img src="images/uncertainS.png" alt="image"/></p><p>Now we can use this structure factor to solve the mode-coupling equation as usual.</p><pre><code class="language-julia hljs"># The initial condition of the derivative must have the same type as the initial condition itself
∂F0 = zeros(eltype(Sₖ_uncertain), Nk)
α = 1.0; β = 0.0; γ = @. k_array^2*kBT/(m*Sₖ_uncertain); δ = 0.0
kernel = ModeCouplingKernel(ρ, kBT, m, k_array, Sₖ_uncertain)
problem = MemoryEquation(α, β, γ, δ, Sₖ_uncertain, ∂F0, kernel)
solver = TimeDoublingSolver(Δt=10^-5, t_max=10.0^5, verbose=true, N = 8, tolerance=10^-8, max_iterations=10^8)
sol = @time solve(problem, solver);
p = plot(xlabel=&quot;log10(t)&quot;, ylabel=&quot;F(k,t)&quot;, ylims=(0,1), xlims=(-5,5))
plot!(p, log10.(sol.t[2:10:end]), sol[19]/Sₖ_uncertain[19], label=&quot;k = $(k_array[19])&quot;, lw=3)</code></pre><p><img src="images/uncertainF.png" alt="image"/></p><h2 id="Steady-state-(non-ergodicity-parameter)"><a class="docs-heading-anchor" href="#Steady-state-(non-ergodicity-parameter)">Steady state (non-ergodicity parameter)</a><a id="Steady-state-(non-ergodicity-parameter)-1"></a><a class="docs-heading-anchor-permalink" href="#Steady-state-(non-ergodicity-parameter)" title="Permalink"></a></h2><p>This package also exports a function <code>solve_steady_state(γ, F₀, kernel; tolerance=10^-8, max_iterations=10^6, verbose=false)</code> to find the steady-state solution of a mode-coupling like equation. In order to find it, it performs a recursive iteration of the mapping </p><p class="math-container">\[F^\infty = (K(F^\infty,t=\infty) + γ)^{-1} \cdot K(F^\infty, t=\infty) \cdot F(t=0)\]</p><p>It returns a <code>MemoryEquationSolution</code> object defined at one time <span>$t=\infty$</span>, which contains both <span>$F(t=\infty)$</span> and <span>$K(t=\infty)$</span> as fields.</p><h3 id="Example-4"><a class="docs-heading-anchor" href="#Example-4">Example</a><a class="docs-heading-anchor-permalink" href="#Example-4" title="Permalink"></a></h3><pre><code class="language-julia hljs">using ModeCouplingTheory, Plots
η = 0.51595; ρ = η*6/π; kBT = 1.0; m = 1.0
Nk = 100; kmax = 40.0; dk = kmax/Nk; k_array = dk*(collect(1:Nk) .- 0.5);
Sₖ = find_analytical_S_k(k_array, ρ*π/6)

γ = @. k_array^2*kBT/(m*Sₖ)
kernel = ModeCouplingKernel(ρ, kBT, m, k_array, Sₖ)
sol = solve_steady_state(γ, Sₖ, kernel; tolerance=10^-8, verbose=false)
fk = sol.F[1]
p = plot(k_array, fk, ylabel=&quot;non-ergodicity parameter&quot;, xlabel=&quot;k&quot;)</code></pre><p><img src="images/nonergo.png" alt="image"/></p><h2 id="Relaxation-time"><a class="docs-heading-anchor" href="#Relaxation-time">Relaxation time</a><a id="Relaxation-time-1"></a><a class="docs-heading-anchor-permalink" href="#Relaxation-time" title="Permalink"></a></h2><p>Relaxation times can be easily extracted from dynamical data using the <code>find_relaxation_time(t, F; threshold=exp(-1), mode=:log)</code> function.</p><h3 id="Example-5"><a class="docs-heading-anchor" href="#Example-5">Example</a><a class="docs-heading-anchor-permalink" href="#Example-5" title="Permalink"></a></h3><p>Let&#39;s solve mode-coupling theory to get some data:</p><pre><code class="language-julia hljs"># We solve MCT for hard spheres at a volume fraction of 0.51591
η = 0.51591; ρ = η*6/π; kBT = 1.0; m = 1.0

Nk = 100; kmax = 40.0; dk = kmax/Nk; k_array = dk*(collect(1:Nk) .- 0.5)
Sₖ = find_analytical_S_k(k_array, η)

∂F0 = zeros(Nk); α = 1.0; β = 0.0; γ = @. k_array^2*kBT/(m*Sₖ); δ = 0.0

kernel = ModeCouplingKernel(ρ, kBT, m, k_array, Sₖ)
problem = MemoryEquation(α, β, γ, δ, Sₖ, ∂F0, kernel)
solver = TimeDoublingSolver(Δt=10^-5, t_max=10.0^15, verbose=false, 
                     N = 8, tolerance=10^-8)
sol = @time solve(problem, solver);</code></pre><p>We can now extract a single relaxation time by calling </p><pre><code class="language-julia hljs">julia&gt; find_relaxation_time(sol.t, sol[18]) # at k k_array[18]
4.232796654132995e11</code></pre><p>To extract all relaxation times as a function of <span>$k$</span>:</p><pre><code class="language-julia hljs">julia&gt; t_R = [find_relaxation_time(t, sol[ik]) for ik in eachindex(k_array)]; 
julia&gt; p = plot(k_array, log10.(t_R), xlabel=&quot;k&quot;, ylabel=&quot;log10(relaxation time)&quot;, legend=false)</code></pre><p><img src="images/tr.png" alt="image"/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="Kernels.html">« Kernels</a><a class="docs-footer-nextpage" href="FromPython.html">From Python »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Friday 20 January 2023 14:57">Friday 20 January 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
