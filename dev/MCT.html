<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Mode-Coupling Theory · ModeCouplingTheory</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">ModeCouplingTheory</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Introduction</a></li><li><a class="tocitem" href="Problems_and_Solvers.html">Equations and Solvers</a></li><li><a class="tocitem" href="Kernels.html">Kernels</a></li><li class="is-active"><a class="tocitem" href="MCT.html">Mode-Coupling Theory</a><ul class="internal"><li><a class="tocitem" href="#Single-component-Mode-Coupling-Theory"><span>Single-component Mode-Coupling Theory</span></a></li><li><a class="tocitem" href="#TaggedModeCouplingKernel"><span>TaggedModeCouplingKernel</span></a></li><li><a class="tocitem" href="#Multi-component-Mode-Coupling-Theory"><span>Multi-component Mode-Coupling Theory</span></a></li><li><a class="tocitem" href="#Bengtzelius&#39;-Trick"><span>Bengtzelius&#39; Trick</span></a></li></ul></li><li><a class="tocitem" href="Scope.html">Scope</a></li><li><a class="tocitem" href="FromPython.html">From Python</a></li><li><a class="tocitem" href="internals.html">Internals</a></li><li><a class="tocitem" href="API.html">API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="MCT.html">Mode-Coupling Theory</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="MCT.html">Mode-Coupling Theory</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/IlianPihlajamaa/ModeCouplingTheory.jl/blob/main/docs/src/MCT.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="Single-component-Mode-Coupling-Theory"><a class="docs-heading-anchor" href="#Single-component-Mode-Coupling-Theory">Single-component Mode-Coupling Theory</a><a id="Single-component-Mode-Coupling-Theory-1"></a><a class="docs-heading-anchor-permalink" href="#Single-component-Mode-Coupling-Theory" title="Permalink"></a></h2><p>The mode-coupling theory equation reads</p><p class="math-container">\[\ddot{F}(k,t) + \Omega(k)F(k,t) + \int_0^td\tau K(t-\tau, k)\dot{F}(k,\tau)=0\]</p><p>in which <span>$\Omega(k) = k^2 k_B T/mS(k)$</span>, and</p><p class="math-container">\[K(k,t) =\frac{\rho k_BT}{16\pi^3 m} \int d\mathbf{q} V(\mathbf{k}, \mathbf{q})^2F(q, t)F(|\mathbf{k}-\mathbf{q}|,t)\]</p><p>in which the vertex <span>$V(\textbf{k}, \textbf{q}) = (\textbf{k}\cdot\textbf{q})c(q)/k+(\textbf{k}\cdot(\textbf{k}-\textbf{q})c(|\textbf{k}-\textbf{q}|)/k$</span>. For more details and the meaning of the symbols, see [1, 2].</p><p>This memory kernel integral is discretised as follows:</p><p class="math-container">\[\int d\textbf{q}f(q, |\textbf{k}-\textbf{q}|) = 2\pi\int_0^\infty dq q^2 \int_0^\pi d\theta \sin \theta f(q, |\textbf{k}-\textbf{q}|) = \frac{2\pi}{k}\int_0^\infty dq \int_{|k-q|}^{k+q}dp pq f(q, p) \approx \frac{2\pi \Delta k^2}{k_i}\sum_{j=1}^{N_k} \sum_{l=|j-i|+1}^{j+i-1} \frac{p_l q_j}{k_i}f(q_j, p_l).\]</p><p>in which <span>$p = |\textbf{k}-\textbf{q}|$</span>, and wave numbers <span>$k$</span>, <span>$q$</span> and <span>$p$</span> are discretized on the equidistant grid <span>$k_i = (i_k-\frac{1}{2})\Delta k$</span> where <span>$i_k = 1, 2, 3, \ldots, N_k$</span>. The double sum is then performed for all <span>$k$</span> using Bengtzelius&#39; trick, yielding a fast <span>$O(N_k^2)$</span> algorithm. </p><h3 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h3><pre><code class="language-julia hljs">&quot;&quot;&quot;
    find_analytical_C_k(k, η)
Finds the direct correlation function given by the 
analytical Percus-Yevick solution of the Ornstein-Zernike 
equation for hard spheres for a given volume fraction η.

Reference: Wertheim, M. S. &quot;Exact solution of the Percus-Yevick integral equation 
for hard spheres.&quot; Physical Review Letters 10.8 (1963): 321.
&quot;&quot;&quot; 
function find_analytical_C_k(k, η)
    A = -(1 - η)^-4 *(1 + 2η)^2
    B = (1 - η)^-4*  6η*(1 + η/2)^2
    D = -(1 - η)^-4 * 1/2 * η*(1 + 2η)^2
    Cₖ = @. 4π/k^6 * 
    (
        24*D - 2*B * k^2 - (24*D - 2 * (B + 6*D) * k^2 + (A + B + D) * k^4) * cos(k)
     + k * (-24*D + (A + 2*B + 4*D) * k^2) * sin(k)
     )
    return Cₖ
end

&quot;&quot;&quot;
    find_analytical_S_k(k, η)
Finds the static structure factor given by the 
analytical Percus-Yevick solution of the Ornstein-Zernike 
equation for hard spheres for a given volume fraction η.
&quot;&quot;&quot; 
function find_analytical_S_k(k, η)
        Cₖ = find_analytical_C_k(k, η)
        ρ = 6/π * η
        Sₖ = @. 1 + ρ*Cₖ / (1 - ρ*Cₖ)
    return Sₖ
end

# We solve MCT for hard spheres at a volume fraction of 0.51591
η = 0.51591; ρ = η*6/π; kBT = 1.0; m = 1.0

Nk = 100; kmax = 40.0; 
dk = kmax/Nk; k_array = dk*(collect(1:Nk) .- 0.5) # construct the grid this way to satisfy the assumtions
                                                  # of the discretisation.
Sₖ = find_analytical_S_k(k_array, η)

∂F0 = zeros(Nk); α = 1.0; β = 0.0; γ = @. k_array^2*kBT/(m*Sₖ); δ = 0.0

kernel = ModeCouplingKernel(ρ, kBT, m, k_array, Sₖ)
problem = MemoryEquation(α, β, γ, δ, Sₖ, ∂F0, kernel)
solver = TimeDoublingSolver(Δt=10^-5, t_max=10.0^15, verbose=true, 
                     N = 8, tolerance=10^-8)
sol = solve(problem, solver);
p = plot(xlabel=&quot;log10(t)&quot;, ylabel=&quot;F(k,t)&quot;, ylims=(0,1))
for ik = [7, 18, 25, 39]
    Fk = get_F(sol, :, ik)
    plot!(p, log10.(get_t(sol)), Fk/Sₖ[ik], label=&quot;k = $(k_array[ik])&quot;, lw=3)
end
p</code></pre><p><img src="images/MCTKernel2.png" alt="image"/></p><h4 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h4><p>[1] Reichman, David R., and Patrick Charbonneau. &quot;Mode-coupling theory.&quot; Journal of Statistical Mechanics: Theory and Experiment 2005.05 (2005): P05013.</p><p>[2] Janssen, Liesbeth MC. &quot;Mode-coupling theory of the glass transition: A primer.&quot; Frontiers in Physics 6 (2018): 97.</p><h2 id="TaggedModeCouplingKernel"><a class="docs-heading-anchor" href="#TaggedModeCouplingKernel">TaggedModeCouplingKernel</a><a id="TaggedModeCouplingKernel-1"></a><a class="docs-heading-anchor-permalink" href="#TaggedModeCouplingKernel" title="Permalink"></a></h2><p>Let&#39;s say we have just solved the mode-coupling equations, and we now want to include also a tagged particle solution (to find the self-intermediate scattering function). This function satisfies</p><p class="math-container">\[\ddot{F}_s(k,t) + \frac{k^2 k_BT}{m} F_s(k,t) + \int_0^t d\tau K(k, t-\tau)\dot{F}_s(k, \tau)=0,\]</p><p>in which</p><p class="math-container">\[K(k,t) = \frac{\rho k_BT}{8\pi^3 m}\int d\mathbf{q} V(\mathbf{k}, \mathbf{q})^2 F(q, t)F_s(|\mathbf{k}-\mathbf{q}|,t)\]</p><p>where</p><p class="math-container">\[V(\textbf{k}, \textbf{q}) = (\textbf{k}\cdot\textbf{q})c(q)/k = \frac{k^2+q^2-p^2}{2k} \cdot c(q),\]</p><p>are the tagged vertices. This is done using the <code>TaggedModeCouplingKernel</code>.</p><p>Example (excluding the code from collective MCT):</p><pre><code class="language-julia hljs">taggedF0 = ones(Nk); tagged∂F0 = zeros(Nk); α = 1.0; β = 0.0; γ = @. k_array^2*kBT/m; δ = 0.0

taggedkernel = TaggedModeCouplingKernel(ρ, kBT, m, k_array, Sₖ, sol)
taggedequation = MemoryEquation(α, β, γ, δ, taggedF0, tagged∂F0, taggedkernel)
taggedsol = solve(taggedequation, solver)</code></pre><h3 id="Mean-squared-displacement-(MSD)"><a class="docs-heading-anchor" href="#Mean-squared-displacement-(MSD)">Mean squared displacement (MSD)</a><a id="Mean-squared-displacement-(MSD)-1"></a><a class="docs-heading-anchor-permalink" href="#Mean-squared-displacement-(MSD)" title="Permalink"></a></h3><p>From the tagged particle dynamics we just computed, we can evaluate the MSD, as a low k limit. The equations that it satisfies are</p><p class="math-container">\[\ddot{\delta r^2}(t) - \frac{6 k_BT}{m}  + \int_0^t d\tau K(k, t-\tau)\delta\dot{ r}^2(\tau)=0,\]</p><p>where</p><p class="math-container">\[K(t) = \frac{\rho k_BT}{6\pi^2 m}\int_0^\infty dq q^4c(q)^2F(q,t)F_s(q,t).\]</p><p>This kernel is implemented in the <code>MSDModeCouplingKernel</code></p><p>Example:</p><pre><code class="language-julia hljs">MSD0 = 0.0; dMSD0 = 0.0; α = 1.0; β = 0.0; γ = 0.0; δ = -6.0*kBT/m;
msdkernel = MSDModeCouplingKernel(ρ, kBT, m, k_array, Sₖ, sol, taggedsol)
msdequation = MemoryEquation(α, β, γ, δ, MSD0, dMSD0, msdkernel)
msdsol = solve(msdequation, solver)

plot(log10.(msdsol.t), log10.(msdsol.F), xlabel=&quot;log(t)&quot;, ylabel=&quot;log(MSD(t))&quot;, xlims=(-5,15), label=false)</code></pre><p><img src="images/msd.png" alt="image"/></p><h2 id="Multi-component-Mode-Coupling-Theory"><a class="docs-heading-anchor" href="#Multi-component-Mode-Coupling-Theory">Multi-component Mode-Coupling Theory</a><a id="Multi-component-Mode-Coupling-Theory-1"></a><a class="docs-heading-anchor-permalink" href="#Multi-component-Mode-Coupling-Theory" title="Permalink"></a></h2><p>The multi-component mode-coupling theory equation reads</p><p class="math-container">\[\ddot{F}_{\alpha\beta}(k,t) + \Omega^2_{\alpha\gamma}(k)F_{\gamma\beta}(k,t) + \int_0^td\tau K_{\alpha\gamma}(t-\tau, k)\dot{F}_{\gamma\beta}(k, \tau)=0\]</p><p>in which <span>$\Omega^2_{\alpha\gamma} = k^2 k_B T x_\alpha/m_\alpha \cdot \left(S^{-1}\right)_{\alpha\gamma}(k)$</span>, and <span>$(\textbf{S})^{-1}(k) = (\frac{\delta_{\alpha\beta}}{x_\alpha} - \rho c_{\alpha\gamma}(k))$</span>. The memory kernel is given by</p><p class="math-container">\[K_{\alpha\beta}(k,t) =\frac{k_B T \rho}{2 x_\beta m_\alpha (2\pi)^3} \int d\mathbf{q} V_{\mu&#39;\nu&#39;\alpha}(\mathbf{k}, \mathbf{q})F_{\mu\mu&#39;}(q, t)F_{\nu\nu&#39;}(|\mathbf{k}-\mathbf{q}|,t)V_{\mu\nu\beta}(\mathbf{k}, \mathbf{q})\]</p><p>in which the vertex <span>$V_{\mu\nu\alpha}(\mathbf{k}, \mathbf{q}) = (\textbf{k}\cdot\textbf{q})c_{\alpha\mu}(q)\delta_{\alpha\nu}/k+(\textbf{k}\cdot(\textbf{k}-\textbf{q})c_{\alpha\nu}(|\textbf{k}-\textbf{q}|)\delta_{\alpha\mu}/k$</span>. Here, the Greek indices indicate species labels, and we have adopted the convention that we sum over repeated indices. This memory kernel has also been implemented using the Bengtzelius&#39; trick. It requires <span>$O(N_k^2 N_s^2)$</span> storage and runs in <span>$O(N_k^2 N_s^4)$</span> in which <span>$N_s$</span> is the number of species.</p><p>Numerically, the correlator <span>$F_{\alpha\beta}(k)$</span> is implemented as a <code>Vector</code> of length <code>Nk</code> of which each of the elements is a small <code>Ns</code> x <code>Ns</code> static matrix. This means that this is also the expected form of the initial condition. If, instead you have the data in a matrix format where each element of the matrix is a list of k-vales, use the <code>convert_multicomponent_structure_factor(S)</code> function to convert it into the right format, see the API page. </p><p>All symbols have the same meaning as those presented in &quot;Weysser, F., Puertas, A. M., Fuchs, M., &amp; Voigtmann, T. (2010). Structural relaxation of polydisperse hard spheres: Comparison of the mode-coupling theory to a Langevin dynamics simulation. Physical review E, 82(1), 011504.&quot;</p><h3 id="Example-2"><a class="docs-heading-anchor" href="#Example-2">Example</a><a class="docs-heading-anchor-permalink" href="#Example-2" title="Permalink"></a></h3><pre><code class="language-julia hljs">using StaticArrays, LinearAlgebra, DelimitedFiles
# number of species Ns, number of wave numbers Nk, volume fraction η
# thermal energy kBT and mass m
Ns = 2; Nk = 100; η  = 0.515; kBT = 1.0; m = ones(Ns)
particle_diameters = [0.8,1.0]
x = [0.2,0.8] # species fraction

# total density
ρ_all = 6η/(π*sum(x .* particle_diameters .^ 3))
ρ = ρ_all * x

kmax = 40.0; dk = kmax/Nk
k_array = dk*(collect(1:Nk) .- 0.5)

# data can be found in the \test\ folder of the source code
Sₖdata = reshape(readdlm(&quot;test/Sk_MC.txt&quot;), (2,2,100))
# convert the data to the Vector of SMatrix format
Sₖ = [@SMatrix(zeros(Ns, Ns)) for i = 1:Nk]
for i = 1:Nk
    Sₖ[i] = Sₖdata[:, :, i]
end
S⁻¹ = inv.(Sₖ)

J = similar(Sₖ) .* 0.0
for ik = 1:Nk
    J[ik] = kBT*k_array[ik]^2 * x ./ m .* I(Ns)
end

F₀ = copy(Sₖ)
∂ₜF₀ = [@SMatrix(zeros(Ns, Ns)) for i = 1:Nk]
α = 1.0
β = 0.0
Ω2 = similar(Sₖ)
for ik = 1:Nk
    Ω2 .= J.*S⁻¹
end
δ = @SMatrix zeros(Ns, Ns)

kernel = MultiComponentModeCouplingKernel(ρ, kBT, m, k_array, Sₖ)
problem = MemoryEquation(α, β, Ω2, δ, F₀, ∂ₜF₀, kernel)
solver = TimeDoublingSolver(verbose=false, N=16, tolerance=10^-8, max_iterations=10^8)
sol = solve(problem, solver)
ik = 19
k = k_array[ik]
t = get_t(sol)

Fk_11 = get_F(:, ik, (1,1))
Fk_12 = get_F(:, ik, (1,2))
Fk_21 = get_F(:, ik, (2,1))
Fk_22 = get_F(:, ik, (2,2))

p = plot(log10.(t), Fk_11/Sₖ[ik][1,1], ls=:dash, lw=2, color=1, label=&quot;Faa(k=$k, t)&quot;) 
plot!(log10.(t), Fk_12/Sₖ[ik][1,2], lw=2, color=2, label=&quot;Fab(k=$k, t)&quot;) 
plot!(log10.(t), Fk_21/Sₖ[ik][2,1], ls=:dash, lw=2, color=3, label=&quot;Fba(k=$k, t)&quot;) 
plot!(log10.(t), Fk_22/Sₖ[ik][2,2], ls=:dash, lw=2, color=4, label=&quot;Fbb(k=$k, t)&quot;)</code></pre><p><img src="images/MCMCTKernel.png" alt="image"/></p><h3 id="Tagged-multi-compontent-mode-coupling-theory"><a class="docs-heading-anchor" href="#Tagged-multi-compontent-mode-coupling-theory">Tagged multi-compontent mode-coupling theory</a><a id="Tagged-multi-compontent-mode-coupling-theory-1"></a><a class="docs-heading-anchor-permalink" href="#Tagged-multi-compontent-mode-coupling-theory" title="Permalink"></a></h3><p>The tagged multi-component mode-coupling theory equation reads</p><p class="math-container">\[\dot{F}_{s}(k,t) + \Omega_s^2(k)F_{s}(k,t) + \int_0^td\tau K_{s}(t-\tau, k)\dot{F}_{s}(k, \tau)=0\]</p><p>for a particle of species <span>$s$</span> in which <span>$\Omega_{s}^2 = k^2 k_B T/m_s$</span>. The memory kernel is given by</p><p class="math-container">\[K_{s}(k,t) =\frac{k_B T \rho}{k^3m_s (2\pi)^3} \sum_{\alpha\beta}\int d\mathbf{q} \left(\textbf{k}\cdot\textbf{q}\right)^2C_{s\alpha}(q)C_{s\beta}(q)F_{\alpha\beta}(q, t)F_{s}(|\mathbf{k}-\mathbf{q}|,t).\]</p><p>Here <span>$F_{s}$</span> is the tagged correlator, with initial condition <span>$F_{s}(t=0)=1$</span>, and <span>$F_{\alpha\beta}$</span> is the collective correlator which can be obtained as explained in the previous section.</p><h4 id="Example-3"><a class="docs-heading-anchor" href="#Example-3">Example</a><a class="docs-heading-anchor-permalink" href="#Example-3" title="Permalink"></a></h4><pre><code class="language-julia hljs"># we look for the tagged correlator of the second species.
s = 2
α = 1.0
β = 0.0
γ = [kBT * k_array[ik]^2 ./ m[s] for ik = 1:Nk]
δ = 0.0
F0 = [1.0 for ik = 1:Nk]
dF0 = [0.0 for ik = 1:Nk]

taggedkernel = TaggedMultiComponentModeCouplingKernel(s, ρ, kBT, m, k_array, Sₖ, sol);
taggedequation = MemoryEquation(α, β, γ, δ, F0, dF0, taggedkernel);
taggedsol = solve(taggedequation, solver)</code></pre><p>In order to solve the tagged particle equation for all species, one should loop over the above code, changing specie index <span>$s$</span> from 1 to the number of species.</p><h3 id="Multi-component-mean-squared-displacements"><a class="docs-heading-anchor" href="#Multi-component-mean-squared-displacements">Multi-component mean-squared displacements</a><a id="Multi-component-mean-squared-displacements-1"></a><a class="docs-heading-anchor-permalink" href="#Multi-component-mean-squared-displacements" title="Permalink"></a></h3><p>The equation for the mean squared displacement in a multicomponent system reads</p><p class="math-container">\[\delta \dot{r}_s^2(t) -\frac{6k_BT}{m_s} + \int_0^td\tau K_{s}(t-\tau)\delta \dot{r}_s^2(\tau)=0\]</p><p>for a particle of species <span>$s$</span>. The memory kernel is given by</p><p class="math-container">\[K_s(t) = \frac{\rho k_BT}{6\pi^2 m_s}\sum_{\alpha\beta}\int_0^\infty dq q^4c_{s\alpha}(q)c_{s\beta}(q)F_{\alpha\beta}(q,t)F^{(s)}_s(q,t).\]</p><p>Here <span>$\delta r_s^2(t)$</span> is the MSD of species s, with initial condition <span>$\delta r_s^2(t=0)=0$</span>, and <span>$\delta \dot{r}_s^2(t=0)=0$</span>. This kernel is implemented using the <code>MSDMultiComponentModeCouplingKernel</code></p><h4 id="Example-4"><a class="docs-heading-anchor" href="#Example-4">Example</a><a class="docs-heading-anchor-permalink" href="#Example-4" title="Permalink"></a></h4><pre><code class="language-julia hljs"># we look for the tagged correlator of the second species.
s = 2
α = 1.0
β = 0.0
γ = 0.0
δ = -6*kBT / m[s]
msd0 = 0.0
dmsd0 = 0.0

msdkernel = MSDMultiComponentModeCouplingKernel(s, ρ, kBT, m, k_array, Sₖ, sol, taggedsol);
msdequation = MemoryEquation(α, β, γ, δ, msd0, dmsd0, msdkernel);
msdsol = solve(msdequation, solver)</code></pre><h2 id="Bengtzelius&#39;-Trick"><a class="docs-heading-anchor" href="#Bengtzelius&#39;-Trick">Bengtzelius&#39; Trick</a><a id="Bengtzelius&#39;-Trick-1"></a><a class="docs-heading-anchor-permalink" href="#Bengtzelius&#39;-Trick" title="Permalink"></a></h2><p>Bengtzelius&#39; trick is a fast way to evaluate the integral <span>$I(k) = \int d \mathbf{q} A(q, |\mathbf{k}-\mathbf{q}|)$</span>. It is used in the evaluation of all memory kernels listed on this page. Very briefly: after discretisation of the integral, one is left with terms such as <span>$T_{i}[A]=\sum_{j=1}^{N_k}\sum_{l=|j-i|+1}^{i+j-1}  A(p_{l},q_{j})$</span> which are largely independent of <span>$i$</span>. Because of this, one can calculate <span>$T_{i}[A]$</span> from <span>$T_{i-1}[A]$</span> in order <span>$N_k$</span> operations. The recurrence relation that allows one to do so is given by </p><p class="math-container">\[T_{i}[A] = T_{i-1}[A] + \sum_{j=1}^{N_k-i+1}(A(j, j+i-1)+A(j+i-1, j)) - \sum_{j=1}^{i-1}A(j,i-j)\]</p><p>with initial condition</p><p class="math-container">\[T_{1}[A] = \sum_{j=1}^{N_k}A(j, j).\]</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="Kernels.html">« Kernels</a><a class="docs-footer-nextpage" href="Scope.html">Scope »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Tuesday 18 July 2023 07:55">Tuesday 18 July 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
