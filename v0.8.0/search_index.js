var documenterSearchIndex = {"docs":
[{"location":"Kernels.html#Kernels","page":"Kernels","title":"Kernels","text":"","category":"section"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"A memory kernel kernel is an instance of a type of which MemoryKernel is a supertype. It can be used to compute out = evaluate_kernel(kernel, F, t) to find the value of the memory kernel. Additionally, when F is a mutable container like a Vector, one can call evaluate_kernel!(out, kernel, F, t) in which case it will mutate the elements of the temporary array out. Below we list the memory kernels that this package defines and give some examples of how to use them.","category":"page"},{"location":"Kernels.html#Schematic-Kernels","page":"Kernels","title":"Schematic Kernels","text":"","category":"section"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"This package includes a couple of schematic memory kernels.","category":"page"},{"location":"Kernels.html#.-ExponentiallyDecayingKernel","page":"Kernels","title":"1. ExponentiallyDecayingKernel","text":"","category":"section"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"The ExponentiallyDecayingKernel implements the kernel K(t) = λ exp(-tτ). It has fields λ <: Number and τ <: Number.","category":"page"},{"location":"Kernels.html#Example","page":"Kernels","title":"Example","text":"","category":"section"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"The integro-differential equation with this memory kernel actually has an analytic solution for tau=1, alpha=0 , beta=1, and gamma=1. It is given by","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"F(t) = frace^-fract2left( lambda + sqrtlambda(lambda+4) + 2right)2 sqrtlambda  (lambda +4)left(sqrtlambda(lambda+4) left(e^sqrtlambda(lambda+4) t+1right)+lambda  left(e^sqrtlambda(lambda+4) t-1right)right)","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"F0 = 1.0; ∂F0 = 0.0; α = 0.0; β = 1.0; γ = 1.0; δ = 0.0; λ = 1.0; τ = 1.0;\n\nkernel = ExponentiallyDecayingKernel(λ, τ)\nproblem = MemoryEquation(α, β, γ, δ, F0, ∂F0, kernel)\nsolver = TimeDoublingSolver(Δt=10^-3, t_max=10.0^2, verbose=false, N = 128, tolerance=10^-10, max_iterations=10^6)\nsol =  solve(problem, solver)\n\nt_analytic = 10 .^ range(-3, 2, length=50)\nF_analytic = @. (exp(-0.5*(3+sqrt(5))* t_analytic)*(exp(sqrt(5)*t_analytic) * (1+sqrt(5))-1+sqrt(5)))/(2sqrt(5))\n\nusing Plots\np = plot(log10.(get_t(sol)), get_F(sol), label=\"Numeric solution\", lw=3)\nscatter!(log10.(t_analytic), F_analytic, label=\"Exact solution\", ylabel=\"F\", xlabel=\"log10(t)\")","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"(Image: image)","category":"page"},{"location":"Kernels.html#SchematicF1Kernel","page":"Kernels","title":"SchematicF1Kernel","text":"","category":"section"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"The SchematicF1Kernel implements the kernel K(t) = ν F(t). It has one field ν <: Number.","category":"page"},{"location":"Kernels.html#Example-2","page":"Kernels","title":"Example","text":"","category":"section"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"The integro-differential equation with this memory kernel also has an analytic solution for alpha=0 , beta=1, and nu=1. It is given by","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"F(t) =  e^-2tleft(I_0(2t) + I_1(2t) right)","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"in which I_k are modified Bessel functions of the first kind.","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"F0 = 1.0; ∂F0 = 0.0; α = 0.0; β = 1.0; γ = 1.0; ν = 1.0; δ = 0.0\n\nkernel = SchematicF1Kernel(ν)\nproblem = MemoryEquation(α, β, γ, δ, F0, ∂F0, kernel)\nsolver = TimeDoublingSolver(Δt=10^-3, t_max=10.0^2, verbose=false, N = 100, tolerance=10^-14, max_iterations=10^6)\nsol =  solve(problem, solver)\n\nusing Plots, SpecialFunctions\nt_analytic = 10 .^ range(-3, 2, length=50)\nF_analytic = @. exp(-2*t_analytic)*(besseli(0, 2t_analytic) + besseli(1, 2t_analytic))\nplot(log10.(get_t(sol)), get_F(sol), label=\"Numerical Solution\", ylabel=\"F\", xlabel=\"log10(t)\", lw=3)\nscatter!(log10.(t_analytic), F_analytic, label=\"Exact Solution\")","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"(Image: image)","category":"page"},{"location":"Kernels.html#SchematicF2Kernel","page":"Kernels","title":"SchematicF2Kernel","text":"","category":"section"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"The SchematicF2Kernel implements the kernel K(t) = ν F(t)^2. It has one field ν <: Number.","category":"page"},{"location":"Kernels.html#SchematicF123Kernel","page":"Kernels","title":"SchematicF123Kernel","text":"","category":"section"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"The SchematicF123Kernel implements the kernel K(t) = nu_1 F(t) + nu_2 F(t)^2 + nu_3 F(t)^3. It has fields ν1 <: Number, ν2 <: Number, and ν3 <: Number.","category":"page"},{"location":"Kernels.html#Example-3","page":"Kernels","title":"Example","text":"","category":"section"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"kernel = SchematicF123Kernel(3.0, 2.0, 1.0);\nF = 2; t = 0;\nevaluate_kernel(kernel, F, t) # returns 22.0 = 3*2^1 + 2*2^2 + 1*2^3","category":"page"},{"location":"Kernels.html#InterpolatingKernel","page":"Kernels","title":"InterpolatingKernel","text":"","category":"section"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"The InterpolatingKernel implements a kernel that interpolates memory kernel data. It is initialized by calling kernel = InterpolatingKernel(t, M, k=k) where t is a Vector of time points, M is a vector of corresponding memory kernel values, and k is the integer degree of polynomial interpolation (default=1). This kernel is implemented using Dierckx.Spline1D. See Dierckx.jl for more information.","category":"page"},{"location":"Kernels.html#SchematicDiagonalKernel","page":"Kernels","title":"SchematicDiagonalKernel","text":"","category":"section"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"The SchematicDiagonalKernel implements the kernel K_ij(t) = delta_ij nu_i F_i(t)^2. It has one field ν which must be either a Vector or an SVector. When called, it returns Diagonal(ν .* F .^ 2), i.e., it implements a non-coupled system of SchematicF2Kernels.","category":"page"},{"location":"Kernels.html#SchematicMatrixKernel","page":"Kernels","title":"SchematicMatrixKernel","text":"","category":"section"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"The SchematicMatrixKernel implements the kernel K_ij(t) = sum_k nu_ij F_k(t) F_j(t). It has one field ν which must be either a Matrix or an SMatrix. ","category":"page"},{"location":"Kernels.html#SjogrenKernel","page":"Kernels","title":"SjogrenKernel","text":"","category":"section"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"The SjogrenKernel implements the kernel K_1(t) = nu_1 F_1(t)^2, K_2(t) = nu_2 F_1(t) F_2(t). It has two fields ν1 and ν2 which must both be of the same type. Consider using Static Vectors for performance.","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"Example:","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"using StaticArrays\nα = 1.0\nβ = 0.0\nγ = 1.0\nδ = 0.0\nν1 = 2.0\nν2 = 1.0\nF0 = @SVector [1.0, 1.0]\n∂F0 = @SVector [0.0, 0.0]\nkernel = SjogrenKernel(ν1, ν2)\neq = MemoryEquation(α, β, γ, δ, F0, ∂F0, kernel)\nsol = solve(eq)","category":"page"},{"location":"Kernels.html#TaggedSchematicF2Kernel","page":"Kernels","title":"TaggedSchematicF2Kernel","text":"","category":"section"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"The TaggedSchematicF2Kernel implements a memory kernel K(t) = nu F(t) F_c(t), where F_c(t) is a correlator that the tagged one couples to. It must be a solution of an earlier schematic MCT equation. Make sure to use the same solver settings for both solves. ","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"Example:","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"F0 = 1.0\n∂F0 = 0.0\nα = 1.0\nβ = 0.0\nγ = 1.0\nδ = 0.0\nν1 = 2.0\nν2 = 1.0\nkernel = SchematicF2Kernel(ν1)\neq = MemoryEquation(α, β, γ, δ, F0, ∂F0, kernel)\nsol = solve(eq)\n\ntaggedkernel = TaggedSchematicF2Kernel(ν2, sol)\ntagged_eq = MemoryEquation(α, β, γ, δ, F0, ∂F0, taggedkernel)\ntagged_sol = solve(tagged_eq);","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"This example is (less performantly) equivalent to the example of the Sjogren kernel above. ","category":"page"},{"location":"Kernels.html#Mode-Coupling-Kernel","page":"Kernels","title":"Mode-Coupling Kernel","text":"","category":"section"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"See the next page of the documentation for information on the kernels for mode-coupling theory.","category":"page"},{"location":"Kernels.html#Defining-custom-kernels","page":"Kernels","title":"Defining custom kernels","text":"","category":"section"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"In order to define a custom kernel, one has to overload ModeCouplingTheory.evaluate_kernel(k::MyCustomKernel, F, t), and optionally  ModeCouplingTheory.evaluate_kernel!(out, k::MyCustomKernel, F, t) for better performance for mutable F.","category":"page"},{"location":"Kernels.html#Example-1","page":"Kernels","title":"Example 1","text":"","category":"section"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"Let's define a custom scalar kernel that evaluates K(t) = alpha F(t)^F(t). First, we define a MyWeirdKernel<:MemoryKernel type that holds the value of the parameter:","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"using ModeCouplingTheory\nimport ModeCouplingTheory.MemoryKernel\n\nstruct MyWeirdKernel <: MemoryKernel\n    α :: Float64\nend\n\nkernel = MyWeirdKernel(2.5)","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"Now, we can define the evaluation of this memory kernel","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"import ModeCouplingTheory.evaluate_kernel\n\nfunction evaluate_kernel(kernel::MyWeirdKernel, F, t)\n    return kernel.α*F^F\nend","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"That's it! We can now use it like any other memory kernel to solve the equation:","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"problem = MemoryEquation(1.0, 0.0, 1.0, 0.0, 1.0, 0.0, kernel)\nsolver = TimeDoublingSolver(Δt = 10^-4, t_max=10.0^5)\nsol = solve(problem, solver)\nusing Plots\np = plot(log10.(sol.t), sol.F, ylims=(0,1), ylabel=\"F(t)\", xlabel=\"log10(t)\")","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"(Image: image)","category":"page"},{"location":"Kernels.html#Example-2","page":"Kernels","title":"Example 2","text":"","category":"section"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"For a slightly more complex example, let's define the mode-coupling theory memory kernel (say we forgot that it is also a built-in kernel). The equation is given by:","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"ddotF(kt) + frack^2 k_BTm S(k) F(kt) + int_0^t dtau K(k t-tau)dotF(k tau)=0","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"in which","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"K(kt) = fracrho k_BT16pi^3 m int dmathbfq V(mathbfk mathbfq)^2F(q t)F(mathbfk-mathbfqt)","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"where","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"V(textbfk textbfq) = (textbfkcdottextbfq)c(q)k+(textbfkcdot(textbfk-textbfq)c(textbfk-textbfq)k","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"where p = textbfk - textbfq. For more information, see the next page of the docs, which is dedicated to this equation.","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"First, we need to evaluate the structure factor, and some input parameters:","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"using ModeCouplingTheory, LinearAlgebra\n\n\"\"\"\n    find_analytical_C_k(k, η)\nFinds the direct correlation function given by the \nanalytical Percus-Yevick solution of the Ornstein-Zernike \nequation for hard spheres for a given volume fraction η.\n\nReference: Wertheim, M. S. \"Exact solution of the Percus-Yevick integral equation \nfor hard spheres.\" Physical Review Letters 10.8 (1963): 321.\n\"\"\" \nfunction find_analytical_C_k(k, η)\n    A = -(1 - η)^-4 *(1 + 2η)^2\n    B = (1 - η)^-4*  6η*(1 + η/2)^2\n    D = -(1 - η)^-4 * 1/2 * η*(1 + 2η)^2\n    Cₖ = @. 4π/k^6 * \n    (\n        24*D - 2*B * k^2 - (24*D - 2 * (B + 6*D) * k^2 + (A + B + D) * k^4) * cos(k)\n     + k * (-24*D + (A + 2*B + 4*D) * k^2) * sin(k)\n     )\n    return Cₖ\nend\n\n\"\"\"\n    find_analytical_S_k(k, η)\nFinds the static structure factor given by the \nanalytical Percus-Yevick solution of the Ornstein-Zernike \nequation for hard spheres for a given volume fraction η.\n\"\"\" \nfunction find_analytical_S_k(k, η)\n        Cₖ = find_analytical_C_k(k, η)\n        ρ = 6/π * η\n        Sₖ = @. 1 + ρ*Cₖ / (1 - ρ*Cₖ)\n    return Sₖ\nend\nη = 0.5158; ρ = η*6/π; kBT = 1.0; m = 1.0\n\nNk = 100; kmax = 40.0; dk = kmax/Nk; k_array = dk*(collect(1:Nk) .- 0.5)\nSₖ = find_analytical_S_k(k_array, η)\nCₖ = find_analytical_C_k(k_array, η)\n∂F0 = zeros(Nk); α = 1.0; β = 0.0; γ = @. k_array^2*kBT/(m*Sₖ); δ = 0.0","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"Now, we need to construct the memory kernel for the intermediate scattering function F. For performance reasons, we also implement the in-place evaluate_kernel!(out, kernel, Fs, t). The discrete equation that we must implement is given by ","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"K(k_it) = fracrho k_BT Delta k^28pi^2 msum_j=1^N_k sum_l=j-i+1^j+i-1 fracp_l q_jk_iF(q_j)F(p_l)V^2(k_i q_j p_l)","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"This memory kernel can now be straightforwardly implemented as follows:","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"import ModeCouplingTheory.MemoryKernel\nstruct MCTKernel <: MemoryKernel\n    V²::Array{Float64, 3}\n    k_array::Vector{Float64}\n    prefactor::Float64\nend\n\n# The constructor for the MCTKernel\nfunction MCTKernel(ρ, kBT, m, k_array, Cₖ)\n    Δk = k_array[2] - k_array[1]\n    prefactor = ρ*kBT*Δk^2/(8*π^2*m)\n    Nk = length(k_array)\n    # calculate the vertices\n    V² = zeros(Nk, Nk, Nk)\n    for i = 1:Nk, j = 1:Nk, l = 1:Nk # loop over k, q, p\n        k = k_array[i]\n        q = k_array[j]\n        p = k_array[l]\n        cq = Cₖ[j]\n        cp = Cₖ[l]\n        if abs(j-i)+1 <= l <= j+i-1\n            V = cq * (k^2  + q^2 - p^2)/(2k) + cp * (k^2  + p^2 - q^2)/(2k)\n            V²[l, j, i] = V^2\n        end\n    end\n    return MCTKernel(V², k_array, prefactor)\nend\n","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"Now to evaluate the kernel, we first write the in-place version of the code, that mutates its first argument. Note also that, since the mermory kernel is multiplied with a vector F to produce something of the same type of F, it has to be encoded as a matrix, with on the diagonal the discretised wave-number dependent memory kernel values.","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"import ModeCouplingTheory.evaluate_kernel!\nfunction evaluate_kernel!(out::Diagonal, kernel::MCTKernel, F, t)\n    out.diag .= zero(eltype(out.diag)) # set the output array to zero\n    k_array = kernel.k_array\n    Nk = length(k_array)\n    for i = 1:Nk, j = 1:Nk, l = 1:Nk # loop over k, q, p\n        k = k_array[i]\n        q = k_array[j]\n        p = k_array[l]\n        out.diag[i] += p*q/k * kernel.V²[l, j, i] * F[j] * F[l]\n    end\n    out.diag .*= kernel.prefactor\nend\n\nimport ModeCouplingTheory.evaluate_kernel\nfunction evaluate_kernel(kernel::MCTKernel, F, t)\n    out = Diagonal(similar(F)) # we need it to produce a diagonal matrix\n    evaluate_kernel!(out, kernel, F, t) # call the inplace version\n    return out\nend","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"Now we can solve the equation:","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"kernel = MCTKernel(ρ, kBT, m, k_array, Cₖ);\nequation = MemoryEquation(α, β, γ, δ, Sₖ, ∂F0, kernel);\nsolver = TimeDoublingSolver(Δt=10^-5, t_max=10.0^10, \n                           N = 8, tolerance=10^-8, verbose=true);\nsol = @time solve(equation, solver);\nusing Plots\np = plot(xlabel=\"log10(t)\", ylabel=\"Fₛ(k,t)\", ylims=(0,1))\nfor ik = [7, 18, 25, 39]\n    Fk = get_F(sol, 1:10:800, ik)\n    t = get_t(sol)[1:10:800]\n    plot!(p, log10.(t), Fk/Sₖ[ik], label=\"k = $(k_array[ik])\", lw=3)\nend\np","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"This implementation of the memory kernel is much slower than the built-in one, and can be made much more performant by Bengtzelius' trick. For the purposes of this example, however, we do not pursue this any further. For help with implementing your own kernel, please file an issue.","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"We can verify that the results are the same with the built-in memory kernel:","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"kernel2 = ModeCouplingKernel(ρ, kBT, m, k_array, Sₖ);\nequation2 = MemoryEquation(α, β, γ, δ, Sₖ, ∂F0, kernel2);\nsol2 = @time solve(equation2, solver);\n\nfor ik = [7, 18, 25, 39]\n    Fk = get_F(sol2, 1:10:800, ik)\n    t = get_t(sol2)[1:10:800]\n    plot!(p, log10.(t), Fk/Sₖ[ik], label=false, lw=3, ls=:dash, c=:black)\nend\np","category":"page"},{"location":"Kernels.html","page":"Kernels","title":"Kernels","text":"(Image: image)","category":"page"},{"location":"MCT.html#Single-component-Mode-Coupling-Theory","page":"Mode-Coupling Theory","title":"Single-component Mode-Coupling Theory","text":"","category":"section"},{"location":"MCT.html","page":"Mode-Coupling Theory","title":"Mode-Coupling Theory","text":"The mode-coupling theory equation reads","category":"page"},{"location":"MCT.html","page":"Mode-Coupling Theory","title":"Mode-Coupling Theory","text":"ddotF(kt) + Omega(k)F(kt) + int_0^tdtau K(t-tau k)dotF(ktau)=0","category":"page"},{"location":"MCT.html","page":"Mode-Coupling Theory","title":"Mode-Coupling Theory","text":"in which Omega(k) = k^2 k_B TmS(k), and","category":"page"},{"location":"MCT.html","page":"Mode-Coupling Theory","title":"Mode-Coupling Theory","text":"K(kt) =fracrho k_BT16pi^3 m int dmathbfq V(mathbfk mathbfq)^2F(q t)F(mathbfk-mathbfqt)","category":"page"},{"location":"MCT.html","page":"Mode-Coupling Theory","title":"Mode-Coupling Theory","text":"in which the vertex V(textbfk textbfq) = (textbfkcdottextbfq)c(q)k+(textbfkcdot(textbfk-textbfq)c(textbfk-textbfq)k. For more details and the meaning of the symbols, see [1, 2].","category":"page"},{"location":"MCT.html","page":"Mode-Coupling Theory","title":"Mode-Coupling Theory","text":"This memory kernel integral is discretised as follows:","category":"page"},{"location":"MCT.html","page":"Mode-Coupling Theory","title":"Mode-Coupling Theory","text":"int dtextbfqf(q textbfk-textbfq) = 2piint_0^infty dq q^2 int_0^pi dtheta sin theta f(q textbfk-textbfq) = frac2pikint_0^infty dq int_k-q^k+qdp pq f(q p) approx frac2pi Delta k^2k_isum_j=1^N_k sum_l=j-i+1^j+i-1 fracp_l q_jk_if(q_j p_l)","category":"page"},{"location":"MCT.html","page":"Mode-Coupling Theory","title":"Mode-Coupling Theory","text":"in which p = textbfk-textbfq, and wave numbers k, q and p are discretized on the equidistant grid k_i = (i_k-frac12)Delta k where i_k = 1 2 3 ldots N_k. The double sum is then performed for all k using Bengtzelius' trick, yielding a fast O(N_k^2) algorithm. ","category":"page"},{"location":"MCT.html#Example","page":"Mode-Coupling Theory","title":"Example","text":"","category":"section"},{"location":"MCT.html","page":"Mode-Coupling Theory","title":"Mode-Coupling Theory","text":"\"\"\"\n    find_analytical_C_k(k, η)\nFinds the direct correlation function given by the \nanalytical Percus-Yevick solution of the Ornstein-Zernike \nequation for hard spheres for a given volume fraction η.\n\nReference: Wertheim, M. S. \"Exact solution of the Percus-Yevick integral equation \nfor hard spheres.\" Physical Review Letters 10.8 (1963): 321.\n\"\"\" \nfunction find_analytical_C_k(k, η)\n    A = -(1 - η)^-4 *(1 + 2η)^2\n    B = (1 - η)^-4*  6η*(1 + η/2)^2\n    D = -(1 - η)^-4 * 1/2 * η*(1 + 2η)^2\n    Cₖ = @. 4π/k^6 * \n    (\n        24*D - 2*B * k^2 - (24*D - 2 * (B + 6*D) * k^2 + (A + B + D) * k^4) * cos(k)\n     + k * (-24*D + (A + 2*B + 4*D) * k^2) * sin(k)\n     )\n    return Cₖ\nend\n\n\"\"\"\n    find_analytical_S_k(k, η)\nFinds the static structure factor given by the \nanalytical Percus-Yevick solution of the Ornstein-Zernike \nequation for hard spheres for a given volume fraction η.\n\"\"\" \nfunction find_analytical_S_k(k, η)\n        Cₖ = find_analytical_C_k(k, η)\n        ρ = 6/π * η\n        Sₖ = @. 1 + ρ*Cₖ / (1 - ρ*Cₖ)\n    return Sₖ\nend\n\n# We solve MCT for hard spheres at a volume fraction of 0.51591\nη = 0.51591; ρ = η*6/π; kBT = 1.0; m = 1.0\n\nNk = 100; kmax = 40.0; \ndk = kmax/Nk; k_array = dk*(collect(1:Nk) .- 0.5) # construct the grid this way to satisfy the assumtions\n                                                  # of the discretisation.\nSₖ = find_analytical_S_k(k_array, η)\n\n∂F0 = zeros(Nk); α = 1.0; β = 0.0; γ = @. k_array^2*kBT/(m*Sₖ); δ = 0.0\n\nkernel = ModeCouplingKernel(ρ, kBT, m, k_array, Sₖ)\nproblem = MemoryEquation(α, β, γ, δ, Sₖ, ∂F0, kernel)\nsolver = TimeDoublingSolver(Δt=10^-5, t_max=10.0^15, verbose=true, \n                     N = 8, tolerance=10^-8)\nsol = solve(problem, solver);\np = plot(xlabel=\"log10(t)\", ylabel=\"F(k,t)\", ylims=(0,1))\nfor ik = [7, 18, 25, 39]\n    Fk = get_F(sol, :, ik)\n    plot!(p, log10.(get_t(sol)), Fk/Sₖ[ik], label=\"k = $(k_array[ik])\", lw=3)\nend\np","category":"page"},{"location":"MCT.html","page":"Mode-Coupling Theory","title":"Mode-Coupling Theory","text":"(Image: image)","category":"page"},{"location":"MCT.html#References","page":"Mode-Coupling Theory","title":"References","text":"","category":"section"},{"location":"MCT.html","page":"Mode-Coupling Theory","title":"Mode-Coupling Theory","text":"[1] Reichman, David R., and Patrick Charbonneau. \"Mode-coupling theory.\" Journal of Statistical Mechanics: Theory and Experiment 2005.05 (2005): P05013.","category":"page"},{"location":"MCT.html","page":"Mode-Coupling Theory","title":"Mode-Coupling Theory","text":"[2] Janssen, Liesbeth MC. \"Mode-coupling theory of the glass transition: A primer.\" Frontiers in Physics 6 (2018): 97.","category":"page"},{"location":"MCT.html#TaggedModeCouplingKernel","page":"Mode-Coupling Theory","title":"TaggedModeCouplingKernel","text":"","category":"section"},{"location":"MCT.html","page":"Mode-Coupling Theory","title":"Mode-Coupling Theory","text":"Let's say we have just solved the mode-coupling equations, and we now want to include also a tagged particle solution (to find the self-intermediate scattering function). This function satisfies","category":"page"},{"location":"MCT.html","page":"Mode-Coupling Theory","title":"Mode-Coupling Theory","text":"ddotF_s(kt) + frack^2 k_BTm F_s(kt) + int_0^t dtau K(k t-tau)dotF_s(k tau)=0","category":"page"},{"location":"MCT.html","page":"Mode-Coupling Theory","title":"Mode-Coupling Theory","text":"in which","category":"page"},{"location":"MCT.html","page":"Mode-Coupling Theory","title":"Mode-Coupling Theory","text":"K(kt) = fracrho k_BT8pi^3 mint dmathbfq V(mathbfk mathbfq)^2 F(q t)F_s(mathbfk-mathbfqt)","category":"page"},{"location":"MCT.html","page":"Mode-Coupling Theory","title":"Mode-Coupling Theory","text":"where","category":"page"},{"location":"MCT.html","page":"Mode-Coupling Theory","title":"Mode-Coupling Theory","text":"V(textbfk textbfq) = (textbfkcdottextbfq)c(q)k = frack^2+q^2-p^22k cdot c(q)","category":"page"},{"location":"MCT.html","page":"Mode-Coupling Theory","title":"Mode-Coupling Theory","text":"are the tagged vertices. This is done using the TaggedModeCouplingKernel.","category":"page"},{"location":"MCT.html","page":"Mode-Coupling Theory","title":"Mode-Coupling Theory","text":"Example (excluding the code from collective MCT):","category":"page"},{"location":"MCT.html","page":"Mode-Coupling Theory","title":"Mode-Coupling Theory","text":"taggedF0 = ones(Nk); tagged∂F0 = zeros(Nk); α = 1.0; β = 0.0; γ = @. k_array^2*kBT/m; δ = 0.0\n\ntaggedkernel = TaggedModeCouplingKernel(ρ, kBT, m, k_array, Sₖ, sol)\ntaggedequation = MemoryEquation(α, β, γ, δ, taggedF0, tagged∂F0, taggedkernel)\ntaggedsol = solve(taggedequation, solver)","category":"page"},{"location":"MCT.html#Mean-squared-displacement-(MSD)","page":"Mode-Coupling Theory","title":"Mean squared displacement (MSD)","text":"","category":"section"},{"location":"MCT.html","page":"Mode-Coupling Theory","title":"Mode-Coupling Theory","text":"From the tagged particle dynamics we just computed, we can evaluate the MSD, as a low k limit. The equations that it satisfies are","category":"page"},{"location":"MCT.html","page":"Mode-Coupling Theory","title":"Mode-Coupling Theory","text":"ddotdelta r^2(t) - frac6 k_BTm  + int_0^t dtau K(k t-tau)deltadot r^2(tau)=0","category":"page"},{"location":"MCT.html","page":"Mode-Coupling Theory","title":"Mode-Coupling Theory","text":"where","category":"page"},{"location":"MCT.html","page":"Mode-Coupling Theory","title":"Mode-Coupling Theory","text":"K(t) = fracrho k_BT6pi^2 mint_0^infty dq q^4c(q)^2F(qt)F_s(qt)","category":"page"},{"location":"MCT.html","page":"Mode-Coupling Theory","title":"Mode-Coupling Theory","text":"This kernel is implemented in the MSDModeCouplingKernel","category":"page"},{"location":"MCT.html","page":"Mode-Coupling Theory","title":"Mode-Coupling Theory","text":"Example:","category":"page"},{"location":"MCT.html","page":"Mode-Coupling Theory","title":"Mode-Coupling Theory","text":"MSD0 = 0.0; dMSD0 = 0.0; α = 1.0; β = 0.0; γ = 0.0; δ = -6.0*kBT/m;\nmsdkernel = MSDModeCouplingKernel(ρ, kBT, m, k_array, Sₖ, sol, taggedsol)\nmsdequation = MemoryEquation(α, β, γ, δ, MSD0, dMSD0, msdkernel)\nmsdsol = solve(msdequation, solver)\n\nplot(log10.(msdsol.t), log10.(msdsol.F), xlabel=\"log(t)\", ylabel=\"log(MSD(t))\", xlims=(-5,15), label=false)","category":"page"},{"location":"MCT.html","page":"Mode-Coupling Theory","title":"Mode-Coupling Theory","text":"(Image: image)","category":"page"},{"location":"MCT.html#Multi-component-Mode-Coupling-Theory","page":"Mode-Coupling Theory","title":"Multi-component Mode-Coupling Theory","text":"","category":"section"},{"location":"MCT.html","page":"Mode-Coupling Theory","title":"Mode-Coupling Theory","text":"The multi-component mode-coupling theory equation reads","category":"page"},{"location":"MCT.html","page":"Mode-Coupling Theory","title":"Mode-Coupling Theory","text":"ddotF_alphabeta(kt) + Omega^2_alphagamma(k)F_gammabeta(kt) + int_0^tdtau K_alphagamma(t-tau k)dotF_gammabeta(k tau)=0","category":"page"},{"location":"MCT.html","page":"Mode-Coupling Theory","title":"Mode-Coupling Theory","text":"in which Omega^2_alphagamma = k^2 k_B T x_alpham_alpha cdot left(S^-1right)_alphagamma(k), and (textbfS)^-1(k) = (fracdelta_alphabetax_alpha - rho c_alphagamma(k)). The memory kernel is given by","category":"page"},{"location":"MCT.html","page":"Mode-Coupling Theory","title":"Mode-Coupling Theory","text":"K_alphabeta(kt) =frack_B T rho2 x_beta m_alpha (2pi)^3 int dmathbfq V_munualpha(mathbfk mathbfq)F_mumu(q t)F_nunu(mathbfk-mathbfqt)V_munubeta(mathbfk mathbfq)","category":"page"},{"location":"MCT.html","page":"Mode-Coupling Theory","title":"Mode-Coupling Theory","text":"in which the vertex V_munualpha(mathbfk mathbfq) = (textbfkcdottextbfq)c_alphamu(q)delta_alphanuk+(textbfkcdot(textbfk-textbfq)c_alphanu(textbfk-textbfq)delta_alphamuk. Here, the Greek indices indicate species labels, and we have adopted the convention that we sum over repeated indices. This memory kernel has also been implemented using the Bengtzelius' trick. It requires O(N_k^2 N_s^2) storage and runs in O(N_k^2 N_s^4) in which N_s is the number of species.","category":"page"},{"location":"MCT.html","page":"Mode-Coupling Theory","title":"Mode-Coupling Theory","text":"Numerically, the correlator F_alphabeta(k) is implemented as a Vector of length Nk of which each of the elements is a small Ns x Ns static matrix. This means that this is also the expected form of the initial condition. If, instead you have the data in a matrix format where each element of the matrix is a list of k-vales, use the convert_multicomponent_structure_factor(S) function to convert it into the right format, see the API page. ","category":"page"},{"location":"MCT.html","page":"Mode-Coupling Theory","title":"Mode-Coupling Theory","text":"All symbols have the same meaning as those presented in \"Weysser, F., Puertas, A. M., Fuchs, M., & Voigtmann, T. (2010). Structural relaxation of polydisperse hard spheres: Comparison of the mode-coupling theory to a Langevin dynamics simulation. Physical review E, 82(1), 011504.\"","category":"page"},{"location":"MCT.html#Example-2","page":"Mode-Coupling Theory","title":"Example","text":"","category":"section"},{"location":"MCT.html","page":"Mode-Coupling Theory","title":"Mode-Coupling Theory","text":"using StaticArrays, LinearAlgebra, DelimitedFiles\n# number of species Ns, number of wave numbers Nk, volume fraction η\n# thermal energy kBT and mass m\nNs = 2; Nk = 100; η  = 0.515; kBT = 1.0; m = ones(Ns)\nparticle_diameters = [0.8,1.0]\nx = [0.2,0.8] # species fraction\n\n# total density\nρ_all = 6η/(π*sum(x .* particle_diameters .^ 3))\nρ = ρ_all * x\n\nkmax = 40.0; dk = kmax/Nk\nk_array = dk*(collect(1:Nk) .- 0.5)\n\n# data can be found in the \\test\\ folder of the source code\nSₖdata = reshape(readdlm(\"test/Sk_MC.txt\"), (2,2,100))\n# convert the data to the Vector of SMatrix format\nSₖ = [@SMatrix(zeros(Ns, Ns)) for i = 1:Nk]\nfor i = 1:Nk\n    Sₖ[i] = Sₖdata[:, :, i]\nend\nS⁻¹ = inv.(Sₖ)\n\nJ = similar(Sₖ) .* 0.0\nfor ik = 1:Nk\n    J[ik] = kBT*k_array[ik]^2 * x ./ m .* I(Ns)\nend\n\nF₀ = copy(Sₖ)\n∂ₜF₀ = [@SMatrix(zeros(Ns, Ns)) for i = 1:Nk]\nα = 1.0\nβ = 0.0\nΩ2 = similar(Sₖ)\nfor ik = 1:Nk\n    Ω2 .= J.*S⁻¹\nend\nδ = @SMatrix zeros(Ns, Ns)\n\nkernel = MultiComponentModeCouplingKernel(ρ, kBT, m, k_array, Sₖ)\nproblem = MemoryEquation(α, β, Ω2, δ, F₀, ∂ₜF₀, kernel)\nsolver = TimeDoublingSolver(verbose=false, N=16, tolerance=10^-8, max_iterations=10^8)\nsol = solve(problem, solver)\nik = 19\nk = k_array[ik]\nt = get_t(sol)\n\nFk_11 = get_F(:, ik, (1,1))\nFk_12 = get_F(:, ik, (1,2))\nFk_21 = get_F(:, ik, (2,1))\nFk_22 = get_F(:, ik, (2,2))\n\np = plot(log10.(t), Fk_11/Sₖ[ik][1,1], ls=:dash, lw=2, color=1, label=\"Faa(k=$k, t)\") \nplot!(log10.(t), Fk_12/Sₖ[ik][1,2], lw=2, color=2, label=\"Fab(k=$k, t)\") \nplot!(log10.(t), Fk_21/Sₖ[ik][2,1], ls=:dash, lw=2, color=3, label=\"Fba(k=$k, t)\") \nplot!(log10.(t), Fk_22/Sₖ[ik][2,2], ls=:dash, lw=2, color=4, label=\"Fbb(k=$k, t)\")","category":"page"},{"location":"MCT.html","page":"Mode-Coupling Theory","title":"Mode-Coupling Theory","text":"(Image: image)","category":"page"},{"location":"MCT.html#Tagged-multi-compontent-mode-coupling-theory","page":"Mode-Coupling Theory","title":"Tagged multi-compontent mode-coupling theory","text":"","category":"section"},{"location":"MCT.html","page":"Mode-Coupling Theory","title":"Mode-Coupling Theory","text":"The tagged multi-component mode-coupling theory equation reads","category":"page"},{"location":"MCT.html","page":"Mode-Coupling Theory","title":"Mode-Coupling Theory","text":"dotF_s(kt) + Omega_s^2(k)F_s(kt) + int_0^tdtau K_s(t-tau k)dotF_s(k tau)=0","category":"page"},{"location":"MCT.html","page":"Mode-Coupling Theory","title":"Mode-Coupling Theory","text":"for a particle of species s in which Omega_s^2 = k^2 k_B Tm_s. The memory kernel is given by","category":"page"},{"location":"MCT.html","page":"Mode-Coupling Theory","title":"Mode-Coupling Theory","text":"K_s(kt) =frack_B T rhok^3m_s (2pi)^3 sum_alphabetaint dmathbfq left(textbfkcdottextbfqright)^2C_salpha(q)C_sbeta(q)F_alphabeta(q t)F_s(mathbfk-mathbfqt)","category":"page"},{"location":"MCT.html","page":"Mode-Coupling Theory","title":"Mode-Coupling Theory","text":"Here F_s is the tagged correlator, with initial condition F_s(t=0)=1, and F_alphabeta is the collective correlator which can be obtained as explained in the previous section.","category":"page"},{"location":"MCT.html#Example-3","page":"Mode-Coupling Theory","title":"Example","text":"","category":"section"},{"location":"MCT.html","page":"Mode-Coupling Theory","title":"Mode-Coupling Theory","text":"# we look for the tagged correlator of the second species.\ns = 2\nα = 1.0\nβ = 0.0\nγ = [kBT * k_array[ik]^2 ./ m[s] for ik = 1:Nk]\nδ = 0.0\nF0 = [1.0 for ik = 1:Nk]\ndF0 = [0.0 for ik = 1:Nk]\n\ntaggedkernel = TaggedMultiComponentModeCouplingKernel(s, ρ, kBT, m, k_array, Sₖ, sol);\ntaggedequation = MemoryEquation(α, β, γ, δ, F0, dF0, taggedkernel);\ntaggedsol = solve(taggedequation, solver)","category":"page"},{"location":"MCT.html","page":"Mode-Coupling Theory","title":"Mode-Coupling Theory","text":"In order to solve the tagged particle equation for all species, one should loop over the above code, changing specie index s from 1 to the number of species.","category":"page"},{"location":"MCT.html#Multi-component-mean-squared-displacements","page":"Mode-Coupling Theory","title":"Multi-component mean-squared displacements","text":"","category":"section"},{"location":"MCT.html","page":"Mode-Coupling Theory","title":"Mode-Coupling Theory","text":"The equation for the mean squared displacement in a multicomponent system reads","category":"page"},{"location":"MCT.html","page":"Mode-Coupling Theory","title":"Mode-Coupling Theory","text":"delta dotr_s^2(t) -frac6k_BTm_s + int_0^tdtau K_s(t-tau)delta dotr_s^2(tau)=0","category":"page"},{"location":"MCT.html","page":"Mode-Coupling Theory","title":"Mode-Coupling Theory","text":"for a particle of species s. The memory kernel is given by","category":"page"},{"location":"MCT.html","page":"Mode-Coupling Theory","title":"Mode-Coupling Theory","text":"K_s(t) = fracrho k_BT6pi^2 m_ssum_alphabetaint_0^infty dq q^4c_salpha(q)c_sbeta(q)F_alphabeta(qt)F^(s)_s(qt)","category":"page"},{"location":"MCT.html","page":"Mode-Coupling Theory","title":"Mode-Coupling Theory","text":"Here delta r_s^2(t) is the MSD of species s, with initial condition delta r_s^2(t=0)=0, and delta dotr_s^2(t=0)=0. This kernel is implemented using the MSDMultiComponentModeCouplingKernel","category":"page"},{"location":"MCT.html#Example-4","page":"Mode-Coupling Theory","title":"Example","text":"","category":"section"},{"location":"MCT.html","page":"Mode-Coupling Theory","title":"Mode-Coupling Theory","text":"# we look for the tagged correlator of the second species.\ns = 2\nα = 1.0\nβ = 0.0\nγ = 0.0\nδ = -6*kBT / m[s]\nmsd0 = 0.0\ndmsd0 = 0.0\n\nmsdkernel = MSDMultiComponentModeCouplingKernel(s, ρ, kBT, m, k_array, Sₖ, sol, taggedsol);\nmsdequation = MemoryEquation(α, β, γ, δ, msd0, dmsd0, msdkernel);\nmsdsol = solve(msdequation, solver)","category":"page"},{"location":"MCT.html#Bengtzelius'-Trick","page":"Mode-Coupling Theory","title":"Bengtzelius' Trick","text":"","category":"section"},{"location":"MCT.html","page":"Mode-Coupling Theory","title":"Mode-Coupling Theory","text":"Bengtzelius' trick is a fast way to evaluate the integral I(k) = int d mathbfq A(q mathbfk-mathbfq). It is used in the evaluation of all memory kernels listed on this page. Very briefly: after discretisation of the integral, one is left with terms such as T_iA=sum_j=1^N_ksum_l=j-i+1^i+j-1  A(p_lq_j) which are largely independent of i. Because of this, one can calculate T_iA from T_i-1A in order N_k operations. The recurrence relation that allows one to do so is given by ","category":"page"},{"location":"MCT.html","page":"Mode-Coupling Theory","title":"Mode-Coupling Theory","text":"T_iA = T_i-1A + sum_j=1^N_k-i+1(A(j j+i-1)+A(j+i-1 j)) - sum_j=1^i-1A(ji-j)","category":"page"},{"location":"MCT.html","page":"Mode-Coupling Theory","title":"Mode-Coupling Theory","text":"with initial condition","category":"page"},{"location":"MCT.html","page":"Mode-Coupling Theory","title":"Mode-Coupling Theory","text":"T_1A = sum_j=1^N_kA(j j)","category":"page"},{"location":"Problems_and_Solvers.html#Equations","page":"Equations and Solvers","title":"Equations","text":"","category":"section"},{"location":"Problems_and_Solvers.html","page":"Equations and Solvers","title":"Equations and Solvers","text":"The most straightforward workflow for solving MCT-like equations is to construct objects that represent the memory kernel (of type MemoryKernel), the equation to solve (of type AbstractMemoryEquation), and optionally the solver (of type Solver), in that order. The MemoryKernel is an object that is passed to the function evaluate_kernel to compute the memory kernel. The AbstractMemoryEquation holds the coefficients, initial conditions, and the just defined MemoryKernel belonging to the equation that needs to be solved, and the Solver stores information related to the numerical integration procedure, such as the time step. Once these three objects have been defined, the function solve(::AbstractMemoryEquation, ::Solver) can be called on them to solve the equation","category":"page"},{"location":"Problems_and_Solvers.html","page":"Equations and Solvers","title":"Equations and Solvers","text":"alpha ddotF(t) + beta dotF(t) + gamma F(t) + δ + int_0^t dtau K(t-tau)dotF(tau) = 0","category":"page"},{"location":"Problems_and_Solvers.html","page":"Equations and Solvers","title":"Equations and Solvers","text":"A MemoryEquation defined by the equation above is constructed by the constructor MemoryEquation(α, β, γ, δ, F₀, ∂ₜF₀, kernel::MemoryKernel). Here, F₀ and ∂ₜF₀ are the initial conditions of F and its time derivative. In the case of vector-valued functions F, this package requires that the operation α*F is defined and that it returns the same type as F. This means that in general, when F is a vector, α must either be a matrix with a compatible element type, or a scalar. However, because it is common in practice to find equations in which α and F are both vectors (such that the multiplication α*F is understood to be conducted element-wise), vector-valued αs will automatically be promoted to diagonal matrices. β and γ are treated in the same way. δ must be additively compatible with F.","category":"page"},{"location":"Problems_and_Solvers.html#Examples","page":"Equations and Solvers","title":"Examples","text":"","category":"section"},{"location":"Problems_and_Solvers.html","page":"Equations and Solvers","title":"Equations and Solvers","text":"Scalar problems are the most straightforward:","category":"page"},{"location":"Problems_and_Solvers.html","page":"Equations and Solvers","title":"Equations and Solvers","text":"kernel = SchematicF1Kernel(0.2); # in the next page of the documentation we will \n                                 # explain how to construct memory kernels\nα = 1.0; β = 0.0; γ = 1.0; δ =0.0, F0 = 1.0; ∂F0 = 0.0;\nproblem = MemoryEquation(α, β, γ, δ, F0, ∂F0, kernel)","category":"page"},{"location":"Problems_and_Solvers.html","page":"Equations and Solvers","title":"Equations and Solvers","text":"For vector-valued problems, the coefficients can be scalar, vector or matrix-valued. They are automatically promoted to make linear algebra work:","category":"page"},{"location":"Problems_and_Solvers.html","page":"Equations and Solvers","title":"Equations and Solvers","text":"julia> N = 5;\njulia> kernel = SchematicDiagonalKernel(rand(N)); # again, ignore this for now\njulia> α = 1.0; β = rand(N); γ = rand(N,N); δ = 0.0; F0 = ones(N); ∂F0 = zeros(N);\njulia> problem = MemoryEquation(α, β, γ, δ, F0, ∂F0, kernel);\n\njulia> problem.coeffs.α # a scalar is promoted to a multiple of the identity matrix\nLinearAlgebra.UniformScaling{Float64}\n1.0*I\n\njulia> problem.coeffs.β # a vector is promoted to a diagonal matrix\n5×5 LinearAlgebra.Diagonal{Float64, Vector{Float64}}:\n 0.789182   ⋅         ⋅        ⋅         ⋅\n  ⋅        0.379832   ⋅        ⋅         ⋅\n  ⋅         ⋅        0.50589   ⋅         ⋅\n  ⋅         ⋅         ⋅       0.241663   ⋅\n  ⋅         ⋅         ⋅        ⋅        0.857202\n\njulia> problem.coeffs.γ # a matrix is already in the right format\n5×5 Matrix{Float64}:\n 0.746936  0.963531  0.724356  0.31979   0.600617\n 0.731198  0.217209  0.603705  0.373079  0.930195\n 0.464137  0.670576  0.973505  0.23666   0.536108\n 0.40188   0.797017  0.332496  0.841541  0.434256\n 0.401826  0.303485  0.238624  0.239107  0.453554\n\n julia> problem.coeffs.δ\n5-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0","category":"page"},{"location":"Problems_and_Solvers.html#Limitations","page":"Equations and Solvers","title":"Limitations","text":"","category":"section"},{"location":"Problems_and_Solvers.html","page":"Equations and Solvers","title":"Equations and Solvers","text":"This package is not tested for and is not expected to work when the type of F is something other than a Number, Vector or SVector. For example, using types like OffsetArrays as initial conditions might lead to unexpected behaviour.","category":"page"},{"location":"Problems_and_Solvers.html#Solvers","page":"Equations and Solvers","title":"Solvers","text":"","category":"section"},{"location":"Problems_and_Solvers.html","page":"Equations and Solvers","title":"Equations and Solvers","text":"A Solver object holds the settings for a specific integration method. This package defines two solvers: EulerSolver and TimeDoublingSolver. The EulerSolver implements a simple forward Euler method (with trapezoidal integration) which is wildly inefficient if the domain of t spans many orders of magnitude (such as it often does in Mode-Coupling Theory). It should therefore mainly be used for testing purposes. The TimeDoublingSolver is preferred in almost all other cases. The scheme it implements is outlined in [1] and in the appendix of [2]. If no solver is provided to a solve call, the default TimeDoublingSolver is used.","category":"page"},{"location":"Problems_and_Solvers.html","page":"Equations and Solvers","title":"Equations and Solvers","text":"In short, the equation is discretised and solved on a grid of 4N time-points, which are equally spaced over an interval Δt. It is solved using an implicit method, and thus a fixed point has to be found for each time point. This is done by recursive iteration. When the solution is found, the interval is doubled Δt => 2Δt and the solution on the previous grid is mapped onto the first 2N time points of the new grid. The solution on the other2N points is again found by recursive iteration. This is repeated until some final time t_max is reached.","category":"page"},{"location":"Problems_and_Solvers.html","page":"Equations and Solvers","title":"Equations and Solvers","text":"A TimeDoublingSolver is constructed as follows:","category":"page"},{"location":"Problems_and_Solvers.html","page":"Equations and Solvers","title":"Equations and Solvers","text":"julia> kernel = SchematicF1Kernel(0.2);\njulia> α = 1.0; β = 0.0; γ = 1.0; δ = 0.0; F0 = 1.0; ∂F0 = 0.0;\njulia> problem = MemoryEquation(α, β, γ, δ, F0, ∂F0, kernel);\njulia> solver1 = TimeDoublingSolver() # using all default parameters\njulia> solver2 = TimeDoublingSolver(N=128, Δt=10^-5, \n                            t_max=10.0^15, max_iterations=10^8, \n                            tolerance=10^-6, verbose=true)","category":"page"},{"location":"Problems_and_Solvers.html","page":"Equations and Solvers","title":"Equations and Solvers","text":"As optional keyword arguments TimeDoublingSolver accepts:","category":"page"},{"location":"Problems_and_Solvers.html","page":"Equations and Solvers","title":"Equations and Solvers","text":"N: The number of time points in the interval is equal to 4N. default = 32\nt_max: when this time value is reached, the integration returns. default = 10.0^10\nΔt: starting time interval, this will be doubled repeatedly. default = 10^-10\nmax_iterations: the maximal number of iterations before convergence is reached for each time doubling step. default = 10^4\ntolerance: while the error of the recursive iteration is bigger than this value, convergence is not reached. The error by default is computed as the absolute sum of squared differences. default = 10^-10\nverbose: if true, some information will be printed. default = false\ninplace: if true and if the type of F is mutable, the solver will try to avoid allocating many temporaries. default = true","category":"page"},{"location":"Problems_and_Solvers.html","page":"Equations and Solvers","title":"Equations and Solvers","text":"Having defined a MemoryKernel, AbstractMemoryEquation and a Solver, one can call sol = solve(problem, solver) to solve the problem. It outputs an object sol that contains a Vector sol.t of time points and the solution sol.F and memory kernel sol.K evaluated at those times points. They can be extracted with get_t(sol), get_F(sol) and get_K(sol), respectively. These functions also allow for easy indexing. For example, suppose one has obtained the solution to a vector-valued equation, then extracting the solution over time of the second equation can be done with get_F(sol, :, 2). If instead one wants to extract the solution at the 53th time point for all equations, one may run get_F(sol, 53, :).","category":"page"},{"location":"Problems_and_Solvers.html#References","page":"Equations and Solvers","title":"References","text":"","category":"section"},{"location":"Problems_and_Solvers.html","page":"Equations and Solvers","title":"Equations and Solvers","text":"[1] Fuchs, Matthias, et al. \"Comments on the alpha-peak shapes for relaxation in supercooled liquids.\" Journal of Physics: Condensed Matter 3.26 (1991): 5047.","category":"page"},{"location":"Problems_and_Solvers.html","page":"Equations and Solvers","title":"Equations and Solvers","text":"[2] Flenner, Elijah, and Grzegorz Szamel. \"Relaxation in a glassy binary mixture: Comparison of the mode-coupling theory to a Brownian dynamics simulation.\" Physical Review E 72.3 (2005): 031508.","category":"page"},{"location":"FromPython.html#Calling-from-Python","page":"From Python","title":"Calling from Python","text":"","category":"section"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"Using ModeCouplingTheory from Python can be useful for solving mode-coupling theory repeatedly or for large systems of equations, making the overhead of initializing Julia negligible. (Or perhaps if one prefers to work in Python.)","category":"page"},{"location":"FromPython.html#Installing","page":"From Python","title":"Installing","text":"","category":"section"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"First, install juliacall through the pip package manager, with","category":"page"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"pip install juliacall","category":"page"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"This package allows one to call julia from python ","category":"page"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"In Python (only versions geq 3 are supported), run:","category":"page"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"from juliacall import Main as jl","category":"page"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"which will install the latest stable version of Julia the first time it is called. Now install ModeCouplingTheory.jl, with","category":"page"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"\njl.Pkg.add(\"ModeCouplingTheory\")","category":"page"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"To import this package in order to use it we need to run:","category":"page"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"jl.seval(\"using ModeCouplingTheory\")","category":"page"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"The jl.seval function let's us evaluate any julia code from within Python.","category":"page"},{"location":"FromPython.html#Usage","page":"From Python","title":"Usage","text":"","category":"section"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"We can now use ModeCouplingTheory.jl in Python:","category":"page"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"# since Python doesn't like all unicode symbols (α, β, ∂, ...), we use standard letters:\nk = 3.99999\na = 1.0\nb = 0.0\nc = 1.0\nd = 0.0\nF0 = 1.0\ndF0 = 0.0\nkernel = jl.SchematicF2Kernel(k)\nproblem = jl.MemoryEquation(a, b, c, d, F0, dF0, kernel)\nsol = jl.solve(problem)\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nt = jl.get_t(sol)\nF = jl.get_F(sol)\nplt.plot(np.log10(t), F)\nplt.show()","category":"page"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"et voilà!","category":"page"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"(Image: image)","category":"page"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"See the documentation of juliacall for more information on how to call Julia from Python.","category":"page"},{"location":"Scope.html#Time-dependent-coefficients","page":"Scope","title":"Time-dependent coefficients","text":"","category":"section"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"In order to allow the coefficients alpha, beta, gamma, and delta to have a time dependence, the constructor of MemoryEquation allows for an optional keyword argument update_coefficients!, which should be a user-defined function that updates the coefficient struct given a value of t. Make sure, when updating the coefficients, that their type does not change. The type of the coefficients can be inspected in the coeffs field of a MemoryEquation object.","category":"page"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"The default is that all coefficients are independent of time, that is: update_coefficients! = (coeffs, t) -> nothing. ","category":"page"},{"location":"Scope.html#Example","page":"Scope","title":"Example","text":"","category":"section"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"Let's say we want the coefficient γ to be equal to 2 + cos(sqrt(t)), this can be achieved like this:","category":"page"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"α=1.0, β=0.0, γ=3.0, δ=0.0; F0=1.0; dF0=0.0\nkernel = SchematicF2Kernel(3.9)\n\nfunction myfunc(coeffs, t)\n    coeffs.γ = 2+cos(sqrt(t))\nend\n\nMemoryEquation(α, β, γ, δ, F0, ∂F0, kernel; update_coefficients! = myfunc)","category":"page"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"Alternatively, let's say we want to solve  ddotF + F - t = 0, which has the analytical solution F(t) = t + cos(t) - sin(t)","category":"page"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"import ModeCouplingTheory: MemoryKernel, evaluate_kernel\nfunction myfunc(coeffs, t)\n    coeffs.δ = -t\nend\nstruct ZeroKernel <: MemoryKernel end\nevaluate_kernel(::ZeroKernel, _, _) = 0.0\nα = 1.0; β = 0.0; γ = 1.0; δ = 0.0; F0 = 1.0; dF0 = 0.0; kernel = ZeroKernel()\nequation = MemoryEquation(α, β, γ, δ, F0, dF0, kernel; update_coefficients! = myfunc)\nsolver = TimeDoublingSolver(t_max = 10.0^3, N = 600, Δt = 10^-4)\nsol = solve(equation, solver)\nt = sol.t; F = sol.F\nplot(log10.(t), log10.(F), lw=3)\nplot!(log10.(t), log10.(t .+ cos.(t) .- sin.(t)), ls=:dash, lw=3)","category":"page"},{"location":"Scope.html#Automatic-differentiation","page":"Scope","title":"Automatic differentiation","text":"","category":"section"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"This package is compatible with forward-mode automatic differentiation. This makes it possible to calculate quatities such as fracdF(t)dlambda for example, where lambda is a parameter of the memory kernel.","category":"page"},{"location":"Scope.html#Example-2","page":"Scope","title":"Example","text":"","category":"section"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"Let's take the derivative of the solution to the generalized Langevin equation with the exponentially decaying kernel with respect to the coupling parameter. First we need to write a function that solves this equation and outputs the solution for a given coupling parameter. Since we know the analytical solution, we can compare with the derivative of that.","category":"page"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"using ModeCouplingTheory, Plots\nfunction my_func(λ)\n    F0 = 1.0\n    ∂F0 = 0.0\n    α = 0.0\n    β = 1.0\n    γ = 1.0\n    δ = 0.0\n    kernel = ExponentiallyDecayingKernel(λ, 1.0)\n    problem = MemoryEquation(α, β, γ, δ, F0, ∂F0, kernel)\n    solver = TimeDoublingSolver(Δt=10^-4, t_max=5*10.0^1, verbose=false, N = 128, tolerance=10^-10, max_iterations=10^6)\n\n    sol =  solve(problem, solver)\n    return sol\nend\n\nfunction exact_func(λ, t)\n    temp = sqrt(λ*(λ+4)) \n    F = @. exp(-0.5* t*(temp+λ+2)) * (temp*(exp(temp*t)+1)+ λ* (exp(temp*t)-1)) / (2temp) \n    return [t, F]\nend\n\nsol = my_func(5.0)\ntexact, Fexact = exact_func(5.0, t)\n\np = plot(log10.(texact), Fexact, label=\"Exact\", lw=4) \nscatter!(log10.(sol.t[1:100:end]), sol.F[1:100:end], label=\"Numerical solution\", ls=:dash, lw=4) ","category":"page"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"(Image: image)","category":"page"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"Now we can take the derivative with respect to the argument of the functions we defined:","category":"page"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"using ForwardDiff\n_, dF_exact = ForwardDiff.derivative(y -> exact_func(y, t), 5.0)\nsol = ForwardDiff.derivative(my_func, 5.0)\n\np = plot(log10.(texact), dF_exact, lw=3, label=\"Exact\", ylabel=\"dF/dλ(λ=5,t)\", xlabel=\"log10(t)\") \nplot!(log10.(sol.t), sol.dF, ls=:dash, lw=3, label=\"Numerical solution\", legend=:topleft)","category":"page"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"(Image: image)","category":"page"},{"location":"Scope.html#Measurement-errors-and-other-number-types","page":"Scope","title":"Measurement errors and other number types","text":"","category":"section"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"Similar to automatically evaluating derivatives, it is also possible to automatically propagate measurement errors through the entire solution process. This does however cause a serious performace loss. It works by instead of doing arithmetic with standard floating point numbers, it uses numbers with an error attached. The  Measurements.jl package implements how arithmetic with such numbers should be performed. Analagously, one can use arbitrary precision arithmetic (when many decimal places of precision are required) or complex valued numbers together with this package.","category":"page"},{"location":"Scope.html#Example-3","page":"Scope","title":"Example","text":"","category":"section"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"Let's solve standard mode-coupling theory with a structure factor that contains measurement errors. To generate such a structure factor, we can use the analytical Percus-Yevick expression, but pretend there is an uncertainty in the volume fraction eta.","category":"page"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"\njulia> using ModeCouplingTheory, Plots, Measurements\n\njulia> η = 0.51 ± 0.01\n0.51 ± 0.05\n\njulia> ρ = η*6/π\n0.974 ± 0.019\n\njulia> kBT = 1.0; m = 1.0;\n\njulia> Nk = 100; kmax = 40.0; dk = kmax/Nk; k_array = dk*(collect(1:Nk) .- 0.5);","category":"page"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"We use the same functions to find the structure factor as before:","category":"page"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"\"\"\"\nFinds the fourier transform of the direct correlation function given by the \nanalytical percus yevick solution of the Ornstein Zernike \nequation for hard spheres for a given volume fraction η on the coordinates r\nin units of one over the diameter of the particles\n\"\"\" \nfunction find_analytical_C_k(k, η)\n    A = -(1 - η)^-4 *(1 + 2η)^2\n    B = (1 - η)^-4*  6η*(1 + η/2)^2\n    D = -(1 - η)^-4 * 1/2 * η*(1 + 2η)^2\n    Cₖ = @. 4π/k^6 * \n    (\n        24*D - 2*B * k^2 - (24*D - 2 * (B + 6*D) * k^2 + (A + B + D) * k^4) * cos(k)\n     + k * (-24*D + (A + 2*B + 4*D) * k^2) * sin(k)\n     )\n    return Cₖ\nend\n\n\"\"\"\nFinds the static structure factor given by the \nanalytical percus yevick solution of the Ornstein Zernike \nequation for hard spheres for a given volume fraction η on the coordinates r\nin units of one over the diameter of the particles\n\"\"\" \nfunction find_analytical_S_k(k, η)\n        Cₖ = find_analytical_C_k(k, η)\n        ρ = 6/π * η\n        Sₖ = @. 1 + ρ*Cₖ / (1 - ρ*Cₖ)\n    return Sₖ\nend\n\njulia> Sₖ_uncertain = find_analytical_S_k(k_array, ρ*π/6)\n100-element Vector{Measurement{Float64}}:\n  0.0142 ± 0.0014\n  0.0145 ± 0.0015\n  0.0152 ± 0.0015\n  0.0163 ± 0.0017\n         ⋮\n  1.0154 ± 0.0012\n  0.9987 ± 0.00012\n 0.98327 ± 0.00089\n\njulia> plot(k_array, Sₖ_uncertain, xlabel=\"k\", ylabel=\"S(k)\", legend=false)","category":"page"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"(Image: image)","category":"page"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"Now we can use this structure factor to solve the mode-coupling equation as usual.","category":"page"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"# The initial condition of the derivative must have the same type as the initial condition itself\n∂F0 = zeros(eltype(Sₖ_uncertain), Nk)\nα = 1.0; β = 0.0; γ = @. k_array^2*kBT/(m*Sₖ_uncertain); δ = 0.0\nkernel = ModeCouplingKernel(ρ, kBT, m, k_array, Sₖ_uncertain)\nproblem = MemoryEquation(α, β, γ, δ, Sₖ_uncertain, ∂F0, kernel)\nsolver = TimeDoublingSolver(Δt=10^-5, t_max=10.0^5, verbose=true, N = 8, tolerance=10^-8, max_iterations=10^8)\nsol = @time solve(problem, solver);\np = plot(xlabel=\"log10(t)\", ylabel=\"F(k,t)\", ylims=(0,1), xlims=(-5,5))\nplot!(p, log10.(get_t(sol)[2:10:end]), get_F(sol, :, 19)/Sₖ_uncertain[19], label=\"k = $(k_array[19])\", lw=3)","category":"page"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"(Image: image)","category":"page"},{"location":"Scope.html#Steady-state-(non-ergodicity-parameter)","page":"Scope","title":"Steady state (non-ergodicity parameter)","text":"","category":"section"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"This package also exports a function solve_steady_state(γ, F₀, kernel; tolerance=10^-8, max_iterations=10^6, verbose=false) to find the steady-state solution of a mode-coupling like equation. In order to find it, it performs a recursive iteration of the mapping ","category":"page"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"F^infty = (K(F^inftyt=infty) + γ)^-1 cdot K(F^infty t=infty) cdot F(t=0)","category":"page"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"It returns a MemoryEquationSolution object defined at one time t=infty, which contains both F(t=infty) and K(t=infty) as fields.","category":"page"},{"location":"Scope.html#Example-4","page":"Scope","title":"Example","text":"","category":"section"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"using ModeCouplingTheory, Plots\nη = 0.51595; ρ = η*6/π; kBT = 1.0; m = 1.0\nNk = 100; kmax = 40.0; dk = kmax/Nk; k_array = dk*(collect(1:Nk) .- 0.5);\nSₖ = find_analytical_S_k(k_array, ρ*π/6)\n\nγ = @. k_array^2*kBT/(m*Sₖ)\nkernel = ModeCouplingKernel(ρ, kBT, m, k_array, Sₖ)\nsol = solve_steady_state(γ, Sₖ, kernel; tolerance=10^-8, verbose=false)\nfk = get_F(sol.F, 1, :)\np = plot(k_array, fk, ylabel=\"non-ergodicity parameter\", xlabel=\"k\")","category":"page"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"(Image: image)","category":"page"},{"location":"Scope.html#Relaxation-time","page":"Scope","title":"Relaxation time","text":"","category":"section"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"Relaxation times can be easily extracted from dynamical data using the find_relaxation_time(t, F; threshold=exp(-1), mode=:log) function.","category":"page"},{"location":"Scope.html#Example-5","page":"Scope","title":"Example","text":"","category":"section"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"Let's solve mode-coupling theory to get some data:","category":"page"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"# We solve MCT for hard spheres at a volume fraction of 0.51591\nη = 0.51591; ρ = η*6/π; kBT = 1.0; m = 1.0\n\nNk = 100; kmax = 40.0; dk = kmax/Nk; k_array = dk*(collect(1:Nk) .- 0.5)\nSₖ = find_analytical_S_k(k_array, η)\n\n∂F0 = zeros(Nk); α = 1.0; β = 0.0; γ = @. k_array^2*kBT/(m*Sₖ); δ = 0.0\n\nkernel = ModeCouplingKernel(ρ, kBT, m, k_array, Sₖ)\nproblem = MemoryEquation(α, β, γ, δ, Sₖ, ∂F0, kernel)\nsolver = TimeDoublingSolver(Δt=10^-5, t_max=10.0^15, verbose=false, \n                     N = 8, tolerance=10^-8)\nsol = @time solve(problem, solver);","category":"page"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"We can now extract a single relaxation time by calling ","category":"page"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"julia> find_relaxation_time(get_t(sol), get_F(sol, :, 18)) # at k k_array[18]\n4.232796654132995e11","category":"page"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"To extract all relaxation times as a function of k:","category":"page"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"julia> t_R = [find_relaxation_time(get_t(sol), get_F(sol, :, ik)) for ik in eachindex(k_array)]; \njulia> p = plot(k_array, log10.(t_R), xlabel=\"k\", ylabel=\"log10(relaxation time)\", legend=false)","category":"page"},{"location":"Scope.html","page":"Scope","title":"Scope","text":"(Image: image)","category":"page"},{"location":"index.html#ModeCouplingTheory.jl","page":"Introduction","title":"ModeCouplingTheory.jl","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"This package provides a generic and fast solver of mode-coupling theory-like integrodifferential equations. It uses the algorithm outlined in Fuchs et al. to solve equations of the form","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"alpha ddotF(t) + beta dotF(t) + gamma F(t) + delta + int_0^t dtau K(t-tau)dotF(tau) = 0","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"in which alpha, beta, gamma, and delta are coefficients, and K(t) = K(F(t) t). This package exports some commonly used memory kernels, but it is straightforward to define your own. The solver is differentiable and works for scalar- and vector-valued functions F(t). ","category":"page"},{"location":"index.html#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"To install the package run:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"import Pkg\nPkg.add(\"ModeCouplingTheory\")","category":"page"},{"location":"index.html#Example","page":"Introduction","title":"Example","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"We can define one of the predefined memory kernels ","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"julia> using ModeCouplingTheory\njulia> ν = 3.999\n3.999\njulia> kernel = SchematicF2Kernel(ν)\nSchematicF2Kernel{Float64}(3.999)","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"This kernel evaluates K(t)=nu F(t)^2.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"We can now define the equation we want to solve as follows:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"julia> α = 1.0; β = 0.0; γ = 1.0; δ = 0.0; F0 = 1.0; ∂F0 = 0.0;\njulia> equation = MemoryEquation(α, β, γ, δ, F0, ∂F0, kernel)\nLinear MCT equation object:\n   α F̈ + β Ḟ + γF + δ + ∫K(τ)Ḟ(t-τ) = 0\nin which α is a Float64,\n         β is a Float64,\n         γ is a Float64,\n         δ is a Float64,\n  and K(t) is a SchematicF2Kernel{Float64}.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"and jula solver:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"julia> solver = TimeDoublingSolver()","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Now we can solve the equation by calling solve:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"julia> using Plots\njulia> sol = solve(equation, solver);\njulia> t = get_t(sol)\njulia> F = get_F(sol)\njulia> plot(log10.(t), F)","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"(Image: image)","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Full copy-pastable example:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"using ModeCouplingTheory, Plots\nν = 3.999\nα = 1.0; β = 0.0; γ = 1.0; δ = 0.0; F0 = 1.0; ∂F0 = 0.0;\nkernel = SchematicF2Kernel(ν)\nproblem = MemoryEquation(α, β, γ, δ, F0, ∂F0, kernel)\nsolver = TimeDoublingSolver()\nsol = solve(problem, solver);\nt = get_t(sol)\nF = get_F(sol)\nplot(log10.(t), F)","category":"page"},{"location":"internals.html#Overview-of-the-internals-of-ModeCouplingTheory.jl","page":"Internals","title":"Overview of the internals of ModeCouplingTheory.jl","text":"","category":"section"},{"location":"internals.html","page":"Internals","title":"Internals","text":"In order to be able to solve an \"MCT-like\" equation, one must construct an instance of an AbstractMemoryEquation, and optionally a Solver. Every AbstractMemoryEquation also needs a MemoryKernel in order to define the equation to be solved. These three are all abstract types such that extending this package to include functionality for different equations or different types of memory kernels is easy. For example, subtypes of MemoryKernel include SchematicF1Kernel and ModeCouplingKernel. Examples of Solvers are EulerSolver and TimeDoublingSolver. At this point, the only concrete AbstractMemoryEquation is a MemoryEquation, which implements the equation mentioned in the Introduction. ","category":"page"},{"location":"internals.html","page":"Internals","title":"Internals","text":"When concrete instances of a an AbstractMemoryEquation, and a Solver have been defined by the user, the function solve(problem::AbstractMemoryEquation, solver::Solver) is called to solve the equation defined by problem, with the memory kernel kernel using the solver solver. ","category":"page"},{"location":"internals.html","page":"Internals","title":"Internals","text":"Thus, in order to extend the functionality of this package to solve an equation of a different form, say:","category":"page"},{"location":"internals.html","page":"Internals","title":"Internals","text":"dotF(t) + a F(t)^p + int_0^tdtau K(tau)dotF(t-tau) = 0","category":"page"},{"location":"internals.html","page":"Internals","title":"Internals","text":"one needs to define ","category":"page"},{"location":"internals.html","page":"Internals","title":"Internals","text":"a new type of AbstractMemoryEquation (e.g. AnharmonicAbstractMemoryEquation <: AbstractMemoryEquation) which stores the coefficients a, p and initial conditions.\noptionally a new Solver (e.g. AnharmonicSolver <: Solver) type, which stores some solver settings, such as timesteps and tolerances. In the case that the solution method is very similar to one that is already implemented, (such as it is in this case), it might be possible to use the already defined solvers such as TimeDoublingSolver, only extending a few methods, see below. \na new solve method that dispatches on the above types to solve this equation with the right method (e.g. one needs to write the method solve(problem::AnharmonicAbstractMemoryEquation, solver::AnharmonicSolver)). However, in the case that e.g. TimeDoublingSolver can be reused, instead of a new solve method, one can also create new methods for lower-level function that solve(problem::AnharmonicAbstractMemoryEquation, solver::TimeDoublingSolver) calls, specializing for AnharmonicAbstractMemoryEquation, in order to implement the changes necessary to solve this AnharmonicAbstractMemoryEquation.","category":"page"},{"location":"internals.html","page":"Internals","title":"Internals","text":"The newly defined methods for this new equation should then work with any of the defined memory kernels. In summary, the real functionality of this package is implemented by the solve function. The memory kernel, solvers and problem types are used in order to specialize solve calls.","category":"page"},{"location":"internals.html#Internals-of-the-Fuchs-Solver","page":"Internals","title":"Internals of the Fuchs Solver","text":"","category":"section"},{"location":"internals.html","page":"Internals","title":"Internals","text":"The basic idea of the algorithm popularizd by Fuchs and coworkers was, that, in order to solve the equations over many orders of magnitude in time, it is helpful to periodically increase the time step of the grid on which the equation is solved. Below we give a more detailed overview of the implementation of the algorithm in this package.","category":"page"},{"location":"internals.html","page":"Internals","title":"Internals","text":"The equations are solved using these steps:","category":"page"},{"location":"internals.html","page":"Internals","title":"Internals","text":"allocate_temporary_arrays(problem::AbstractMemoryEquation, solver::TimeDoublingSolver) returns a SolverCache that is used internally to avoid unnecessary allocations.\ninitialize_temporary_arrays!(problem::AbstractMemoryEquation, solver::TimeDoublingSolver, kernel::MemoryKernel, temp_arrays::SolverCache): The algorithm is started by initializing temporary variables such as F and K discretised on the time grid of 4N points on t_i = iDelta t4N where i = 1ldots4N. F(t) is solved by a forward Euler method on the first 2N points to kickstart the algorithm. The effects of the memory integral is neglected here. \ndo_time_steps!(problem::AbstractMemoryEquation, solver::TimeDoublingSolver, kernel::MemoryKernel, temp_arrays::SolverCache): The full equation is discretised on the time points between i=2N+1 and i=4N. For each of these time points, the parameters C_1, C_2, and C_3 are calculated by update_Fuchs_parameters!(problem, solver, temp_arrays, i) as prescribed in the literature. Now, in order to solve for F(t_i), the fixed point of the mapping C_1 F  = -C_2 K(F) + C_3 is found by recurstive iteration. Convergence is established if the maximimal squared error is smaller than a set tolerance.\nallocate_results!(t_array, F_array, K_array, solver, temp_arrays::SolverCache) the results found by step 2, residing in temporary arrays are pushed to t_array, F_array, and K_array, which are returned when the program exits.\nnew_time_mapping!(problem, solver, temp_arrays::SolverCache): the results stored in the temporary variables temp_arrays.F_temp, temp_arrays.K_temp, temp_arrays.I_F, temp_arrays.I_K are mapped from the time points i=1ldots4N to the points i=1ldots2N as prescribed in the literature. The time step Delta t is also doubled.\nIf Δt > t_max the main loop exits and a solution object containing t_array, F_array, K_array, and the solver settings is returned. ","category":"page"},{"location":"internals.html","page":"Internals","title":"Internals","text":"For information on specific methods, see the next page of the documentation.","category":"page"},{"location":"API.html#Module-Index","page":"API Reference","title":"Module Index","text":"","category":"section"},{"location":"API.html","page":"API Reference","title":"API Reference","text":"Modules = [ModeCouplingTheory]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"API.html#Detailed-API","page":"API Reference","title":"Detailed API","text":"","category":"section"},{"location":"API.html","page":"API Reference","title":"API Reference","text":"Modules = [ModeCouplingTheory]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"API.html#ModeCouplingTheory.EulerSolver-Tuple{}","page":"API Reference","title":"ModeCouplingTheory.EulerSolver","text":"EulerSolver(equation::MemoryEquation; t_max=10.0^2, Δt=10^-3, verbose=false)\n\nConstructs a solver object that, when called solve upon will solve an MemoryEquation using a forward Euler method. It will discretise the integral using a Trapezoidal rule. Use this solver only for testing purposes. It is a wildy  inefficient way to solve MCT-like equations.\n\nArguments:\n\nequation an instance of MemoryEquation\nt_max when this time value is reached, the integration returns\nΔt fixed time step\nverbose if true, information will be printed to STDOUT\n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.ExponentiallyDecayingKernel","page":"API Reference","title":"ModeCouplingTheory.ExponentiallyDecayingKernel","text":"ExponentiallyDecayingKernel{T<:Number} <: MemoryKernel\n\nScalar kernel with fields ν and τ which when called returns ν exp(-t/τ).\n\n\n\n\n\n","category":"type"},{"location":"API.html#ModeCouplingTheory.InterpolatingKernel-Tuple{Any, Any}","page":"API Reference","title":"ModeCouplingTheory.InterpolatingKernel","text":"InterpolatingKernel(t, M; k=1)\n\nUses the package Dierckx to provide a kernel that interpolates the data M defined on grid t using spline interpolation of degree k. \n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.MemoryEquation-Tuple{Any, Any, Any, Any, Any, Any, MemoryKernel}","page":"API Reference","title":"ModeCouplingTheory.MemoryEquation","text":"MemoryEquation(α, β, γ, F₀::T, ∂ₜF₀::T, kernel::MemoryKernel) where T\n\nArguments:\n\nα: coefficient in front of the second derivative term. If α and F₀ are both vectors, α will automatically be converted to a diagonal matrix, to make them compatible.\nβ: coefficient in front of the first derivative term. If β and F₀ are both vectors, β will automatically be converted to a diagonal matrix, to make them compatible.\nγ: coefficient in front of the second derivative term. If γ and F₀ are both vectors, γ will automatically be converted to a diagonal matrix, to make them compatible.\nδ: coefficient in front of the constant term. δ and F0 must by types that can be added together. If δ is a number and F0 is a vector, this conversion will be done automatically.\nF₀: initial condition of F(t)\n∂ₜF₀ initial condition of the derivative of F(t)\nkernel instance of a MemoryKernel that when called on F₀ and t=0, evaluates to the initial condition of the memory kernel.\n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.MemoryEquationCoefficients-NTuple{5, Any}","page":"API Reference","title":"ModeCouplingTheory.MemoryEquationCoefficients","text":"MemoryEquationCoefficients(a, b, c, d, F₀)\n\nConstructor of the MemoryEquationCoefficients struct, which holds the values of the coefficients α, β, γ and δ. It will convert common cases automatically to make the types compatible. For example, if α and F0 are both given as vectors, α is converted to a Diagonal matrix. \n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.MemoryEquationSolution","page":"API Reference","title":"ModeCouplingTheory.MemoryEquationSolution","text":"MemoryEquationSolution\n\nsolution object that holds the solution of an AbstractMemoryEquation. It has 4 fields     t: array of t values     F: array of F for all t     K: array of K for all T     solver: solver object that holds the solver settings\n\nan MCT object can be indexed such that      sol=MemoryEquationSolution     sol[2]   gives the F[2] for all t.\n\n\n\n\n\n","category":"type"},{"location":"API.html#ModeCouplingTheory.SchematicDiagonalKernel","page":"API Reference","title":"ModeCouplingTheory.SchematicDiagonalKernel","text":"SchematicDiagonalKernel{T<:Union{SVector, Vector}} <: MemoryKernel\n\nMatrix kernel with field ν which when called returns Diagonal(ν .* F .^ 2), i.e., it implements a non-coupled system of SchematicF2Kernels.\n\n\n\n\n\n","category":"type"},{"location":"API.html#ModeCouplingTheory.SchematicF123Kernel","page":"API Reference","title":"ModeCouplingTheory.SchematicF123Kernel","text":"SchematicF1Kernel{T<:Number} <: MemoryKernel\n\nScalar kernel with fields ν1, ν2, and ν3 which when called returns ν1 * F^1 + ν2 * F^2 + ν3 * F^3.\n\n\n\n\n\n","category":"type"},{"location":"API.html#ModeCouplingTheory.SchematicF1Kernel","page":"API Reference","title":"ModeCouplingTheory.SchematicF1Kernel","text":"SchematicF1Kernel{T<:Number} <: MemoryKernel\n\nScalar kernel with field ν which when called returns ν F.\n\n\n\n\n\n","category":"type"},{"location":"API.html#ModeCouplingTheory.SchematicF2Kernel","page":"API Reference","title":"ModeCouplingTheory.SchematicF2Kernel","text":"SchematicF2Kernel{T<:Number} <: MemoryKernel\n\nScalar kernel with field ν which when called returns ν F^2.\n\n\n\n\n\n","category":"type"},{"location":"API.html#ModeCouplingTheory.SchematicMatrixKernel","page":"API Reference","title":"ModeCouplingTheory.SchematicMatrixKernel","text":"SchematicMatrixKernel{T<:Union{SVector, Vector}} <: MemoryKernel\n\nMatrix kernel with field ν which when called returns ν * F * Fᵀ, i.e., it implements Kαβ = νFαFβ.\n\n\n\n\n\n","category":"type"},{"location":"API.html#ModeCouplingTheory.SjogrenKernel","page":"API Reference","title":"ModeCouplingTheory.SjogrenKernel","text":"SjogrenKernel\n\nMemory kernel that implements the kernel K[1] = ν1 F[1]^2, K[2] = ν2 F[1] F[2]. Consider using Static Vectors for performance. \n\n\n\n\n\n","category":"type"},{"location":"API.html#ModeCouplingTheory.TaggedSchematicF2Kernel","page":"API Reference","title":"ModeCouplingTheory.TaggedSchematicF2Kernel","text":"SchematicF2Kernel{T<:Number} <: MemoryKernel\n\nScalar tagged particle kernel with field ν which when called returns ν F*Fs.\n\n\n\n\n\n","category":"type"},{"location":"API.html#ModeCouplingTheory.TimeDoublingSolver-Tuple{}","page":"API Reference","title":"ModeCouplingTheory.TimeDoublingSolver","text":"TimeDoublingSolver(N=32, Δt=10^-10, t_max=10.0^10, max_iterations=10^4, tolerance=10^-10, verbose=false, ismutable=true)\n\nUses the algorithm devised by Fuchs et al.\n\nArguments:\n\nequation: an instance of MemoryEquation\nN: The number of time points in the interval is equal to 4N\nt_max: when this time value is reached, the integration returns\nΔt: starting time step, this will be doubled repeatedly\nmax_iterations: the maximal number of iterations before convergence is reached for each time doubling step\ntolerance: while the error is bigger than this value, convergence is not reached. The error by default is computed as the absolute sum of squares\nverbose: if true, information will be printed to STDOUT\nismutable: if true and if the type of F is mutable, the solver will try to avoid allocating many temporaries\n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.MSDModeCouplingKernel-NTuple{7, Any}","page":"API Reference","title":"ModeCouplingTheory.MSDModeCouplingKernel","text":"MSDModeCouplingKernel(ρ, kBT, m, k_array, Sₖ, sol, taggedsol; dims=3)\n\nConstructor of a MSDModeCouplingKernel. It implements the kernel K(k,t) = ρ kBT / (6π^2m) ∫dq q^4 c(q)^2 F(q,t) Fs(q,t) where the integration runs from 0 to infinity. F and Fs are the coherent and incoherent intermediate scattering functions, and must be passed in as solutions of the corresponding equations.\n\nArguments:\n\nρ: number density\nkBT: Thermal energy\nm : particle mass\nk_array: vector of wavenumbers at which the structure factor is known\nSₖ: vector with the elements of the structure factor \nsol: a solution object of an equation with a ModeCouplingKernel.\ntaggedsol: a solution object of an equation with a TaggedModeCouplingKernel.\n\nReturns:\n\nan instance k of MSDModeCouplingKernel <: MemoryKernel, which can be evaluated like: k = evaluate_kernel(kernel, F, t)\n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.MSDMultiComponentModeCouplingKernel-Tuple{Int64, Vararg{Any, 7}}","page":"API Reference","title":"ModeCouplingTheory.MSDMultiComponentModeCouplingKernel","text":"MSDMultiComponentModeCouplingKernel(s, ρ, kBT, m, k_array, Sₖ, sol, taggedsol; dims=3)\n\nConstructor of a MSDModeCouplingKernel. It implements the kernel Kₛ(k,t) = ρ kBT / (6π^2mₛ) Σαβ ∫dq q^4 csα(q)csβ(q) Fαβ(q,t) Fₛ(q,t) where the integration runs from 0 to infinity. F and Fs are the coherent and incoherent intermediate scattering functions, and must be passed in as solutions of the corresponding equations.\n\nArguments:\n\ns: the species for which to solve this equation\nρ: number density\nkBT: Thermal energy\nm : particle mass of species s\nk_array: vector of wavenumbers at which the structure factor is known\nSₖ: vector with the elements of the structure factor \nsol: a solution object of an equation with a MultiComponentModeCouplingKernel.\ntaggedsol: a solution object of an equation with a TaggedMultiComponentModeCouplingKernel.\n\nReturns:\n\nan instance k of MSDMultiComponentModeCouplingKernel <: MemoryKernel, which can be evaluated like: k = evaluate_kernel(kernel, F, t)\n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.ModeCouplingKernel-NTuple{5, Any}","page":"API Reference","title":"ModeCouplingTheory.ModeCouplingKernel","text":"ModeCouplingKernel(ρ, kBT, m, k_array, Sₖ; dims=3)\n\nConstructor of a ModeCouplingKernel. It implements the kernel K(k,t) = ρ kBT / (16π^3m) ∫dq V^2(k,q) F(q,t) F(k-q,t) in which k and q are vectors. \n\nArguments:\n\nρ: number density\nkBT: Thermal energy\nm : particle mass\nk_array: vector of wavenumbers at which the structure factor is known\nSₖ: structure factor\n\nReturns:\n\nan instance k of ModeCouplingKernel <: MemoryKernel, which can be called both in-place and out-of-place: evaluate_kernel!(out, kernel, F, t) out = evaluate_kernel(kernel, F, t)\n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.MultiComponentModeCouplingKernel-NTuple{5, Any}","page":"API Reference","title":"ModeCouplingTheory.MultiComponentModeCouplingKernel","text":"MultiComponentModeCouplingKernel(ρ, kBT, m, k_array, Sₖ; dims=3)\n\nConstructor of a MultiComponentModeCouplingKernel. It implements the kernel Kαβ(k,t) = ρ  / (2 xα xβ (2π)³) Σμνμ'ν' ∫dq Vμ'ν'(k,q) Fμμ'(q,t) Fνν'(k-q,t) Vμν(k,q) in which k and q are vectors and α and β species labels. \n\nArguments:\n\nρ: vector of number densities for each species\nkBT: Thermal energy\nm : vector of particle masses for each species\nk_array: vector of wavenumbers at which the structure factor is known\nSₖ: a Vector of Nk SMatrixs containing the structure factor of each component at each wave number\n\nReturns:\n\nan instance k of ModeCouplingKernel <: MemoryKernel, which can be called both in-place and out-of-place: k = MultiComponentModeCouplingKernel(ρ, kBT, m, karray, Sₖ) `evaluatekernel!(out, kernel, F, t)out = evaluate_kernel(kernel, F, t)`\n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.TaggedModeCouplingKernel-NTuple{6, Any}","page":"API Reference","title":"ModeCouplingTheory.TaggedModeCouplingKernel","text":"TaggedModeCouplingKernel(ρ, kBT, m, k_array, Sₖ, sol; dims=3)\n\nConstructor of a Tagged ModeCouplingKernel. It implements the kernel K(k,t) = ρ kBT / (8π^3m) ∫dq V^2(k,q) F(q,t) Fs(k-q,t) in which k and q are vectors. Here V(k,q) = c(q) (k dot q)/k. \n\nArguments:\n\nρ: number density\nkBT: Thermal energy\nm : particle mass\nk_array: vector of wavenumbers at which the structure factor is known\nSₖ: vector with the elements of the structure factor \nsol: a solution object of an equation with a ModeCouplingKernel.\n\nReturns:\n\nan instance k of TaggedModeCouplingKernel <: MemoryKernel, which can be called both in-place and out-of-place: evaluate_kernel!(out, kernel, Fs, t) out = evaluate_kernel(kernel, Fs, t)\n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.TaggedMultiComponentModeCouplingKernel-Tuple{Int64, Vararg{Any, 6}}","page":"API Reference","title":"ModeCouplingTheory.TaggedMultiComponentModeCouplingKernel","text":"TaggedMultiComponentModeCouplingKernel(s, ρ, kBT, m, k_array, Sₖ, sol; dims=3)\n\nConstructor of a Tagged ModeCouplingKernel. It implements the kernel Kₛ(k,t) = ρ kBT / (8π^3 mₛ) Σαβ ∫dq V^2sαβ(k,q) Fαβ(q,t) Fₛ(k-q,t) in which k and q are vectors. \n\nArguments:\n\ns: the species for which to solve this equation\nρ: number density\nkBT: Thermal energy\nm : particle mass\nk_array: vector of wavenumbers at which the structure factor is known\nSₖ: vector with the elements of the structure factor \nsol: a solution object of an equation with a MultiComponentModeCouplingKernel.\n\nReturns:\n\nan instance k of TaggedMultiComponentModeCouplingKernel <: MemoryKernel, which can be called both in-place and out-of-place: evaluate_kernel!(out, kernel, Fs, t) out = evaluate_kernel(kernel, Fs, t)\n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.allocate_results!-Tuple{Any, Any, Any, AbstractMemoryEquation, TimeDoublingSolver, ModeCouplingTheory.SolverCache}","page":"API Reference","title":"ModeCouplingTheory.allocate_results!","text":"allocate_results!(t_array, F_array, K_array, equation::AbstractMemoryEquation, solver::TimeDoublingSolver, temp_arrays::SolverCache; istart=2(solver.N)+1, iend=4(solver.N))\n\npushes the found solution, stored in temp_arrays with indices istart until istop to the output arrays.\n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.allocate_temporary_arrays-Tuple{MemoryEquation, TimeDoublingSolver}","page":"API Reference","title":"ModeCouplingTheory.allocate_temporary_arrays","text":"allocate_temporary_arrays(equation::AbstractMemoryEquation, solver::TimeDoublingSolver)\n\nReturns a SolverCache containing several arrays that are used for intermediate calculations.\n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.compute_C3_immutable-Tuple{MemoryEquation, TimeDoublingSolver, ModeCouplingTheory.SolverCache, Int64}","page":"API Reference","title":"ModeCouplingTheory.compute_C3_immutable","text":"computec3immutable(equation::MemoryEquation, solver::TimeDoublingSolver, temp_arrays::SolverCache, it::Int)\n\ncomputes one of the matrices necessary to propagate F in time.\n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.compute_C3_mutable!-Tuple{MemoryEquation, TimeDoublingSolver, ModeCouplingTheory.SolverCache, Int64}","page":"API Reference","title":"ModeCouplingTheory.compute_C3_mutable!","text":"computec3mutable(equation::MemoryEquation, solver::TimeDoublingSolver, temp_arrays::SolverCache, it::Int)\n\ncomputes one of the matrices necessary to propagate F in time, by mutating it inplace. The commented code is the corresponding scalar equivalent\n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.convert_multicomponent_structure_factor-Union{Tuple{Array{Vector{T}, 2}}, Tuple{T}} where T","page":"API Reference","title":"ModeCouplingTheory.convert_multicomponent_structure_factor","text":"`convert_multicomponent_structure_factor(Sk_in::Matrix{Vector{T}})``\n\nThis function takes a matrix of vectors Sk_in where each vector  contains structure factor information for different species  at different k-points and converts it into a vector of SMatrix.\n\nInput:\n\nSk_in::Matrix{Vector{T}} - A square matrix of vectors, where each vector contains structure factor information for a specific set of species at different k-points.\n\nOutput:\n\nSk_out - A Vector of SMatrix where each SMatrix contains structure factor information for different species at a single k-point.\n\nExample\n\nNs = 2;\nNk = 3;\nS11 = [1,2,3]; S21 = [4,5,6]; S22 = [8,9,10];\nS = [zeros(Nk) for i=1:2, j=1:2];\nS[1,1] = S11; S[1,2] = S21; S[2,1] = S21; S[2,2] = S22;\nconvert_multicomponent_structure_factor(S)\n\n    3-element Vector{StaticArraysCore.SMatrix{2, 2, Float64, 4}}:\n    [1.0 4.0; 4.0 8.0]\n    [2.0 5.0; 5.0 9.0]\n    [3.0 6.0; 6.0 10.0]\n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.do_time_steps!-Tuple{AbstractMemoryEquation, TimeDoublingSolver, Any, ModeCouplingTheory.AbstractSolverCache}","page":"API Reference","title":"ModeCouplingTheory.do_time_steps!","text":"do_time_steps!(equation::MemoryEquation, solver::TimeDoublingSolver, kernel::MemoryKernel, temp_arrays::SolverCache)\n\nSolves the equation on the time points with index 2N+1 until 4N, for each point doing a recursive iteration to find the solution to the nonlinear equation C1 F  = -C2 M(F) + C3.\n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.evaluate_kernel!-Tuple{Any, MemoryKernel, Any, Any}","page":"API Reference","title":"ModeCouplingTheory.evaluate_kernel!","text":"evaluate_kernel!(out, kernel::MemoryKernel, F, t)\n\nEvaluates the memory kernel in-place, overwriting the elements of the out variable. It may mutate the content of kernel.\n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.evaluate_kernel-Tuple{MemoryKernel, Any, Any}","page":"API Reference","title":"ModeCouplingTheory.evaluate_kernel","text":"evaluate_kernel(kernel::MemoryKernel, F, t)\n\nEvaluates the memory kernel out-place. It may mutate the content of kernel.\n\nReturns\n\nout the kernel evaluated at (F, t)\n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.find_error-Union{Tuple{T}, Tuple{T, T}} where T","page":"API Reference","title":"ModeCouplingTheory.find_error","text":"find_error(F_new::T, F_old::T) where T\n\nFinds the error between a new and old iteration of F. The returned scalar will be compared  to the tolerance to establish convergence. \n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.find_relaxation_time-Tuple{Any, Vector{<:Number}}","page":"API Reference","title":"ModeCouplingTheory.find_relaxation_time","text":"find_relaxation_time(t, F; threshold=exp(-1), mode=:log)\n\nFinds the time at which a signal first decreases below some threshold. Uses interpolation to find an accurate result. if it never decreases below the threshold, returns Inf.\n\nArguments:\n\nt: a vector of time values at which the signal F is known\nF: the signal\nthreshold: see above\nmode: uses interpolation either in a logarithmic or linear space. \n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.get_F-Tuple{ModeCouplingTheory.MemoryEquationSolution}","page":"API Reference","title":"ModeCouplingTheory.get_F","text":"`get_F(sol::MemoryEquationSolution)`\n\nobtains the solution F from a MemoryEquationSolution object. Equivalent to sol.F.\n\n`get_F(sol::MemoryEquationSolution, I...)`\n\nobtains the solution F from a MemoryEquationSolution object and indexes into it. Enables convenient indexing into the multidimensional object.  I is interpreted as a set of indices. \n\nExamples:\n\nIf sol is the solution to a scalar equation get_F(sol, 2:4) gets the elements 2:4 If sol is the solution to a vector-valued equation get_F(sol, 5, 2:43) gets the solution at the 5th time point for vector indices 2:43. If sol is the solution to a vector-valued multicomponent equation get_F(sol, 5, 2:43, (1,2)) gets the solution at the 5th time point for vector indices 2:43, for species 1 and 2.\n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.get_K-Tuple{ModeCouplingTheory.MemoryEquationSolution, Any, Any}","page":"API Reference","title":"ModeCouplingTheory.get_K","text":"`get_K(sol::MemoryEquationSolution)`\n\nobtains the kernel K from a MemoryEquationSolution object. Equivalent to sol.K.\n\n`get_K(sol::MemoryEquationSolution, I...)`\n\nobtains the solution K from a MemoryEquationSolution object and indexes into it. Enables convenient indexing into the multidimensional object. See get_F for examples.\n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.get_t-Tuple{ModeCouplingTheory.MemoryEquationSolution}","page":"API Reference","title":"ModeCouplingTheory.get_t","text":"`get_t(sol::MemoryEquationSolution)`\n\nobtains the time grid t from a MemoryEquationSolution object. Equivalent to sol.t.\n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.initialize_F_temp!-Tuple{MemoryEquation, TimeDoublingSolver, ModeCouplingTheory.SolverCache}","page":"API Reference","title":"ModeCouplingTheory.initialize_F_temp!","text":"initialize_F_temp!(equation::MemoryEquation, solver::TimeDoublingSolver, temp_arrays::SolverCache)\n\nFills the first 2N entries of the temporary arrays of F using forward Euler without a memory kernel in order to kickstart the algorithm' scheme.\n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.initialize_K_temp!-Tuple{TimeDoublingSolver, MemoryKernel, ModeCouplingTheory.SolverCache}","page":"API Reference","title":"ModeCouplingTheory.initialize_K_temp!","text":"initialize_K_temp!(solver::TimeDoublingSolver, kernel::MemoryKernel, temp_arrays::SolverCache)\n\nEvaluates the memory kernel at the first 2N time points.\n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.initialize_integrals!-Tuple{AbstractMemoryEquation, TimeDoublingSolver, ModeCouplingTheory.SolverCache}","page":"API Reference","title":"ModeCouplingTheory.initialize_integrals!","text":"initialize_integrals!(equation::AbstractMemoryEquation, solver::TimeDoublingSolver, temp_arrays::SolverCache)\n\nInitializes the integrals on the first 2N time points as prescribed in the literature.\n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.initialize_output_arrays-Tuple{AbstractMemoryEquation}","page":"API Reference","title":"ModeCouplingTheory.initialize_output_arrays","text":"initialize_output_arrays(equation::AbstractMemoryEquation)\n\ninitializes arrays that the solver will push results into.\n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.mymul!-NTuple{5, Any}","page":"API Reference","title":"ModeCouplingTheory.mymul!","text":"\"     mymul!(c,a,b,α,β)\n\nprescribes how types used in this solver should be multiplied in place. In particular, it performs C.= βC .+ αa*b. defaults to mul!(c,a,b,α,β)\n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.new_time_mapping!-Tuple{AbstractMemoryEquation, TimeDoublingSolver, ModeCouplingTheory.SolverCache}","page":"API Reference","title":"ModeCouplingTheory.new_time_mapping!","text":"newtimemapping!(equation::AbstractMemoryEquation, solver::TimeDoublingSolver, temp_arrays::SolverCache)\n\nPerforms the time mapping central to Fuchs' algorithm with the conventions prescribed in  \"Flenner, Elijah, and Grzegorz Szamel. Physical Review E 72.3 (2005): 031508\".  Performs them inplace if solver.inplace = true in order to avoid unnecessary allocations.\n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.solve-Tuple{AbstractMemoryEquation, ModeCouplingTheory.Solver}","page":"API Reference","title":"ModeCouplingTheory.solve","text":"solve(equation::AbstractMemoryEquation, solver::Solver)\n\nSolves the AbstractMemoryEquation with the provided kernel using solver.  Search for a specific solver or kernel object to find more specific information.\n\nIf no solver is provided, it uses the default TimeDoublingSolver. \n\nReturns:\n\nt an array of time values\nF The solution in an array of which the last dimension corresponds to the time.\nK The memory kernel corresponding to each F\n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.solve_steady_state-Tuple{Any, Any, Any}","page":"API Reference","title":"ModeCouplingTheory.solve_steady_state","text":"solve_steady_state(γ, F₀, kernel; tolerance=10^-8, max_iterations=10^6, verbose=false, inplace=true)\n\nFinds the steady-state solution (non-ergodicity parameter) of the generalized Langevin equation by recursive iteration of F = (K + γ)⁻¹ * K(F) * F₀ This function assumes δ = 0, since that would lead to a divergence.\n\nArguments:\n\nγ: parameter in front of the linear term in F\nF₀: initial condition of F. This is also the initial condition of the rootfinding method.\nkernel: callable memory kernel\nmax_iterations: the maximal number of iterations before convergence is reached\ntolerance: while the error is bigger than this value, convergence is not reached. The error by default is computed as the absolute sum of squares between successive iterations\nverbose: if true, information will be printed to STDOUT\ninplace: if true and if the type of F is mutable, the solver will try to avoid allocating many temporaries. default =true``\n\nReturns:\n\nThe steady state solution\n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.update_F!-Tuple{MemoryEquation, TimeDoublingSolver, ModeCouplingTheory.SolverCache, Int64}","page":"API Reference","title":"ModeCouplingTheory.update_F!","text":"update_F!(solver::TimeDoublingSolver, temp_arrays::SolverCache, it::Int)\n\nupdates F using the formula c1F = -KC2 + C3.\n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.update_Fuchs_parameters!-Tuple{MemoryEquation, TimeDoublingSolver, ModeCouplingTheory.SolverCache, Int64}","page":"API Reference","title":"ModeCouplingTheory.update_Fuchs_parameters!","text":"update_Fuchs_parameters!(equation::MemoryEquation, solver::TimeDoublingSolver, temp_arrays::SolverCache, it::Int)\n\nUpdates the parameters c1, c2, c3, according to the appendix of  \"Flenner, Elijah, and Grzegorz Szamel. Physical Review E 72.3 (2005): 031508\" using the naming conventions from that paper. If F is mutable (and therefore also c1,c2,c3), it will update the variables in place, otherwise it will create new copies. This is controlled by the solver.inplace  setting.\n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.update_K!-Tuple{TimeDoublingSolver, MemoryKernel, ModeCouplingTheory.SolverCache, Int64}","page":"API Reference","title":"ModeCouplingTheory.update_K!","text":"update_K!(solver::TimeDoublingSolver, kernel::MemoryKernel, temp_arrays::SolverCache, it::Int)\n\nevaluates the memory kernel, updating the value in solver.temparrays.Ktemp    \n\n\n\n\n\n","category":"method"},{"location":"API.html#ModeCouplingTheory.update_integrals!-Tuple{ModeCouplingTheory.SolverCache, AbstractMemoryEquation, Int64}","page":"API Reference","title":"ModeCouplingTheory.update_integrals!","text":"update_integrals!(solver::TimeDoublingSolver, equation::AbstractMemoryEquation, temp_arrays::SolverCache, it::Int)\n\nUpdate the discretisation of the integral of F and K, see the literature for details.\n\n\n\n\n\n","category":"method"}]
}
