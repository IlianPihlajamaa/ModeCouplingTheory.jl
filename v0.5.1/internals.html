<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Internals · ModeCouplingTheory</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">ModeCouplingTheory</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Introduction</a></li><li><a class="tocitem" href="Problems_and_Solvers.html">Problems and Solvers</a></li><li><a class="tocitem" href="Kernels.html">Kernels</a></li><li><a class="tocitem" href="Scope.html">Scope</a></li><li><a class="tocitem" href="FromPython.html">From Python</a></li><li class="is-active"><a class="tocitem" href="internals.html">Internals</a><ul class="internal"><li><a class="tocitem" href="#Overview-of-the-internals-of-ModeCouplingTheory.jl"><span>Overview of the internals of ModeCouplingTheory.jl</span></a></li><li><a class="tocitem" href="#Internals-of-the-Fuchs-Solver"><span>Internals of the Fuchs Solver</span></a></li></ul></li><li><a class="tocitem" href="API.html">API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="internals.html">Internals</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="internals.html">Internals</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/IlianPihlajamaa/ModeCouplingTheory.jl/blob/main/docs/src/internals.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="Overview-of-the-internals-of-ModeCouplingTheory.jl"><a class="docs-heading-anchor" href="#Overview-of-the-internals-of-ModeCouplingTheory.jl">Overview of the internals of ModeCouplingTheory.jl</a><a id="Overview-of-the-internals-of-ModeCouplingTheory.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Overview-of-the-internals-of-ModeCouplingTheory.jl" title="Permalink"></a></h2><p>In order to be able to solve an &quot;MCT-like&quot; equation, one must construct an instance of an <code>MCTEquation</code>, and optionally a <code>Solver</code>. Every <code>MCTEquation</code> also needs a <code>MemoryKernel</code> in order to define the equation to be solved. These three are all abstract types such that extending this package to include functionality for different equations or different types of memory kernels is easy. For example, subtypes of <code>MemoryKernel</code> include <code>SchematicF1Kernel</code> and <code>ModeCouplingKernel</code>. Examples of <code>Solver</code>s are <code>EulerSolver</code> and <code>FuchsSolver</code>. At this point, the only concrete <code>MCTEquation</code> is a <code>LinearMCTEquation</code>, which implements the equation mentioned in the <a href="https://ilianpihlajamaa.github.io/ModeCouplingTheory.jl/dev/index.html">Introduction</a>. </p><p>When concrete instances of a an <code>MCTEquation</code>, and a <code>Solver</code> have been defined by the user, the function <code>solve(problem::MCTEquation, solver::Solver)</code> is called to solve the equation defined by <code>problem</code>, with the memory kernel <code>kernel</code> using the solver <code>solver</code>. </p><p>Thus, in order to extend the functionality of this package to solve an equation of a different form, say:</p><p class="math-container">\[\dot{F}(t) + a F(t)^p + \int_0^td\tau K(\tau)\dot{F}(t-\tau) = 0\]</p><p>one needs to define </p><ul><li>a new type of <code>MCTEquation</code> (e.g. <code>AnharmonicMCTEquation &lt;: MCTEquation</code>) which stores the coefficients <span>$a$</span>, <span>$p$</span> and initial conditions.</li><li>optionally a new <code>Solver</code> (e.g. <code>AnharmonicSolver &lt;: Solver</code>) type, which stores some solver settings, such as timesteps and tolerances. In the case that the solution method is very similar to one that is already implemented, (such as it is in this case), it might be possible to use the already defined solvers such as <code>FuchsSolver</code>, only extending a few methods, see below. </li><li>a new <code>solve</code> method that dispatches on the above types to solve this equation with the right method (e.g. one needs to write the method <code>solve(problem::AnharmonicMCTEquation, solver::AnharmonicSolver)</code>). However, in the case that e.g. <code>FuchsSolver</code> can be reused, instead of a new <code>solve</code> method, one can also create new methods for lower-level function that <code>solve(problem::AnharmonicMCTEquation, solver::FuchsSolver)</code> calls, specializing for <code>AnharmonicMCTEquation</code>, in order to implement the changes necessary to solve this <code>AnharmonicMCTEquation</code>.</li></ul><p>The newly defined methods for this new equation should then work with any of the defined memory kernels. In summary, the real functionality of this package is implemented by the <code>solve</code> function. The memory kernel, solvers and problem types are used in order to specialize solve calls.</p><h2 id="Internals-of-the-Fuchs-Solver"><a class="docs-heading-anchor" href="#Internals-of-the-Fuchs-Solver">Internals of the Fuchs Solver</a><a id="Internals-of-the-Fuchs-Solver-1"></a><a class="docs-heading-anchor-permalink" href="#Internals-of-the-Fuchs-Solver" title="Permalink"></a></h2><p>The basic idea of the algorithm popularizd by Fuchs and coworkers was, that, in order to solve the equations over many orders of magnitude in time, it is helpful to periodically increase the time step of the grid on which the equation is solved. Below we give a more detailed overview of the implementation of the algorithm in this package.</p><p>The equations are solved using these steps:</p><ol><li><code>allocate_temporary_arrays(problem::MCTEquation, solver::FuchsSolver)</code> returns a <code>FuchsTempStruct</code> that is used internally to avoid unnecessary allocations.</li><li><code>initialize_temporary_arrays!(problem::MCTEquation, solver::FuchsSolver, kernel::MemoryKernel, temp_arrays::FuchsTempStruct)</code>: The algorithm is started by initializing temporary variables such as <span>$F$</span> and <span>$K$</span> discretised on the time grid of <span>$4N$</span> points on <span>$t_i = i\Delta t/4N$</span> where <span>$i = 1,\ldots,4N$</span>. <span>$F(t)$</span> is solved by a forward Euler method on the first <span>$2N$</span> points to kickstart the algorithm. The effects of the memory integral is neglected here. </li><li><code>do_time_steps!(problem::MCTEquation, solver::FuchsSolver, kernel::MemoryKernel, temp_arrays::FuchsTempStruct)</code>: The full equation is discretised on the time points between <span>$i=2N+1$</span> and <span>$i=4N$</span>. For each of these time points, the parameters <span>$C_1$</span>, <span>$C_2$</span>, and <span>$C_3$</span> are calculated by <code>update_Fuchs_parameters!(problem, solver, temp_arrays, i)</code> as prescribed in the literature. Now, in order to solve for <span>$F(t_i)$</span>, the fixed point of the mapping <span>$C_1 F  = -C_2 K(F) + C_3$</span> is found by recurstive iteration. Convergence is established if the maximimal squared error is smaller than a set tolerance.</li><li><code>allocate_results!(t_array, F_array, K_array, solver, temp_arrays::FuchsTempStruct)</code> the results found by step 2, residing in temporary arrays are pushed to <code>t_array</code>, <code>F_array</code>, and <code>K_array</code>, which are returned when the program exits.</li><li><code>new_time_mapping!(problem, solver, temp_arrays::FuchsTempStruct)</code>: the results stored in the temporary variables <code>temp_arrays.F_temp</code>, <code>temp_arrays.K_temp</code>, <code>temp_arrays.I_F</code>, <code>temp_arrays.I_K</code> are mapped from the time points <span>$i=1\ldots4N$</span> to the points <span>$i=1\ldots2N$</span> as prescribed in the literature. The time step <span>$\Delta t$</span> is also doubled.</li><li>If <code>Δt &gt; t_max</code> the main loop exits and the arrays <code>t_array</code>, <code>F_array</code>, and <code>K_array</code> are returned. </li></ol><p>For information on specific methods, see the next page of the documentation.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="FromPython.html">« From Python</a><a class="docs-footer-nextpage" href="API.html">API Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Thursday 3 November 2022 09:02">Thursday 3 November 2022</span>. Using Julia version 1.8.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
